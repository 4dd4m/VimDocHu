*usr_24.txt*	For Vim version 8.2.  Last change: 2018 Mar 18

		  Bram Moolenaar: Vim felhasználói kézikönyv

			     Beszúrás gyorsan


A szövegek beszúrásnak folyamatát számos billentyűkombináció igyekszik
lerövidíteni és ezzel minimalizálni a hibalehetőségeket. Egészítsd ki a
félkész szavakat, rövidíts le szavakat. Gépelj olyan karaktereket, melyek nem
szerepelnek a billentyűzeteden.

|24.1|	Korrekciók
|24.2|	Egyezések mutatás
|24.3|	Kiegészítés
|24.4|	Szerkesztés ismétlése
|24.5|	Másolás másik sorból
|24.6|	Regiszter tartalmának beszúrása
|24.7|	Rövidítések
|24.8|	Speciális karakterek
|24.9|	Digrammák
|24.10|	Normal módú parancsok

Következő fejezet: |usr_25.txt|  Editing formatted text
    Előző fejezet: |usr_23.txt|  Editing other files
  Tartalomjegyzék: |usr_toc.txt|

==============================================================================
*24.1*	Korrekciót

A <BS> billentyű funkcióját már ismerjük.  Egy karakter töröl a kurzor előtt.
A <Del> billentyű pedig egy karaktert töröl a kurzor után (alatt).
   Ha egy egész szót újra szeretnél gépelni, akkor CTRL-W

	The horse had fallen to the sky ~
				       CTRL-W
	The horse had fallen to the ~

Ha valamit nagyon nem úgy szerettél volna, akkor a CTRL-U paranccsal az egész
sort törölheted. Ez megtartja a kurzor utáni karaktereket, illetve a sor eleji
behúzást. A sor első nem üres karakterétől a kurzorig töröl. Ha a kurzorunk a
"fallen" szó "f" betűjén áll, akkor ez történik:

	The horse had fallen to the ~
		      CTRL-U
	fallen to the ~

Ha pár szóval hátrébb fedezted fel a hibát, akkor a kurzorral vissza kell
menned arra a pontra. Például, ezt gépelted:

	The horse had follen to the ground ~

A "follen" szót ki kell cserélned "fallenre". A sor végén álló kurzorral így
korrigálhatod a problémát: >

					<Esc>4blraA

<	kilépés insert módból		<Esc>
	négy szót hátra			     4b
	"o"-ra ugrás			       l
	csere "a"-ra				ra
	vissza Insert módba			  A

Másik módszer: >

		<C-Left><C-Left><C-Left><C-Left><Right><Del>a<End>

<	négy szót hátra		     <C-Left><C-Left><C-Left><C-Left>
	"o"-ra ugrás				<Right>
	"o" törlése					<Del>
	"a" beszúrása					    a
	sor végére ugrás				    <End>

Az utóbbi módszer speciális billentyűt használ a korrigáláshoz, az első pedig
végig Insert módban marad. Ez kellőképpen szemlélteti a nem-modális
szerkesztő munkamenetét. Könnyebb megjegyezni, do sokkal tovább tart
végrehajtani (kezeidet a kurzorbillentyűkhöz viszed, az <End> billentyűért
pedig valószínűleg le kell pillantanod. 
   Ezeket speciális billentyűk arra jók, hogy segítségükkel olyan mappeket
hozzunk létre, ami nem hagyja el az Insert módot. Így pedig az extra gépelés
nem számít.
   Áttekintés az Insert módban használható billentyűkről:

	<C-Home>	fájl kezdetéhez ugrás
	<PageUp>	teljes képernyőt fel
	<Home>		sor kezdetéhez ugrás
	<S-Left>	egy szót balra
	<C-Left>	egy szót balra
	<S-Right>	egy szót jobbra
	<C-Right>	egy szót balra
	<End>		sor végéhez ugrás
	<PageDown>	egy teljes képernyőt le
	<C-End>		fájl végéhez ugrás

Ennél több létezik,  |ins-special-special|.

==============================================================================
*24.2*	Egyezések mutatása

Ha ) karaktert gépelsz, akkor jó lenne látni a párját (. Ehhez add ki az
alábbi parancsot: >

	:set showmatch

Szövegbevitelkor például a "(example)" gépelésénél, rögtön miután ) karaktert
gépelsz, a Vim egy pillanatra felvillantja a párját, melyhez odaugrik, aztán
vissza a kurzor eredeti helyére. 
   Ha nem találja meg a zárókarakter párját ( ( ), akkor hangjelzést ad. Így
tudod, hogy elfelejtettél valamit, vagy túl sokat gépeltél.
   Az ellenőrzés a [] és a {} párokra is kiterjed. Nem kell megvárnod, amíg az
ellenőrzés fut, gépelhetsz tovább.
   A várakozási időt itt beállíthatod 'matchtime'. Például, másfél másodperces
időköz. >

	:set matchtime=15

Az egység 0.1s.

==============================================================================
*24.3*	Kiegészítés

A Vim képes a begépelt szavak kiegészítésére. A szó első részét begépeled,
nyomj CTRL-P-t és a Vim megpróbálja kiegészíteni.
   Tegyük fel, hogy C program szerkesztésekor ezt szeretnéd beírni:

	total = ch_array[0] + ch_array[1] + ch_array[2]; ~

Eddig beírsz mindent:

	total = ch_array[0] + ch_ ~

Itt azt mondod a Vimnek, hogy próbálja kiegészíteni a szót. CTRL-P-t nyomva a
szerkesztő ellenőrzi a fájlt és olyan szavak után néz, melyek az aktuális
szavunk karaktereivel kezdődnek. Ebben az esetben a "ch_" megtalálható a
"ch_array" szóban, azért a parancs után a következőket látod: 

	total = ch_array[0] + ch_array ~

Még kicsivel többet gépelsz és ide jutsz (a sor végén szóköz található):

	total = ch_array[0] + ch_array[1] + ~

Ha most nyomsz CTRL-P-t, akkor a olyan szavak után néz, melyek kiegészíthetnék
a kurzort. Mivel még nem gépeltünk semmit (üres karakter), ezért a Vim elkezd
visszafelé keresni teljes szavak után, az első szót megtalálja visszafelé
"ch_array". CTRL-P újbóli megnyitása a következő egyező szóra egészít ki, ami
a "total". A harmadik CTRL-P billentyűparancsra még hátrébb lép a listában. Ha
elfogynak a szavak, akkor a szerkesztő visszatér az eredeti szóhoz. És így
tovább.

Az előre kereséshez nyomj CTRL-N-t. A mechanizmus teljesen ugyan az, az irány
kivételével. A keresés újrakezdődik a fájl elejétől, így gyakorlatilag a lista
ugyanazokat az elemeket tartalmazza, csak fordított sorrendben.


A Vim hatalmas erőfeszítést tesz, hogy ki tudja egészíteni a szavainkat.
Alapértelmezett beállításokkal az alábbi helyeken keres:

	1. Az aktív fájlban
	2. A többi ablakban megnyitott fájlokon
	3. Egyéb betöltött fájlokon (rejtett buffer)
	4. Olyan fájlokban, melyek nincsenek betöltve (inaktív buffer)
	5. Tag fájlokban
	6. Az összes fájlban #include-olt fájlban.


BEÁLLÍTÁSOK

A keresési sorrendet a 'complete' opcióban megváltoztathatod.

Az 'ignorecase' hatással van a kiegészítésre, ami ha be van állítva, akkor a
program nem tesz különbséget nagy- és kisbetű között.

A kiegészítés speciális beállítása a 'infercase'. Ez hasznos az ilyen jellegű
kereséseknél ('ignorecase' opció bekapcsolt állapotában kell, hogy legyen),
dinamikusan kezeli a nagy- és kisbetűket. Például, ha "For"-t gépelsz, akkor a
Vim megtalálja a "fortunately" szót, de "Fortunately"-ként lesz kiegészítve.


SPECIÁLIS ELEMEK KIEGÉSZÍTÉSE

Ha tisztában vagy a keresés jellegével, akkor ezeket a parancsokat
használhatod:

	CTRL-X CTRL-F		fájlnevek
	CTRL-X CTRL-L		teljes sorok
	CTRL-X CTRL-D		makró definíciók (az #includeolt fájlokban is)
	CTRL-X CTRL-I		aktív és #includeolt fájlok
	CTRL-X CTRL-K		szavak szótár alapján
	CTRL-X CTRL-T		Thesaurus szavak
	CTRL-X CTRL-]		tagek
	CTRL-X CTRL-V		Vim command-line

Az összes parancs esetén megegyezik a navigáció: CTRL-N a következő találatra,
 CTRL-P pedig az előzőre ugrik.
   A parancsokról további részleteket olvashatsz: |ins-completion|.


FÁJLNEVEK KIEGÉSZÍTÉSE

Vegyük például a CTRL-X CTRL-F kombinációt. Ez fájlnevekre keres. Végigjárja a
munkakönyvtárat és az összes egyezést megjeleníti a kurzor előtt.
   Tegyük fel, hogy munkakönyvtáradban az alábbi fájlok találhatóak:

	main.c  sub_count.c  sub_done.c  sub_exit.c

Válts Insert módra és kezdd el gépelni:

	The exit code is in the file sub ~

Ezen a ponton ad ki a CTRL-X CTRL-F parancsot. Keresés kezdődik a
munkakönyvtárban olyan fájlok után, melyek "sub" karakterekkel kezdődnek. Az
első találat a "sub_count.c" fájl. Nem ezt a fájlt szeretted volna, ezért
lépsz a következőre CTRL-N. A következő találat a "dub_done.c". Egy újabb
CTRL-N végül "sub_exit.c"-n landol. Az eredmény:

	The exit code is in the file sub_exit.c ~

Nem számít, hogy milyen formátumú az elérési út, kezdődhet / jellel (Unix),
vagy C:\-vel (MS-Windows), a fájlrendszeren minden egyes fájl megtalálható.
Például, "/u" szó CTRL-X CTRL-F-el "/usr" szóra egészít (csak Unixon):

	the file is found in /usr/ ~

CTRL-N visszatér az eredeti szóra "/u". CTRL-X CTRL-F-el elfogadhatod a
"/usr/" kiegészítést és az alkönyvtárba léphetsz (ez nincs hatással az
munkakönyvtáradra, elérési utak esetén a Vim képes akármilyen mélységig
kiegészíteni).

	the file is found in /usr/X11R6/ ~

Az eredmény csak attól függ, hogy mi található a fájlrendszereden. Az
egyezések betűrend alapján rendezettek.


FORRÁSKÓD KIEGÉSZÍTÉSE

A forráskódok jól struktúráltak, ezáltal a kiegészítésnek egy intelligensebb
változatát teszi lehetővé. Ez a Vimben Omni kiegészítésnek hívjuk. Más
szerkesztőkben pedig intellisensenek, ami ráadásul jogvédett.

Az Omni kiegészítés kombinációja a CTRL-X CTRL-O. Az O ebben a kontextusban
"Omni"-t jelent, így könnyebb megjegyezni. Szemléljük meg a működését:

	{ ~
	    struct foo *p; ~
	    p-> ~

Kurzorunk a "p->" karakterek után áll. CTRL-X CTRL-O. Számos alternatíva közül
választhatsz, melyeket a "struct foo" tartalmaz. Ez picit különbözik a CTRL-P
működésétől, ami bármely szóra egészítene, itt csak "struct foo" tagjai
érvényesek.

Az Omni kiegészítés beállításához be kell állítanunk pár dolgot. Győződj meg
arról, hogy a filetype plugin használata engedélyezve van. Ha a vimrc fájlod
tartalmazza ezt: >
	filetype plugin on
vagy ezt a sort: >
	filetype plugin indent on

Akkor minden rendben. C kódokhoz készítenünk kell egy tag fájlt a 'tags'
opcióval. Részletesen  |ft-c-omni|. Egyéb fájltípusokhoz valami hasonlót kell
csinálnod |compl-omni-filetypes|. Nem működik minden fájltípusnál. Az
'omnifunc' opció értékének ellenőrzésével kiderítheted, hogy mely fájltípusokkal
működik.

==============================================================================
*24.4*	Szerkesztés ismétlése

Ha CTRL-A-t ütsz (Insert módban), akkor az utolsó szerkesztésed (Insert mód) 
szövegét automatikusan beilleszti a program.
   Például, van egy fájlod, ami így kezdődik:

	"file.h" ~
	/* Main program begins */ ~

A szerkesztéseddel az "#include "-ot hozzáadod a sor elejére:

	#include "file.h" ~
	/* Main program begins */ ~

A következő sor elejére ugrasz "j^", Insert módra váltasz, ahová ismét beírsz
egy "#include"-ot, de immáron így: >

	i CTRL-A

Mely ezt eredményezi:

	#include "file.h" ~
	#include /* Main program begins */ ~

Az "#include " azért került be a bufferbe, mert CTRL-A megismételte az előző
szerkesztésedet. Már csak annyit dolgod van, hogy beírod a fájlnevet
"main.h"<Enter>:

	#include "file.h" ~
	#include "main.h" ~
	/* Main program begins */ ~

A CTRL-@ parancs ugyan az, mint a CTRL-A, csak ki is lép Insert módból.
Repetitív beillesztések ellenszere.

==============================================================================
*24.5*	Másolás másik sorból

A CTRL-Y parancs (Insert módban) a kurzor fölötti karaktert gépeli.
Csodálatos, ha például az új sor nagy része megegyezik a fentebbivel. Például,
van egy sorod C-ben:

	b_array[i]->s_next = a_array[i]->s_next; ~

A következő sorod javarészt meg fog egyezni ("s_prev" helyett "s_next").
Indíts egy új sort és támaszkodj rá a CTRL-Y billentyűre (14-szer), amíg a
második "_" karakterhez érsz:

	b_array[i]->s_next = a_array[i]->s_next; ~
	b_array[i]->s_ ~

Beírod a különböző szót:

	b_array[i]->s_next = a_array[i]->s_next; ~
	b_array[i]->s_prev ~

CTRL-Y-vel kiegészíted a sor a "next"-ig:

	b_array[i]->s_next = a_array[i]->s_next; ~
	b_array[i]->s_prev = a_array[i]->s_ ~

Most pedig az utolsó "prev;".

A parancs inverze a CTRL-E, ami kurzor alatti lévő karaktert gépeli be.

==============================================================================
*24.6*	Regiszter tartalmának beszúrása

A CTRL-R {register} parancs a hivatkozott regiszter tartalmát illeszti be.
Kiválóan felhasználható hosszú szavak gépelésére. Például, ezt kell
kialakítanod a forráskódban:

	r = VeryLongFunction(a) + VeryLongFunction(b) + VeryLongFunction(c) ~

A függvény nevét egy másik fájl definiálja. Szerkeszd a definíciót, a függvény
nevét pedig másold be egy általad választott regiszterbe, mondjuk v: >

	"vyiw

"v a regiszterazonosító, "yiw" pedig kimásolja a szót (yank-inner-word). Most
menj arra a helyre, ahová be szeretnéd illeszteni. Kezdd el a sort:

	r = ~

A függvény nevét illeszd be a CTRL-R v-vel:

	r = VeryLongFunction ~

A függvények közötti " + " részt kézzel kell megoldanunk, de további két
alkalommal a CTRL-R v használható.
   Mezei kiegészítéssel is megoldhattuk volna a feladatot. A regiszterek akkor
remekelnek, ha sok azonos betűkkel kezdődő elemünk van.

A regiszterek speciális karakterei (<BS> stb.) a képernyőre íródnak, mintha
begépeltük volna őket. Ha ezt nem szeretnéd és a <BS> karaktereket szövegként
szeretnéd beilleszteni, akkor CTRL-R CTRL-R {register}.

==============================================================================
*24.7*	Rövidítések

A rövidítésekkel hosszú szavak rövidíthetünk, elgépeléseket korrigálhatunk.
Például, az "ad" szót gépeléskor automatikusan kiegészíti a szerkesztő
"advertisement"-re.
  Hogy ezt definiáljuk insert módban, adjuk ki a parancsot: >

	:iabbrev ad advertisement

Most, ha "ad"-ot gépelsz, a szó "advertisement"-re átváltozik, amikor az első
olyan karaktert gépeled be, amely a szavakban nem szerepelhet:

	Amit beírsz		Amit látsz
	I saw the a		I saw the a ~
	I saw the ad		I saw the ad ~
	I saw the ad<Space>	I saw the advertisement<Space> ~

A kibontás nem történik meg még akkor sem, ha az "ad" szót begépeljük. Így
gépelhetünk egy teljesen más szót is ("add"), a rövidítés nem lesz kibontva.
The expansion doesn't happen when typing just "ad". A rövidítések ellenőrzése
teljes szavak alapján történik.


TÖBB SZÓ RÖVIDÍTÉSE

It is possible to define an abbreviation that results in multiple words.  For
example, to define "JB" as "Jack Benny", use the following command: >

	:iabbrev JB Jack Benny

As a programmer, I use two rather unusual abbreviations: >

	:iabbrev #b /****************************************
	:iabbrev #e <Space>****************************************/

These are used for creating boxed comments.  The comment starts with #b, which
draws the top line.  I then type the comment text and use #e to draw the
bottom line.
   Notice that the #e abbreviation begins with a space.  In other words, the
first two characters are space-star.  Usually Vim ignores spaces between the
abbreviation and the expansion.  To avoid that problem, I spell space as seven
characters: <, S, p, a, c, e, >.

	Note:
	":iabbrev" is a long word to type.  ":iab" works just as well.
	That's abbreviating the abbreviate command!


FIXING TYPING MISTAKES

It's very common to make the same typing mistake every time.  For example,
typing "teh" instead of "the".  You can fix this with an abbreviation: >

	:abbreviate teh the

You can add a whole list of these.  Add one each time you discover a common
mistake.


LISTING ABBREVIATIONS

The ":abbreviate" command lists the abbreviations:

	:abbreviate
	i  #e		  ****************************************/
	i  #b		 /****************************************
	i  JB		 Jack Benny
	i  ad		 advertisement
	!  teh		 the

The "i" in the first column indicates Insert mode.  These abbreviations are
only active in Insert mode.  Other possible characters are:

	c	Command-line mode			:cabbrev
	!	both Insert and Command-line mode	:abbreviate

Since abbreviations are not often useful in Command-line mode, you will mostly
use the ":iabbrev" command.  That avoids, for example, that "ad" gets expanded
when typing a command like: >

	:edit ad


DELETING ABBREVIATIONS

To get rid of an abbreviation, use the ":unabbreviate" command.  Suppose you
have the following abbreviation: >

	:abbreviate @f fresh

You can remove it with this command: >

	:unabbreviate @f

While you type this, you will notice that @f is expanded to "fresh".  Don't
worry about this, Vim understands it anyway (except when you have an
abbreviation for "fresh", but that's very unlikely).
   To remove all the abbreviations: >

	:abclear

":unabbreviate" and ":abclear" also come in the variants for Insert mode
(":iunabbreviate and ":iabclear") and Command-line mode (":cunabbreviate" and
":cabclear").


REMAPPING ABBREVIATIONS

There is one thing to watch out for when defining an abbreviation: The
resulting string should not be mapped.  For example: >

	:abbreviate @a adder
	:imap dd disk-door

When you now type @a, you will get "adisk-doorer".  That's not what you want.
To avoid this, use the ":noreabbrev" command.  It does the same as
":abbreviate", but avoids that the resulting string is used for mappings: >

	:noreabbrev @a adder

Fortunately, it's unlikely that the result of an abbreviation is mapped.

==============================================================================
*24.8*	Entering special characters

The CTRL-V command is used to insert the next character literally.  In other
words, any special meaning the character has, it will be ignored.  For
example: >

	CTRL-V <Esc>

Inserts an escape character.  Thus you don't leave Insert mode.  (Don't type
the space after CTRL-V, it's only to make this easier to read).

	Note:
	On MS-Windows CTRL-V is used to paste text.  Use CTRL-Q instead of
	CTRL-V.  On Unix, on the other hand, CTRL-Q does not work on some
	terminals, because it has a special meaning.

You can also use the command CTRL-V {digits} to insert a character with the
decimal number {digits}.  For example, the character number 127 is the <Del>
character (but not necessarily the <Del> key!).  To insert <Del> type: >

	CTRL-V 127

You can enter characters up to 255 this way.  When you type fewer than two
digits, a non-digit will terminate the command.  To avoid the need of typing a
non-digit, prepend one or two zeros to make three digits.
   All the next commands insert a <Tab> and then a dot:

	CTRL-V 9.
	CTRL-V 09.
	CTRL-V 009.

To enter a character in hexadecimal, use an "x" after the CTRL-V: >

	CTRL-V x7f

This also goes up to character 255 (CTRL-V xff).  You can use "o" to type a
character as an octal number and two more methods allow you to type up to
a 16 bit and a 32 bit number (e.g., for a Unicode character): >

	CTRL-V o123
	CTRL-V u1234
	CTRL-V U12345678

==============================================================================
*24.9*	Digraphs

Some characters are not on the keyboard.  For example, the copyright character
(©).  To type these characters in Vim, you use digraphs, where two characters
represent one.  To enter a ©, for example, you press three keys: >

	CTRL-K Co

To find out what digraphs are available, use the following command: >

	:digraphs

Vim will display the digraph table.  Here are three lines of it:

  AC ~_ 159  NS |  160  !I ¡  161  Ct ¢  162  Pd £  163  Cu ¤  164  Ye ¥  165 ~
  BB ¦  166  SE §  167  ': ¨  168  Co ©  169  -a ª  170  << «  171  NO ¬  172 ~
  -- ­  173  Rg ®  174  'm ¯  175  DG °  176  +- ±  177  2S ²  178  3S ³  179 ~

This shows, for example, that the digraph you get by typing CTRL-K Pd is the
character (£).  This is character number 163 (decimal).
   Pd is short for Pound.  Most digraphs are selected to give you a hint about
the character they will produce.  If you look through the list you will
understand the logic.
   You can exchange the first and second character, if there is no digraph for
that combination.  Thus CTRL-K dP also works.  Since there is no digraph for
"dP" Vim will also search for a "Pd" digraph.

	Note:
	The digraphs depend on the character set that Vim assumes you are
	using.  Always use ":digraphs" to find out which digraphs are currently
	available.

You can define your own digraphs.  Example: >

	:digraph a" ä

This defines that CTRL-K a" inserts an ä character.  You can also specify the
character with a decimal number.  This defines the same digraph: >

	:digraph a" 228

More information about digraphs here: |digraphs|
   Another way to insert special characters is with a keymap.  More about that
here: |45.5|

==============================================================================
*24.10*	Normal mode commands

Insert mode offers a limited number of commands.  In Normal mode you have many
more.  When you want to use one, you usually leave Insert mode with <Esc>,
execute the Normal mode command, and re-enter Insert mode with "i" or "a".
   There is a quicker way.  With CTRL-O {command} you can execute any Normal
mode command from Insert mode.  For example, to delete from the cursor to the
end of the line: >

	CTRL-O D

You can execute only one Normal mode command this way.  But you can specify a
register or a count.  A more complicated example: >

	CTRL-O "g3dw

This deletes up to the third word into register g.

==============================================================================

Következő fejezet: |usr_25.txt|  Editing formatted text

Jogi információk: lásd |manual-copyright|  vim:tw=78:ts=8:noet:ft=help:norl:
