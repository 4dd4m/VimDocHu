*usr_27.txt*	For Vim version 8.2.  Last change: 2019 Jul 14

		  Bram Moolenaar: Vim felhasználói kézikönyv

			 Keresési parancsok és minták


A harmadik fejezetben már megtanulhattuk a keresés alapjait |03.9| Azonban a
Vim ennél sokkal többre képes. A fejezet bemutatja a leggyakrabban alkalmazott
technikákat. A mintákról külön fejezetben tájékozódhatsz: |pattern|.

|27.1|	Kis- és nagybetű ignorálása
|27.2|	Körkörös keresés
|27.3|	Offszetek
|27.4|	Illesztés több alkalommal
|27.5|	Alternatívák
|27.6|	Karaktertartományok
|27.7|	Karakterosztályok
|27.8|	Sortörés illesztése
|27.9|	Példák

Következő fejezet: |usr_28.txt|  Foldolás
    Előző fejezet: |usr_26.txt|  Ismétlés
  Tartalomjegyzék: |usr_toc.txt|

==============================================================================
*27.1*	Kis- és nagybetű ignorálása

Ha az alapértelmezett beállításokon nem változtatunk, akkor a keresés során a
Vim illeszti a nagy- és kisbetűket is. Ezért "include", "INCLUDE" és "Include"
különbözőek, azért a keresésünk csak az egyik szóra fog illeszkedni.
   Most kapcsold be az 'ignorecase' opciót: >

	:set ignorecase

Keress az "include" szóra. A művelet illeszkedett mindhárom szóra, és
illeszkedne például a "InClUdE" szóra is. (Kapcsold be a 'hlsearch' opciót,
mely kiemeli a találatokat).
   Így kapcsolható ki: >

	:set noignorecase

Most azonban még ne kapcsoljuk ki, keressünk rá az "INCLUDE" szóra. Az
eredmény ugyan az, a keresés mindhárom szóra illeszkedett. Kapcsoljuk be a
'smartcase' opciót: >

	:set ignorecase smartcase

Ha a mintának legalább egy karaktere nagybetűs, akkor a keresés betűérzékennyé
válik, hiszen csak abban az esetben használunk nagybetűt, ha azt szeretnénk,
hogy a keresés betűérzékeny legyen. Okos!
    A 'ignorecase' és s 'smartcase' által végzett keresések találatainak
szemléltetés:

	minta			egyezés	~
	word			word, Word, WORD, WoRd, etc.
	Word			Word
	WORD			WORD
	WoRd			WoRd


BETŰÉRZÉKENYSÉG MINTÁNKÉNT

Az előbb említett opciókat nem kell feltétlenül be- és kikapcsolni minden egyes
keresés alkalmával. Ha betűérzéketlenné szeretnéd tenni a keresést, akkor "\c"
stringet fűzd a mintád elejéhez. "\C" betűérzékennyé teszi a keresést. A
prefixum felülírja az 'ignorecase' és a 'smartcase' értékeit. "\c","\C"
használata esetén az  említett két opció értéke nincs figyelembe véve.

	minta			egyezés	~
	\Cword			word
	\CWord			Word
	\cword			word, Word, WORD, WoRd, etc.
	\cWord			word, Word, WORD, WoRd, etc.

A "\c \C" egyik nagy előnye, hogy beépül a mintába. Ezért ha a keresést a
historyból ismétled szintén nem kell hozzányúlni az opciókhoz.

	Megjegyzés:
	Az "\" elemek használata függ a 'magic' opciótól. Ebben a fejezetben
	feltételezzük, hogy 'magic' be van kapcsolva, mert ez az ajánlott és
	alapértelmezett beállítás. Ha megváltoztatnád a 'magic' értékét, akkor
	hirtelen az összes példa invaliddá válna.

	Megjegyzés:
	Hosszan tartó kereséseket megszakíthatunk Unixon CTRL-C, MS-Windowson
	CTRL-Break billentyűkkel.

==============================================================================
*27.2*	Körkörös keresés

Keresésnél (előre irányban), a keresés a kurzortól pontjától a fájl végéig
futtatja a keresést. Amennyiben nem volt találat, akkor a keresés a fájl
elejétől folytatódik és a kurzor pozíciójáig tart.
   A parancs ismétlésénél ("n") a találatok bejárása során visszajutsz a
legelső találathoz is, amit ha nem veszel észre akkor örökké keresni fogsz!
Hogy végképp ne vessz el, a Vim az alábbi üzeneteket írja ki a command-linera:

	search hit BOTTOM, continuing at TOP ~

Ha visszafelé irányban keresel ("?"), akkor az alábbi üzenetet láthatod:

	search hit TOP, continuing at BOTTOM ~

Sajnos még mindig nem láthatod, hog mikor van a kurzorod az első találaton.
Egyik módja, ha bekapcsolod a 'ruler' opciót: >

	:set ruler

A jobb alsó sarokban láthatod (az állapotsoron, ha engedélyezve van)  a 'ruler'-t,
mely megjeleníti kurzor sor- és oszlopszámát:

	101,29       84% ~

Jegyezd meg, hogy melyik soron található az első találat, és legközelebb már
tudni fogod, hogy áthaladtál-e rajta.


KÖRKÖRÖS KERESÉS KIKAPCSOLÁSA

A körkörös keresést kikapcsolhatod: >

	:set nowrapscan

Így, ha a keresésed eléri a fájl végét, akkor hibaüzenetet kapsz:

	E385: search hit BOTTOM without match for: forever ~

Ezért, hogy az összes találatot megtaláld, először a fájl elejére kell
ugranod a "gg" paranccsal és addig keresni, amíg hibaüzenetet nem kapsz.
   A fájl teteje által kiváltott hibaüzenet kereséskor ("?"):

	E384: search hit TOP without match for: forever ~

==============================================================================
*27.3*	Offszetek

Ha a keresés találatot eredményez, akkor a kurzor az egyező minta elejére
kerül. Ha ez nem megfelelő, akkor offszet segítségével a Vim képes
pozícionálni a kurzort. Előre keresésnél "/", a mintát egy "/" karakter, és az
offszet értéke követi: >

	/default/2

A parancs mintája a "default" szó, az offszet pedig 2, így a kurzor a találat
sorához képest két sorral lejjebb (a sor elején) fog elhelyezkedni.

Ha az offszet egy szám, akkor a kurzor a sor elejére kerül. Az offszet lehet
negatív és pozitív is. Ha a szám negatív, akkor a találattól feljebb, ha
pozitív, akkor a találattól lejjebb helyezi a kurzort.


KARAKTER OFSZETEK

Az "e" offszet jelzi a találat végét, a kurzort így a találat végére mozgatja:
>
	/const/e

ez a kurzort a "t" betűre helyezi a "const" szóban.
   Erről a pozíciótól egy szám argumentummal tudunk elmozdulni akár pozitív,
akár negatív irányba. Az argumentum értéke határozza meg az elmozdulást. >

	/const/e+1

Pozitív egész szám a kurzort jobbra mozgatja, negatív elmozdulás pedig balra.
Például: >

	/const/e-1

Ebben az esetben a kurzor a "const" szó "s" betűjére kerül.

A "b" offszet a szó elejére helyezi a kurzort, mely nem túl hasznos
önmagában, hiszen az alapértelmezett keresés is így működik, ezért az
általános használata mindig egy számmal történik, adott karakterszámmal
mozdítja el a kurzort. Például: >

	/const/b+2

A kurzor két karakterrel jobbra mozdul el a keresés után ("n").


ISMÉTLÉS

A keresés ismétlése különböző offszettel, csak hagyjuk ki a mintát: >

	/that
	//e

Egyenértékű ezzel: >

	/that/e

Ismétlés azonos offszettel: >

	/

Az "n" ugyanazt csinálja.  Megismétli a keresést ugyanazzal az offszettel: >

	//


KERESÉS VISSZA IRÁNYBAN

A "?" parancs az offszeteket ugyanígy használja, következetesen "?" kell
használnunk a keresés és az offszet elválasztásánál: >

	?const?e-2

Az "e" és "b" (begin - end) is ugyanúgy működnek, irányuk nem változik meg a "?"
használatánál.


KEZDŐPOZÍCIÓ

A keresés kezdőpontja a kurzor. Ha offszeteled a keresést, gondot okozhat.
Például: >

	/const/-2

A keresés megtalálja a "const" szót, mely után két sor lép felfelé. Ha "n"
paranccsal a következő találatra szeretnél ugrani, akkor második alkalommal is
ugyanarra a találatra érkezel, ezért sohasem fogsz előrébb jutni.
   Rosszabb esetben: Képzeld el, hogy van még egy "const" szó két sorral
feljebb. Ez lényegében visszább viszi a kurzort!

Offszetes keresésnél a Vim kompenzál pár karaktert vissza és előre irányban,
hogy ne legyen egy találat kétszer a körbejárás során.

==============================================================================
*27.4*	Illesztés több alkalommal

A "*" előtt álló elem akárhányszor előfordulhat (akár nulla alkalommal is). 
Ezért: >

	/a*

Ez illeszkedik: "a", "aa", "aaa", stb.  De szintén illeszkedik az  "" 
(üres string), mivel nulla alkalommal is előfordulhat.
   Az "*" csak az őt megelőző elemre vonatkozik. Ezért "ab*" illeszkedik:
"a", "ab", "abb", "abbb", stb.  Ha ezt hosszabb karakterláncra is ki
szeretnénk terjeszti, akkor csoportosítanunk kell őket zárójelek segítségével.
Ezt úgy tehetjük meg, hogy a karakterlánc elé "\(", mögé pedig "\)" írunk.
Azaz: >

	/\(ab\)*

Illeszkedik: "ab", "abab", "ababab", stb,  és persze "".

Az üres sztring illesztését úgy tudjuk elkerülni, ha a "\+" metakaraktert
használjuk, mely megengedi, hogy az előző elem egyszer, vagy többször
forduljon elő. >

	/ab\+

Illeszkedik "ab", "abb", "abbb", stb. Nem illeszkedik az összes olyan
sztringre, melyekben "a" nem "b"-t követi.


Opcionális elem, "\=".  Például: >

	/folders\=

Illeszkedik "folder" és "folders"-re.


SZÁMSZERŰSÍTÉS

Ha egy meghatározott mennyiséget szeretnél engedélyezni, akkor használd a
"\{n,m}" formátumot. Az "n" és "m" pozitív egész szám. Ennek hatására a
megelőző elem minimum "n" és maximum "m" alkalommal szerepelhet. |inclusive|.
Például: >

	/ab\{3,5}

Illeszkedik "abbb", "abbbb" and "abbbbb".
  Ha "n" nincs meghatározva, akkor értéke 0. Ha "m" nincs meghatározva, akkor
értéke a végtelen. Ha ",m" hiányzik a mintából, akkor pontosan "n" alkalommal.
Például:

	minta		egyezések száma ~
	\{,4}		0, 1, 2, 3 or 4
	\{3,}		3, 4, 5, stb.
	\{0,1}		0 vagy 1, azaz \=
	\{0,}		0 vagy többször, azaz *
	\{1,}		1 vagy többször, azaz \+
	\{3}		3


A LEHETŐ LEGKISEBB ILLESZTÉS

Az eddigi minták az összes karakterre illeszkedtek. Lehető legkisebb illesztés
formátuma: "\{-n,m}". Működése megegyezik a "\{n,m}" mintáéval, kivéve, hogy a
lehető legkevesebb karaktert próbálja illeszteni. Például, a következő minta:
>
	/ab\{-1,3}

Illeszkedni fog "ab"-re az "abbb"-ben. Tulajdonképpen, soha nem fog egy b-nél
többre illeszteni, hiszen nincs szükség rá. Más módszerrel kényszeríthetjük,
hogy többet illesszen az alsó határtól.
   Ugyanezek a szabályok vonatkoznak ha "n" és "m"-et eltávolítjuk, "\{-}". Ez
illeszkedik 0  vagy több alkalommal, a lehető legkevesebbszer. Általában
kombinációban használjuk más elemekkel: >

	/a.\{-}b

Illeszkedik "axb"-re az "axbxb"-ben.  Ha így használtuk volna: >

	/a.*b

".*" a lehető legtöbb karakterre illesztett volna, "axbxb"-re is.

==============================================================================
*27.5*	Alternatívák

Az "vagy" operátor szintaktikája az "\|". Például: >

	/foo\|bar

Ez illeszkedik "foo" és "bar" szavakra. A többi alternatívát hozzáfűzzük: >

	/one\|two\|three

Illeszkedik "one", "two" és "three" szavakra.
   Ha megengedjük, hogy többször is előforduljanak, akkor  "\(" közé "\)"
zárjuk őket: >

	/\(foo\|bar\)\+

Ez illeszkedik "foo", "foobar", "foofoo", "barfoobar", stb. szavakra.
   Egy másik példa: >

	/end\(if\|while\|for\)

Ez illeszkedik "endif", "endwhile" és "endfor" szavakra.
???
A related item is "\&".  This requires that both alternatives match in the
same place.  The resulting match uses the last alternative.  Example: >
???  >
	/forever\&...

Ez illeszkedik a "forever" szóban lévő "for"-ra.  A "fortuin" szóra nem fog
illeszkedni.

==============================================================================
*27.6*	Karaktertartományok

"a", "b" vagy "c" illesztéséhez használhatjuk ezt a mintát: "/a\|b\|c". Ha az
összes karakterre szeretnél illeszteni "a"-tól "z"-ig, ezzel a módszerrel
sokáig tartana leírni a mintát. Ezért rövidítést használunk: >

	/[a-z]

A [] szimpla karakterekre illeszt, melyeket a [] belsejében kell
definiálnunk. A karaktereket listaszerűen beírhatjuk így: >

	/[0123456789abcdef]

Ez csak azokra a karakterekre illeszt, amelyek a lista részét képzik. Egymást
követő karakterek esetén meghatározhatjuk a tartományt. "0-3" jelentése
"0123". "w-z" jelentése "wxyz". Ezért a fenti minta így rövidíthető: >

	/[0-9a-f]

Ha konkrétan a "-" karaktert szeretnéd illeszteni, akkor szúrd be külön a
lista elejére (vagy végére). 
    Az alábbi speciális karakterek használhatjuk a [] tartományban (és az
egész mintában:

	\e	<Esc>
	\t	<Tab>
	\r	<CR>
	\b	<BS>

A [] tartománynak vannak speciális esetei, melyekről |/[]| itt olvashatsz.


COMPLEMENTED RANGE

To avoid matching a specific character, use "^" at the start of the range.
The [] item then matches everything but the characters included.  Example: >

	/"[^"]*"
<
	 "	  a double quote
	  [^"]	  any character that is not a double quote
	      *	  as many as possible
	       "  a double quote again

This matches "foo" and "3!x", including the double quotes.


PREDEFINED RANGES

A number of ranges are used very often.  Vim provides a shortcut for these.
For example: >

	/\a

Finds alphabetic characters.  This is equal to using "/[a-zA-Z]".  Here are a
few more of these:

	elem	illeszkedik			egyenlő ~
	\d	szám			[0-9]
	\D	nem-szám		[^0-9]
	\x	hex szám		[0-9a-fA-F]
	\X	nem-hex szám		[^0-9a-fA-F]
	\s	üres karakter		[ 	]     (<Tab> és <Space>)
	\S	nem-üres karakter	[^ 	]     (nem <Tab> és <Space>)
	\l	kisbetűs alpha		[a-z]
	\L	nem-kisbetűs alpha	[^a-z]
	\u	nagybetűs alpha		[A-Z]
	\U	nem-nagybetűs alpha	[^A-Z]

	Note:
	Using these predefined ranges works a lot faster than the character
	range it stands for.
	These items can not be used inside [].  Thus "[\d\l]" does NOT work to
	match a digit or lowercase alpha.  Use "\(\d\|\l\)" instead.

See |/\s| for the whole list of these ranges.

==============================================================================
*27.7*	Character classes

The character range matches a fixed set of characters.  A character class is
similar, but with an essential difference: The set of characters can be
redefined without changing the search pattern.
   For example, search for this pattern: >

	/\f\+

The "\f" item stands for file name characters.  Thus this matches a sequence
of characters that can be a file name.
   Which characters can be part of a file name depends on the system you are
using.  On MS-Windows, the backslash is included, on Unix it is not.  This is
specified with the 'isfname' option.  The default value for Unix is: >

	:set isfname
	isfname=@,48-57,/,.,-,_,+,,,#,$,%,~,=

For other systems the default value is different.  Thus you can make a search
pattern with "\f" to match a file name, and it will automatically adjust to
the system you are using it on.

	Note:
	Actually, Unix allows using just about any character in a file name,
	including white space.  Including these characters in 'isfname' would
	be theoretically correct.  But it would make it impossible to find the
	end of a file name in text.  Thus the default value of 'isfname' is a
	compromise.

A karakterosztályok:

	item	matches				option ~
	\i	azonosító karakterek		'isident'
	\I	mint \i, kivéve számok
	\k	kulcsszó karakterek		'iskeyword'
	\K	mint \k, kivéve számok
	\p	nyomtatható karakter		'isprint'
	\P	mint \p, kivéve számok
	\f	fájlnév karakter		'isfname'
	\F	mint \f, kivéve számok

==============================================================================
*27.8*	Matching a line break

Vim can find a pattern that includes a line break.  You need to specify where
the line break happens, because all items mentioned so far don't match a line
break.
   To check for a line break in a specific place, use the "\n" item: >

	/one\ntwo

This will match at a line that ends in "one" and the next line starts with
"two".  To match "one two" as well, you need to match a space or a line
break.  The item to use for it is "\_s": >

	/one\_stwo

To allow any amount of white space: >

	/one\_s\+two

This also matches when "one  " is at the end of a line and "   two" at the
start of the next one.

"\s" matches white space, "\_s" matches white space or a line break.
Similarly, "\a" matches an alphabetic character, and "\_a" matches an
alphabetic character or a line break.  The other character classes and ranges
can be modified in the same way by inserting a "_".

Many other items can be made to match a line break by prepending "\_".  For
example: "\_." matches any character or a line break.

	Note:
	"\_.*" matches everything until the end of the file.  Be careful with
	this, it can make a search command very slow.

Another example is "\_[]", a character range that includes a line break: >

	/"\_[^"]*"

This finds a text in double quotes that may be split up in several lines.

==============================================================================
*27.9*	Examples

Here are a few search patterns you might find useful.  This shows how the
items mentioned above can be combined.


FINDING A CALIFORNIA LICENSE PLATE

A sample license plate number is "1MGU103".  It has one digit, three uppercase
letters and three digits.  Directly putting this into a search pattern: >

	/\d\u\u\u\d\d\d

Another way is to specify that there are three digits and letters with a
count: >

	/\d\u\{3}\d\{3}

Using [] ranges instead: >

	/[0-9][A-Z]\{3}[0-9]\{3}

Which one of these you should use?  Whichever one you can remember.  The
simple way you can remember is much faster than the fancy way that you can't.
If you can remember them all, then avoid the last one, because it's both more
typing and slower to execute.


FINDING AN IDENTIFIER

In C programs (and many other computer languages) an identifier starts with a
letter and further consists of letters and digits.  Underscores can be used
too.  This can be found with: >

	/\<\h\w*\>

"\<" and "\>" are used to find only whole words.  "\h" stands for "[A-Za-z_]"
and "\w" for "[0-9A-Za-z_]".

	Note:
	"\<" and "\>" depend on the 'iskeyword' option.  If it includes "-",
	for example, then "ident-" is not matched.  In this situation use: >

		/\w\@<!\h\w*\w\@!
<
	This checks if "\w" does not match before or after the identifier.
	See |/\@<!| and |/\@!|.

==============================================================================

Következő fejezet: |usr_28.txt|  Foldolás

Jogi információk: lásd |manual-copyright|  vim:tw=78:ts=8:noet:ft=help:norl:
