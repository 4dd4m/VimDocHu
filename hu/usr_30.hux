*usr_30.txt*	For Vim version 8.2.  Last change: 2007 Nov 10

		  Bram Moolenaar: Vim felhasználói kézikönyv

			    Programok szerkesztése


Rengeteg parancs nyújt támaszt a programok szerkesztése során. A program
fordítása,  majd egyből a legelső hibára ugrás. Automatikus behúzás, formázott
kommentek.

|30.1|	Fordítás
|30.2|	C fájlok behúzása
|30.3|	Automatikus behúzás
|30.4|	Egyéb behúzások
|30.5|	Tabulátorok és szóközök
|30.6|	Kommentek formázása

Következő fejezet: |usr_31.txt|  A GUI használata
    Előző fejezet: |usr_29.txt|  Navigáció kódbázisban
  Tartalomjegyzék: |usr_toc.txt|

==============================================================================
*30.1*	Fordítás

Meg kell ismerjük a Vim következő nagy parancs csomagját, a "quickfix"
parancsokat. Használatukkal úgy fordíthatunk, hogy nem kell elhagynunk a
szerkesztőt, végigjárhatjuk a hibák listáját, kísérletet tehetünk a javításra. 
Majd új ciklust kezdünk, fordítunk és javítjuk a hibákat addig, amíg az összes
hibától megszabadulunk.

A következő parancs a "make" programot futtatja (azokkal az argumentumokkal,
melyeket megadsz) és rögzíti a hibákat: >

    :make {arguments}

A hibákat egy listában összegyűjti a Vim és az első találathoz navigál.
Köved végig az alábbi ":make" munkafolyamatot. A ":make" beírása utáni
kimenet:

	:!make | &tee /tmp/vim215953.err ~
	gcc -g -Wall -o prog main.c sub.c ~
	main.c: In function 'main': ~
	main.c:6: too many arguments to function 'do_sub' ~
	main.c: At top level: ~
	main.c:10: parse error before '}' ~
	make: *** [prog] Error 1 ~

	2 returned ~
	"main.c" 11L, 111C ~
	(3 of 6): too many arguments to function 'do_sub' ~
	Press ENTER or type command to continue ~

Ebből azt láthatjuk, hogy hiba forrás a "main.c" fájl. Ha <Enter> billentyűt
nyomsz, akkor a szerkesztő a "main.c" fájlt fogja megnyitni, a kurzort a 6.
sorra pozícionálva. Nem kell meghatároznod sem a fájl helyét, sem a kurzor
helyét. A Vim tudja, hogy hová kell mennie hiba esetén.

		+---------------------------------------------------+
		|int main()					    |
		|{						    |
		|	int i=3;				    |
      kurzor -> |	do_sub("foo");				    |
		|	++i;					    |
		|	return (0);				    |
		|}						    |
		|}						    |
		| ~						    |
		|(3 of 12): too many arguments to function 'do_sub' |
		+---------------------------------------------------+

Ugrás a következő hibára: >

	:cnext

A kurzor a 10. sorba kerül (fájl utolsó sora), ahol az extra '}' található.
   Ha a hibaüzenet nem fér ki, akkor a Vim lerövidíti az üzenetet. A teljes
hibaüzenet elérése: >

	:cc

Az összes hibaüzenetről a ":clist" paranccsal kaphatsz egy egysoros
áttekintést, mely így néz ki: >

	:clist  
>	3 main.c: 6:too many arguments to function 'do_sub' ~
	5 main.c: 10:parse error before '}' ~

A listában csak a fájlnévvel és a sor számával beazonosítható hibák
szerepelnek. Feltételezi, hogy ezek a sorok érdekelhetnek bennünket leginkább.
Előfordulhat, hogy a nem felismerhető sorok tartalmaznak valami olyasmit, amit
szívesen megvizsgálnál. A linker kimenete, például egy nem létező függvény. Az
összes hibaüzenet megjelenítéséhez adj a parancshoz egy "!" jelet:
>
	:clist!
<	1 gcc -g -Wall -o prog main.c sub.c ~
	2 main.c: In function 'main': ~
	3 main.c:6: too many arguments to function 'do_sub' ~
	4 main.c: At top level: ~
	5 main.c:10: parse error before '}' ~
	6 make: *** [prog] Error 1 ~

A Vim kiemeli az aktív hibát. Visszatérés az előző hibára: >
>
	:cprevious

Navigáció a hibalistában:

	:cfirst		első hibához
	:clast		utolsó hibához
	:cc 3		a 3. hibához


MÁSIK FORDÍTÓ HASZNÁLATA


A 'makeprg' határozza meg, hogy a ":make" parancs milyen parancsot hív meg.
Általában az érték "make", de a Visual C++ felhasználóknak ezt az értéket át
kell állítaniuk "nmake"-re az alábbi paranccsal: >

	:set makeprg=nmake

Argumentumokat is hozzáfűzhetsz, viszont a speciális karaktereket escapelni
kell \ karakterrel. Például: >

	:set makeprg=nmake\ -f\ project.mak

A speciális Vim kulcsszavak is használhatóak. A % karakter a jelenlegi
fájlnevet jelenti. Szóval ha ezt a parancsot futtatod: >

	:set makeprg=make\ %:S

Ha a main.c fájlt szerkeszted, majd kiadod a ":make" parancsot, akkor a
parancs ez lesz: >

	make main.c

Nincs túl sok értelme, ezért még finomítani kell, most használjuk a :r (root)
módosítót: >

	:set makeprg=make\ %:r:S.o

A parancs így fog lefutni: >

	make main.o

A módosítókról még több: |filename-modifiers|.


A RÉGI ERROR LIST

Tegyük fel, hogy fordítanál egy programot a ":make" paranccsal. Egy fájlhoz
figyelmeztető üzenet jelent meg, a másik fájlhoz pedig egy hibaüzenet.
Korrigálod a hibát, majd lefuttatod még egyszer a ":make" programot, tesztelve
a hibát. Meg szeretnéd tekinteni a figyelmeztető üzenet is. Ez viszont nem
jelent meg újra, hiszen a fájlt nem sikerült lefordítani. Az előző
hibalistához visszatérhetsz: >

	:colder

Aztán a ":clist" és a ":cc {nr}" paranccsal a figyelmeztető üzenet helyére
ugorhatsz.
   A frissebb hibalistához váltás: >

	:cnewer

A Vim tíz hibalistát tart számon.


FORDÍTÓK CSERÉJE

Az 'errorformat' opcióban be kell állítanunk, hogy a fordítónk milyen milyen
formátumban listázza a hibaüzeneteket. A változó szintaxisa elég komplex,
viszont bármelyik fordítóra meg lehet írni a megfelelő formátumot. Erről több
magyarázatot itt találsz: |errorformat|.

Lehet, hogy több fordítót is használsz. Így a 'makeprg' opció manuális
állítgatása nem egyszerű feladat. Ezért a Vim egy paranccsal zárja rövidre a
témát. Például, váltás Microsoft Visual C++ fordítóra: >

	:compiler msvc

Ami betölti az "msvc" fordítóhoz szükséges beállításokat.
   Hozd létre a saját fájlod, így |write-compiler-plugin|.


KIMENET ÁTIRÁNYÍTÁS

A ":make" parancs egy error fájlba átirányítja a futtatott program kimenetét.
A működése számos tényezőtől függ, például a 'shell'. Ha a ":make" parancsod
nem kapja el a kimenetet, ellenőrizd a 'makeef' és a 'shellpipe' opciót. A
'shellquote' és a 'shellxquote' is számíthatnak.

Alternatív megoldásként a programot lefordítható egy külön ablakban, melynek
kimenetét fájlba tudjuk irányítani, azonban ennek feldolgozásához a Vimnek
először be kell olvasnia: >

	:cfile {filename}

A hibák közötti ugrás teljesen megegyezik a ":make" parancs navigációjával.

==============================================================================
*30.2*	C stílusú szöveg behúzása

A program olvashatóbb, ha struktúrált behúzásokkal látjuk el. A Vim számos
módon igyekszik tehermentesíteni bennünket. A C és C stílusú programnyelvek,
mint a Java vagy C++, állítsd be a 'cindent' opciót. A szerkesztő ismeri a C
nyelvet is mindent megtesz, hogy a programunkra megfelelő behúzásokat
alkalmazzon. Állítsd be a 'shiftwidth' opciót, mellyel meghatározhatod a kód
mélységét. Négy szóköz elég. Egy ":set" parancsot adjunk ki: >

	:set cindent shiftwidth=4

Így ha valami olyasmit gépelünk, hogy "if (x)", akkor a következő sor behúzása
automatikusan egy szinttel megnövekszik.

					        if (flag){
	automatikus behúzás	        --->	    do_the_work();
	automatikus behúzás csökkentése <--	if (other_flag) {
	automatikus behúzás             --->	    do_file();
	behúzás tartása				    do_some_more();
	automatikus behúzás csökkentése <--	}

A kapcsos zárójelek {} gépelésénél, a szövegtörzs eleje be lesz húzva, a
behúzás pedig csökkenni fog, ha '}' karaktert gépelünk, hiszen a Vim tudja,
hogy körülbelül mit szeretnél írni.

Mellékhatásként segít a kódban szereplő korai hibák kiszűrésére. Ha } jelet
gépelsz, és a következő behúzás váratlanul nagy, akkor valószínűleg valamit
elfelejtettél lezárni (}). A "%" parancs segítségével derítsd ki a hiba okát.
   A hiányzó ) és ; szintén extra behúzást eredményez. Ilyenkor érdemes
visszamenőleg megvizsgálni az utolsó sorokat.

A Vimben szerencsére nem kell sokat törődni a behúzásokkal, melyek elcsúsznak
ha sorokat mozgatunk, törlünk. A "=" operátor automatikusan behúzza a
sorainkat. Legegyszerűbb formája: >

	==

Ez csak az aktív sorra vonatkozik. Mint minden operátor, három módon
használatos. Visual módban, "=" behúzza a kijelölés sorait. Hasznos
szöveg-objektum a "a{" mely az aktív {} blokkon végez műveletet, azaz a blokk
újra indentálása: >

	=a{

Ha feltűnően rosszul néz ki a kódod, akkor az egész fájlon futtasd: >
>
	gg=G

Abban az esetben, ha a fájlodat gondosan kézzel húztad be, a parancs nem
ajánlott. Az automatikus behúzás az esetek többségében jó, de akadhatnak
kivételek, amikor manuálisan közbe kell avatkoznunk.


IDENTÁLÁSI STÍLUS BEÁLLÍTÁSA

Ahány ház, annyi szokás. Az alapértelmezett stílus megfelel a programozók 
90%-ának.  Léteznek különböző stílusok, melyek mentén, ha szeretnéd,
igazíthatod a kódod.
   A 'cinoptions'-nak nincs értéke. Beállításával megadhatod, hogy milyen
stílusú legyen kódod. Például, ha a {} jeleket így szeretnéd használni:

	if (flag) ~
	  { ~
	    i = 8; ~
	    j = 0; ~
	  } ~

Beállítása: >

	:set cinoptions+={2

Amennyiben érdekel az összes opció: |cinoptions-values|.

==============================================================================
*30.3*	Automatikus behúzás

Valószínűleg nem szeretnéd a 'cindent' opciót minden egyes alkalommal
manuálisan beállítani C fájlok szerkesztésekor. Így teheted automatikussá: >

	:filetype indent on

A valóság az, hogy ezzel a beállítással sokkal több dolgot állítottunk be, nem
csak a 'cindent'-et. Először is, engedélyeztük a fájltípus megállapítást, amit
már a szintaxis kiemelés kapcsán előzőleg beállítottunk. 
   Ha a fájltípus ismert, akkor a Vim megkeresi az adott fájlhoz tartozó
behúzás-fájlt, melynek alapján a szerkesztő szervezi a behúzásokat.

Ha nem tetszik az automatikus behúzás, akkor ki is kapcsolhatod: >

	:filetype indent off

Ha csak egy fájltípus behúzását nem kedveled, akkor így kerülheted el. Hozz
létre egy fájl a következő tartalommal: >

	:let b:did_indent = 1

Most pedig mentsd el a fájlt, az alábbiak szerint: 

	{directory}/indent/{filetype}.vim

A {filetype} fájl kiterjesztése, mint "cpp" vagy "java".  A {filetype}
megjelenik (így ellenőrizhető, hogy tényleg jó-e a fájltípus: >

	:set filetype

Ha itt írod be, akkor a kézikönyv fájltípusát fogod megkapni:

	filetype=help ~

A {directory} részhez egy runtime könyvtárat kell megadni. Nézd meg a
'runtimepath' változód tartalmát: >

	set runtimepath

A fájlt másold a vessző előtti (első) elérési útra. 'runtimepath' tartalma:

	runtimepath=~/.vim,/usr/local/share/vim/vim60/runtime,~/.vim/after ~

Például "~/.vim" használod a {directory}-hoz.  Akkor a teljes elérési utad:

	~/.vim/indent/help.vim ~

Ahelyett, hogy a behúzásokat kapcsolgatod, írj saját behúzás-fájlt. Itt minden
el van magyarázva: |indent-expression|.

==============================================================================
*30.4*	Egyéb behúzás

A legegyszerűbb módszer az 'autoindent' opció használata. Csak másolja a
behúzást az előző sorból. Egy picivel okosabb a 'smartindent'. Ez akkor jön
jól, ha a fájltípushoz nincs behúzás-fájlunk. A 'smartindent' nem annyira
okos, mint a 'cident', de okosabb 'autoindent'-nél.
   A 'smartindent' beállítással, egy extra behúzás van adva minden { karakter
után, és eggyel csökkentve } karakter után. További extra behúzás van adva a
'cinwords' beállításban meghatározott szavak után. A # karterrel kezdődő
sorok speciálisak: minden behúzás el van távolítva. Erre azért van szükség,
hogy a preprocesszor direktívái az első oszlopban kezdődhessenek. A következő
sorban a behúzás folytatódik.


BEHÚZÁSOK KORREKCIÓJA

Ha az 'autoindent' vagy a 'smartindent'-et használod, az előző sor
indentálásának folytatásához sokszor hozzá kell adni, vagy el kell távolítani
egy 'shiftwidth' értéknyi behúzást. Insert módban a probléma orvosolható
CTRL-D (behúzás csökkentése) és CTRL-T (behúzás növelése parancsokkal).
   Például, egy shell szkriptet írsz, melynek így kell kinéznie:

	if test -n a; then ~
	   echo a ~
	   echo "-------" ~
	fi ~

Kezdésnek állítsunk az alábbi opciókon: >

	:set autoindent shiftwidth=3

Begépeled az első sort, <Enter>, és a második sor:

	if test -n a; then ~
	echo ~

Most kell egy extra behúzás (CTRL-T), amely után: 

	if test -n a; then ~
	   echo ~

A CTRL-T parancs Insert módban egy 'shiftwidth' értéknyi behúzást add hozzá a
sor elejéhez (bárhol is legyen a kurzor a sorban).
   Folytatod a második sorral, <Enter> és a harmadik sor. Most minden behúzás
a helyén van. Majd <Enter> és az utolsó sor. Most itt tartunk:

	if test -n a; then ~
	   echo a ~
	   echo "-------" ~
	   fi ~

Az extra behúzás eltávolításához CTRL-D (Insert módban), ami töröl egy
'shiftwidth' értéket a sor elejéről. 
   Normál módban, a ">>" és "<<" operátorok, szóval háromféleképpen
használhatjuk. A leghasznosabb: >

	>i{

A parancs egy behúzást ad a {} jelek között szereplő blokknak. A { és }
tartalmazó (határoló) sorokat nem kapnak behúzást (">a{" paranccsal igen). Az
alábbi példában a kurzor a "printf" függvényen van:

	eredeti szöveg		">i{" után		">a{" után

	if (flag)		if (flag)		if (flag) ~
	{			{			    { ~
	printf("yes");		    printf("yes");	    printf("yes"); ~
	flag = 0;		    flag = 0;		    flag = 0;  ~
	}			}			    } ~

==============================================================================
*30.5*	Tabs and spaces

'tabstop' is set to eight by default.  Although you can change it, you quickly
run into trouble later.  Other programs won't know what tabstop value you
used.  They probably use the default value of eight, and your text suddenly
looks very different.  Also, most printers use a fixed tabstop value of eight.
Thus it's best to keep 'tabstop' alone.  (If you edit a file which was written
with a different tabstop setting, see |25.3| for how to fix that.)
   For indenting lines in a program, using a multiple of eight spaces makes
you quickly run into the right border of the window.  Using a single space
doesn't provide enough visual difference.  Many people prefer to use four
spaces, a good compromise.
   Since a <Tab> is eight spaces and you want to use an indent of four spaces,
you can't use a <Tab> character to make your indent.  There are two ways to
handle this:

1.  Use a mix of <Tab> and space characters.  Since a <Tab> takes the place of
    eight spaces, you have fewer characters in your file.  Inserting a <Tab>
    is quicker than eight spaces.  Backspacing works faster as well.

2.  Use spaces only.  This avoids the trouble with programs that use a
    different tabstop value.

Fortunately, Vim supports both methods quite well.


SPACES AND TABS

If you are using a combination of tabs and spaces, you just edit normally.
The Vim defaults do a fine job of handling things.
   You can make life a little easier by setting the 'softtabstop' option.
This option tells Vim to make the <Tab> key look and feel as if tabs were set
at the value of 'softtabstop', but actually use a combination of tabs and
spaces.
   After you execute the following command, every time you press the <Tab> key
the cursor moves to the next 4-column boundary: >

	:set softtabstop=4

When you start in the first column and press <Tab>, you get 4 spaces inserted
in your text.  The second time, Vim takes out the 4 spaces and puts in a <Tab>
(thus taking you to column 8).  Thus Vim uses as many <Tab>s as possible, and
then fills up with spaces.
   When backspacing it works the other way around.  A <BS> will always delete
the amount specified with 'softtabstop'.  Then <Tab>s are used as many as
possible and spaces to fill the gap.
   The following shows what happens pressing <Tab> a few times, and then using
<BS>.  A "." stands for a space and "------->" for a <Tab>.

	type			  result ~
	<Tab>			  ....
	<Tab><Tab>		  ------->
	<Tab><Tab><Tab>		  ------->....
	<Tab><Tab><Tab><BS>	  ------->
	<Tab><Tab><Tab><BS><BS>   ....

An alternative is to use the 'smarttab' option.  When it's set, Vim uses
'shiftwidth' for a <Tab> typed in the indent of a line, and a real <Tab> when
typed after the first non-blank character.  However, <BS> doesn't work like
with 'softtabstop'.


JUST SPACES

If you want absolutely no tabs in your file, you can set the 'expandtab'
option: >

	:set expandtab

When this option is set, the <Tab> key inserts a series of spaces.  Thus you
get the same amount of white space as if a <Tab> character was inserted, but
there isn't a real <Tab> character in your file.
   The backspace key will delete each space by itself.  Thus after typing one
<Tab> you have to press the <BS> key up to eight times to undo it.  If you are
in the indent, pressing CTRL-D will be a lot quicker.


CHANGING TABS IN SPACES (AND BACK)

Setting 'expandtab' does not affect any existing tabs.  In other words, any
tabs in the document remain tabs.  If you want to convert tabs to spaces, use
the ":retab" command.  Use these commands: >

	:set expandtab
	:%retab

Now Vim will have changed all indents to use spaces instead of tabs.  However,
all tabs that come after a non-blank character are kept.  If you want these to
be converted as well, add a !: >

	:%retab!

This is a little bit dangerous, because it can also change tabs inside a
string.  To check if these exist, you could use this: >

	/"[^"\t]*\t[^"]*"

It's recommended not to use hard tabs inside a string.  Replace them with
"\t" to avoid trouble.

The other way around works just as well: >

	:set noexpandtab
	:%retab!

==============================================================================
*30.6*	Formatting comments

One of the great things about Vim is that it understands comments.  You can
ask Vim to format a comment and it will do the right thing.
   Suppose, for example, that you have the following comment:

	/* ~
	 * This is a test ~
	 * of the text formatting. ~
	 */ ~

You then ask Vim to format it by positioning the cursor at the start of the
comment and type: >

	gq]/

"gq" is the operator to format text.  "]/" is the motion that takes you to the
end of a comment.  The result is:

	/* ~
	 * This is a test of the text formatting. ~
	 */ ~

Notice that Vim properly handled the beginning of each line.
  An alternative is to select the text that is to be formatted in Visual mode
and type "gq".

To add a new line to the comment, position the cursor on the middle line and
press "o".  The result looks like this:

	/* ~
	 * This is a test of the text formatting. ~
	 * ~
	 */ ~

Vim has automatically inserted a star and a space for you.  Now you can type
the comment text.  When it gets longer than 'textwidth', Vim will break the
line.  Again, the star is inserted automatically:

	/* ~
	 * This is a test of the text formatting. ~
	 * Typing a lot of text here will make Vim ~
	 * break ~
	 */ ~

For this to work some flags must be present in 'formatoptions':

	r	insert the star when typing <Enter> in Insert mode
	o	insert the star when using "o" or "O" in Normal mode
	c	break comment text according to 'textwidth'

See |fo-table| for more flags.


DEFINING A COMMENT

The 'comments' option defines what a comment looks like.  Vim distinguishes
between a single-line comment and a comment that has a different start, end
and middle part.
   Many single-line comments start with a specific character.  In C++ // is
used, in Makefiles #, in Vim scripts ".  For example, to make Vim understand
C++ comments: >

	:set comments=://

The colon separates the flags of an item from the text by which the comment is
recognized.  The general form of an item in 'comments' is:

	{flags}:{text}

The {flags} part can be empty, as in this case.
   Several of these items can be concatenated, separated by commas.  This
allows recognizing different types of comments at the same time.  For example,
let's edit an e-mail message.  When replying, the text that others wrote is
preceded with ">" and "!" characters.  This command would work: >

	:set comments=n:>,n:!

There are two items, one for comments starting with ">" and one for comments
that start with "!".  Both use the flag "n".  This means that these comments
nest.  Thus a line starting with ">" may have another comment after the ">".
This allows formatting a message like this:

	> ! Did you see that site? ~
	> ! It looks really great. ~
	> I don't like it.  The ~
	> colors are terrible. ~
	What is the URL of that ~
	site? ~

Try setting 'textwidth' to a different value, e.g., 80, and format the text by
Visually selecting it and typing "gq".  The result is:

	> ! Did you see that site?  It looks really great. ~
	> I don't like it.  The colors are terrible. ~
	What is the URL of that site? ~

You will notice that Vim did not move text from one type of comment to
another.  The "I" in the second line would have fit at the end of the first
line, but since that line starts with "> !" and the second line with ">", Vim
knows that this is a different kind of comment.


A THREE PART COMMENT

A C comment starts with "/*", has "*" in the middle and "*/" at the end.  The
entry in 'comments' for this looks like this: >

	:set comments=s1:/*,mb:*,ex:*/

The start is defined with "s1:/*".  The "s" indicates the start of a
three-piece comment.  The colon separates the flags from the text by which the
comment is recognized: "/*".  There is one flag: "1".  This tells Vim that the
middle part has an offset of one space.
   The middle part "mb:*" starts with "m", which indicates it is a middle
part.  The "b" flag means that a blank must follow the text.  Otherwise Vim
would consider text like "*pointer" also to be the middle of a comment.
   The end part "ex:*/" has the "e" for identification.  The "x" flag has a
special meaning.  It means that after Vim automatically inserted a star,
typing / will remove the extra space.

For more details see |format-comments|.

==============================================================================

Következő fejezet: |usr_31.txt|  Exploiting the GUI

Jogi információk: lásd |manual-copyright|  vim:tw=78:ts=8:noet:ft=help:norl:
