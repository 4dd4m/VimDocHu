*usr_28.txt*	For Vim version 8.2.  Last change: 2008 Jun 14

		  Bram Moolenaar: Vim felhasználói kézikönyv

				   Foldolás


A struktúrált szöveget logikailag elkülöníthetjük. Részekre bonthatjuk, aztán
azokat később még tovább. Foldolással kódrészleteket tömöríthetsz egy sorba.
A fejezetben a foldolás különböző módszereit tárgyaljuk.

|28.1|	Mi a foldolás?
|28.2|	Kézi foldolás
|28.3|	Munka a foldokkal
|28.4|	Foldok mentése, visszaállítása
|28.5|	Foldolás behúzás által
|28.6|	Foldolás markerek által
|28.7|	Foldolás szintaxis által
|28.8|	Foldolás kifejezéssel
|28.9|	Változatlan sorok foldolása
|28.10|	Melyik foldolási módszert válasszam?

Következő fejezet: |usr_29.txt|  Mozgás a kódban
    Előző fejezet: |usr_27.txt|  Keresési parancsok és minták
  Tartalomjegyzék: |usr_toc.txt|

==============================================================================
*28.1*	Mi a foldolás?

Foldolással a bufferben lévő tartományokat egy sorként jelenítjük meg a
képernyőn. Mint egy darab papír, melyet ha összehajtunk, rövidebbé válik:

	+------------------------+
	| sor 1 		 |
	| sor 2 		 |
	| sor 3 		 |
	|_______________________ |
	\			 \
	 \________________________\
	 / foldolt sorok	  /
	/________________________/
	| sor 12		 |
	| sor 13		 |
	| sor 14		 |
	+------------------------+

A tartalmazott szöveg még mindig a bufferben van. Csak a megjelenítés módja
változott.

A foldolás egyik előnye, hogy jobb képet kaphatunk a fájlról, hiszen a
logikailag összetartozó sorok nagy részét egy sorba tömörítjük, helyét csak
egyetlen egy sorral jelezzük.

==============================================================================
*28.2*	Kézi foldolás

Próbáld ki: vidd a kurzort egy bekezdésre: >

	zfap

A bekezdést helyettesítette egyetlen egy sor. Egy foldot hoztál létre. |zf|
egy operátor, |ap| pedig a szöveg-objektum volt. A |zf| operátort bármilyen
elmozdulással kombinálhatjuk, mely létrehozza a kijelölésen átívelő foldot. 
A |zf| Visual módban is működik.

A fold kinyitásához gépeld be: >

	zo

Bezárása pedig: >

	zc

Az összes folddal kapcsolatos parancs "z"-vel kezdődik. Kis fantáziával ugyan
de a "z" betű éppen úgy néz ki, mint egy összehajtott papírlap oldalról. A
"z"-t követő betűt pedig így érdemes megjegyezni: >

	zf	Fold létrehozása (Fold)
	zo	Fold kinyitása (Open)
	zc	Fold bezárása (Close)

A foldok egymásba ágyazhatóak: a dokumentum bekezdéseit foldoljuk, aztán még
egyszer foldoljuk az összeset (fejezet). Ha kinyitjuk a fejezet foldot, akkor
az visszaállítja (megjeleníti) a bekezdések foldjait az eredeti állapotukba
(melyek lehetnek nyitottak, lehetnek zártak, attól függően, hogy hogyan
hagytuk őket).

Tegyük fel, hogy készítettél pár foldot, de látni szeretnéd az összes
szöveget. Ha türelmes vagy, akkor bejárhatod az összeset, külön futtatva a
"zo" parancsot. Gyorsabb módja: >

	zr

Ez csökkenti a foldokat (Reduce). Ellentéte: >

	zm

Zárja a foldokat (More). Megismételheted a "zr" és "zm" parancsokat, ha egymásba
ágyazott foldokkal dolgozol.

Ha foldjaid több szintesek, akkor az összeset kinyithatod egyszerre: >

	zR

Csökkenti a foldokat (kinyitja őket). Az összes fold bezárása: >

	zM

Mely bezárja az összes foldot (More).

A foldolás engedélyezése, tiltása a |zn| paranccsal változtatható. A |zN|
visszaállítja a foldokat, ahogyan voltak. A |zi| változtatja a 'foldenable'
állapotát. Példa munkafolyamat:

    - foldok létrehozás
    - navigáció, szerkesztési pontra
    - |zi| szöveg szerkesztése
    - |zi| navigáció

A kézi foldolás részletes leírása: |fold-manual|

==============================================================================
*28.3*	Munka a foldokkal

"j" és "k" parancsok üres sorként haladnák át a zárt foldokon, meggyorsítva a
navigációt.

A foldokat egyszerű sorként másolhatjuk, törölhetjük és illeszthetjük be. Így
a fájlt nagyon gyorsan át lehet rendezni. Győződj meg arról, hogy minden
fold egy teljes függvényt tartalmaz (vagy picivel kevesebbet, ami a
'foldmethod' opció függvénye). Töröld ki a függvényt "dd"-vel, menj a
megfelelő melyre és illeszd be "p". Ha a függvény (alja vagy teteje) kilóg a
foldból, Visual módban jelöld ki a területet:

    - vidd a kurzort az első sorra
    - válts át "V" Visual módra
    - jelöld ki az utolsó sort is
    - töröld ki "d" a sorokat
    - menj az új helyre, majd illeszd be "p"

Néha nehéz észrevenni, hogy egy fold merre található, azaz, hogy melyik soron
használhatjuk a |zo| parancsot. A jobb szemléltetéshez: >

	:set foldcolumn=4

Mely létrehoz egy (jelen esetben) 4 oszlopból álló sávot az ablak bal oldalán,
ahol "+" jelölést láthatunk a zárt állapotú foldok helyén, "-" jelet pedig a
nyitott foldok esetén. A fold által tartalmazott sorokat "|" karakter jelzi.

Egér használatával is elvégezhetjük a foldok nyitását a "+" jelölésre
kattintva, zárását a "-" vagy "|" jelekre kattintva. 

Kurzor alatt lévő össze fold kinyitása |zO|.
Kurzor alatt lévő összes fold bezárása |zC|.
Kurzor sorában lévő fold törlése |zd| (csak a fold definícióját).
Kurzor alatt lévő összes fold törlése |zD| (csak a fold definícióját).

Insert módban a kurzor alatt lévő sor soha nem záródik be (ha zárva van, akkor
kinyílik). Így láthatod, hogy mit írsz!

A foldok automatikusan megnyílnak, ha a kurzort rajtuk jobbra vagy balra
mozgatjuk. Például, a "0" parancs megnyitja a kurzor alatt lévő foldot (ha
'foldopen' "hor"-ként van konfigurálva, ami az alapértelmezés). A 'foldopen'
opció meghatározza, hogy mely parancsok hatására nyíljon ki a fold. A kurzor
alatt lévő fold minden esetben kinyílik, ha: >

	:set foldopen=all

Figyelem: Így nem tudsz zárt foldra ugrani.  Ideiglenes jó ötletnek tűnik, de
próbáljuk alapértelmezetten tartani: >

	:set foldopen&

A foldokat automatikusan bezárhatod, ha kilépsz belőlük: >

	:set foldclose=all


Ez újra-alkalmazza a 'foldlevel' opciót azokon a foldokon, melyben nem
szerepel a kurzor. Próbáld ki, hogy hogyan érzed. A |zm| egy szintet bezár a
|zf| egy szintet kinyit.

A foldolás az ablak tekintetében lokális, ezért egy fájlt megnyithatsz
többször is, egyik ablakban foldokkal, másikban anélkül. (Vagy az egyikben
nyitott foldokkal, a másikban pedig zártakkal).

==============================================================================
*28.4*	Foldok mentése, visszaállítása

Ha "elhagysz" egy fájlt (egy másikat nyitsz meg), akkor a foldok helyzete
elveszik. A kézzel kinyitott és bezárt foldok felveszik kezdő állapotukat
visszatéréskor. Ha kézzel hozol létre foldot, akkor az összes elveszik.
Mentésükhöz használt a |:mkview| parancsot: >

	:mkview

Mely elmenti a nézetet befolyásoló beállításokat. A menthető opciókat a
'viewoptions'-ban  állíthatjuk be. A fájl megnyitásánál töltsük be a nézetet
újra: >

	:loadview

Egy fájlról tíz nézet tárolható. Például, a jelenlegi nézet elmentése a 3.
nézetként, 2. nézet visszatöltése: >

	:mkview 3
	:loadview 2

Megjegyzés: Sorok beszúrásakor vagy törlésekor, a nézet invaliddá válhat. A
'viewdir' opcióban meghatározott könyvtárban néha töröld a régi nézethez
tartozó fájlt.

==============================================================================
*28.5*	Foldolás behúzás által

Defining folds with |zf| is a lot of work.  If your text is structured by
giving lower level items a larger indent, you can use the indent folding
method.  This will create folds for every sequence of lines with the same
indent.  Lines with a larger indent will become nested folds.  This works well
with many programming languages.

Try this by setting the 'foldmethod' option: >

	:set foldmethod=indent

Then you can use the |zm| and |zr| commands to fold more and reduce folding.
It's easy to see on this example text:

This line is not indented
	This line is indented once
		This line is indented twice
		This line is indented twice
	This line is indented once
This line is not indented
	This line is indented once
	This line is indented once

Note that the relation between the amount of indent and the fold depth depends
on the 'shiftwidth' option.  Each 'shiftwidth' worth of indent adds one to the
depth of the fold.  This is called a fold level.

When you use the |zr| and |zm| commands you actually increase or decrease the
'foldlevel' option.  You could also set it directly: >

	:set foldlevel=3

This means that all folds with three times a 'shiftwidth' indent or more will
be closed.  The lower the foldlevel, the more folds will be closed.  When
'foldlevel' is zero, all folds are closed.  |zM| does set 'foldlevel' to zero.
The opposite command |zR| sets 'foldlevel' to the deepest fold level that is
present in the file.

Thus there are two ways to open and close the folds:
(A) By setting the fold level.
    This gives a very quick way of "zooming out" to view the structure of the
    text, move the cursor, and "zoom in" on the text again.

(B) By using |zo| and |zc| commands to open or close specific folds.
    This allows opening only those folds that you want to be open, while other
    folds remain closed.

This can be combined: You can first close most folds by using |zm| a few times
and then open a specific fold with |zo|.  Or open all folds with |zR| and
then close specific folds with |zc|.

But you cannot manually define folds when 'foldmethod' is "indent", as that
would conflict with the relation between the indent and the fold level.

More about folding by indent in the reference manual: |fold-indent|

==============================================================================
*28.6*	Folding with markers

Markers in the text are used to specify the start and end of a fold region.
This gives precise control over which lines are included in a fold.  The
disadvantage is that the text needs to be modified.

Try it: >

	:set foldmethod=marker

Example text, as it could appear in a C program:

	/* foobar () {{{ */
	int foobar()
	{
		/* return a value {{{ */
		return 42;
		/* }}} */
	}
	/* }}} */

Notice that the folded line will display the text before the marker.  This is
very useful to tell what the fold contains.

It's quite annoying when the markers don't pair up correctly after moving some
lines around.  This can be avoided by using numbered markers.  Example:

	/* global variables {{{1 */
	int varA, varB;

	/* functions {{{1 */
	/* funcA() {{{2 */
	void funcA() {}

	/* funcB() {{{2 */
	void funcB() {}
	/* }}}1 */

At every numbered marker a fold at the specified level begins.  This will make
any fold at a higher level stop here.  You can just use numbered start markers
to define all folds.  Only when you want to explicitly stop a fold before
another starts you need to add an end marker.

More about folding with markers in the reference manual: |fold-marker|

==============================================================================
*28.7*	Folding by syntax

For each language Vim uses a different syntax file.  This defines the colors
for various items in the file.  If you are reading this in Vim, in a terminal
that supports colors, the colors you see are made with the "help" syntax file.
   In the syntax files it is possible to add syntax items that have the "fold"
argument.  These define a fold region.  This requires writing a syntax file
and adding these items in it.  That's not so easy to do.  But once it's done,
all folding happens automatically.
   Here we'll assume you are using an existing syntax file.  Then there is
nothing more to explain.  You can open and close folds as explained above.
The folds will be created and deleted automatically when you edit the file.

More about folding by syntax in the reference manual: |fold-syntax|

==============================================================================
*28.8*	Folding by expression

This is similar to folding by indent, but instead of using the indent of a
line a user function is called to compute the fold level of a line.  You can
use this for text where something in the text indicates which lines belong
together.  An example is an e-mail message where the quoted text is indicated
by a ">" before the line.  To fold these quotes use this: >

	:set foldmethod=expr
	:set foldexpr=strlen(substitute(substitute(getline(v:lnum),'\\s','',\"g\"),'[^>].*','',''))

You can try it out on this text:

> quoted text he wrote
> quoted text he wrote
> > double quoted text I wrote
> > double quoted text I wrote

Explanation for the 'foldexpr' used in the example (inside out):
   getline(v:lnum)			gets the current line
   substitute(...,'\\s','','g')		removes all white space from the line
   substitute(...,'[^>].*','','')	removes everything after leading '>'s
   strlen(...)				counts the length of the string, which
					is the number of '>'s found

Note that a backslash must be inserted before every space, double quote and
backslash for the ":set" command.  If this confuses you, do >

	:set foldexpr

to check the actual resulting value.  To correct a complicated expression, use
the command-line completion: >

	:set foldexpr=<Tab>

Where <Tab> is a real Tab.  Vim will fill in the previous value, which you can
then edit.

When the expression gets more complicated you should put it in a function and
set 'foldexpr' to call that function.

More about folding by expression in the reference manual: |fold-expr|

==============================================================================
*28.9*	Folding unchanged lines

This is useful when you set the 'diff' option in the same window.  The
|vimdiff| command does this for you.  Example: >

	:setlocal diff foldmethod=diff scrollbind nowrap foldlevel=1

Do this in every window that shows a different version of the same file.  You
will clearly see the differences between the files, while the text that didn't
change is folded.

For more details see |fold-diff|.

==============================================================================
*28.10* Which fold method to use?

All these possibilities make you wonder which method you should choose.
Unfortunately, there is no golden rule.  Here are some hints.

If there is a syntax file with folding for the language you are editing, that
is probably the best choice.  If there isn't one, you might try to write it.
This requires a good knowledge of search patterns.  It's not easy, but when
it's working you will not have to define folds manually.

Typing commands to manually fold regions can be used for unstructured text.
Then use the |:mkview| command to save and restore your folds.

The marker method requires you to change the file.  If you are sharing the
files with other people or you have to meet company standards, you might not
be allowed to add them.
   The main advantage of markers is that you can put them exactly where you
want them.  That avoids that a few lines are missed when you cut and paste
folds.  And you can add a comment about what is contained in the fold.

Folding by indent is something that works in many files, but not always very
well.  Use it when you can't use one of the other methods.  However, it is
very useful for outlining.  Then you specifically use one 'shiftwidth' for
each nesting level.

Folding with expressions can make folds in almost any structured text.  It is
quite simple to specify, especially if the start and end of a fold can easily
be recognized.
   If you use the "expr" method to define folds, but they are not exactly how
you want them, you could switch to the "manual" method.  This will not remove
the defined folds.  Then you can delete or add folds manually.

==============================================================================

Következő fejezet: |usr_29.txt|  Moving through programs

Jogi információk: lásd |manual-copyright|  vim:tw=78:ts=8:noet:ft=help:norl:
