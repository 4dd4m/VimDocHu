*usr_12.txt*	For Vim version 8.2.  Last change: 2021 Apr 19

		  Bram Moolenaar: Vim felhasználói kézikönyv

			       Tippek, Trükkök


By combining several commands you can make Vim do nearly everything.  In this
chapter a number of useful combinations will be presented.  This uses the
commands introduced in the previous chapters and a few more.

|12.1|	Szavak cseréje
|12.2|	Csere "Last, First" erre "First Last"
|12.3|	Lista rendezése
|12.4|	Fordított sorrend
|12.5|	Szavak számolása
|12.6|	Help fájlok keresése
|12.7|	Üres karakterek levágása
|12.8|	Mi használja az adott szót?

Következő fejezet: |usr_20.txt|  Command-line parancsok gépelése gyorsan
    Előző fejezet: |usr_11.txt|  Helyreállítás
  Tartalomjegyzék: |usr_toc.txt|

==============================================================================
*12.1*	Szavak cseréje

A substitute (csere) parancs lecseréli az összes egyező szót: >

	:%s/four/4/g

A "%" tartomány, a teljes fájlra kiterjed. A "g" flag a végén pedig a sorban
szereplő összes előfordulást lecseréli. 
   A parancs nem hibátlan, hiszen ha a fájl tartalmazza például a "thirtyfour"
szót, akkor a parancs futtatása után "thirty4" lesz az eredmény. Hogy elkerüld
a problematikát, és ne érjen meglepetés "\<" karakterekkel illeszthetsz a szó
elejére: >

	:%s/\<four/4/g

Ha szereted a meglepetéseket, akkor itt van még egy: "fourteen". A mintánk nem
illesztett a szó végére, hiába a "four" karakter valóban szókezdet. A szavak
végét "\>" karakterekkel illesztheted: >

	:%s/\<four\>/4/g

Ha programozó vagy, akkor például sokszor csak a kommentekben kell valamit
lecserélned anélkül, hogy a kódhoz hozzányúlnál. A nem teljesen egyértelmű,
vagy veszélyesnek tűnő cseréknél kérj megerősítést a "c" flaggel és minden
csere előtt validálnod kell a műveletet: >


	:%s/\<four\>/4/gc


CSERÉK TÖBB FÁJLBAN

Tegyük fel, hogy egy adott stringet kell lecseréled, viszont a String több
fájlban is szerepel. Megnyithatod őket egyesével és manuálisan elvégezheted a
keresés. Ez végképp nem elegáns. Egyszerűbb, ha rögzíted és visszajátszod.
   Azt is feltételezzük, hogy van egy könyvtárnyi C++ fájlod, melyek .cpp
kiterjesztéssel végződnek. Mindegyikben van egy "GetResp" függvény, de át
szeretnéd nevezni "GetAnswer"-re. 

	vim *.cpp		Indítsd el a Vimet, argumentumként add át az
				összes C++ fájlt. Az első fájlban vagy.
	qq			Kezdd el a rögzítést a q regiszterbe.
	:%s/\<GetResp\>/GetAnswer/g
				Végezd el a cserét az első fájlban.
	:wnext			Mentsd a fájlt és lépj a következőre.
	q			Állítsd le a felvételt
	@q			Futtasd a @q regisztert.  Ez mind a cserét,
				mind a fájlváltást is ":wnext" elvégzi.
				Győződj meg arról, hogy nem kaptál
				hibaüzenete.
	999@q			Futtasd a többi fájlon is.

Az utolsó fájlon kötelezően hibaüzenetet kell kapj (ha tényleg 999 fájlra
hívtad meg a parancsot, de az argumentumlistában kevesebb szerepel, a fájlok
elfogynak, a ":wnext" pedig nem tud mire továbblépni). Hibaüzenet hatására a
futtatás azonnal leáll.

	Megjegyzés:
	Ha a hibaüzenet nem az utolsó fájlnál jelentkezik, hanem előtte, akkor
	az azt jelenti, hogy a maradék fájlokon nem futott le a makró.

A bökkenő: az egyik fájl nem tartalmazza a "GetResp" függvényt, hibaüzenetet
kapsz és a művelet megszakad. Add hozzá az "e" flaget a csere parancshoz: >

	:%s/\<GetResp\>/GetAnswer/ge

Az "e" flag azt jelenti: hogy a csere nem fog hibát dobni, ha egyáltalán nem
talált egyezést

==============================================================================
*12.2*	"Last, First" cseréje erre "First Last"

Van pár név a listádon:

	Doe, John ~
	Smith, Peter ~

Meg szeretnéd cserélni őket:

	John Doe ~
	Peter Smith ~

Ez egyetlen egy paranccsal megoldható:

	:%s/\([^,]*\), \(.*\)/\2 \1/

Szedjük darabokra. Az utasítás keresés "s" paranccsal kezdődik, mely előtt a
"%" tartomány található (fájl összes sora), azaz a teljes fájlban cserélünk.
   Két argumentumot adunk át a parancsnak, amit le szeretnénk cserélni és
amire cserélni szeretnénk "/from/to/". A "from" és "to" perjelekkel van
tagolva. A "from" az alábbi mintát tartalmazza:
							\([^,]*\), \(.*\) ~

   A  \( \) közötti rész illeszkedik a  "Last"-ra,	\(     \)
	    mely a számok és a vessző kivételével	  [^,]
	    bármire, bármennyiszer illeszkedik		      *
	szó szerint ", "-re illeszkedik				 ,
   A  \( \) közötti rész illeszkedik a  "First"-re,	       	   \(  \)
	    bármely karakter					     .
	    bármennyiszer					      *

A "to" részben a "\2" és "\1" karaktereket láthatjuk. Ezeket hivatkozásoknak
hívjuk. Arra a szövegrészletre hivatkozik, melyet az első "\( \)"-ra
illeszkedett. "\2" pedig a második "\( \)" által illeszkedett szövegre
hivatkozik.  Azaz, ha John Doet vesszük alapul, akkor "\1" a Johnra "\2" pedig
Doera hivatkozik. A helyettesítésben jól látható, hogy a hivatkozások meg
vannak fordítva "\2 \1". Escapelés nélkül a kifejezés így nézne ki: > 


	:%s/([^,]*), (.*)/\2 \1/


A keresés kilenc hivatkozást képes egyszerre kezelni. A "\0" a teljes
illeszkedést jelenti, egyben. A csere parancs még több speciális elemet
tartalmaz, lásd |sub-replace-special|.

==============================================================================
*12.3*	Lista rendezése

A Makefájlok többnyire fájllistákat rejtenek. Például:

	OBJS = \ ~
		version.o \ ~
		pch.o \ ~
		getopt.o \ ~
		util.o \ ~
		getopt1.o \ ~
		inp.o \ ~
		patch.o \ ~
		backup.o ~

A fájllista tartományát adjuk át a sort parancsnak rendezésre: >

	/^OBJS
	j
	:.,/^$/-1!sort

This goes to the first line, where "OBJS" is the first thing in the line.
Then it goes one line down and filters the lines until the next empty line.
You could also select the lines in Visual mode and then use "!sort".  That's
easier to type, but more work when there are many lines.
   The result is this:

	OBJS = \ ~
		backup.o ~
		getopt.o \ ~
		getopt1.o \ ~
		inp.o \ ~
		patch.o \ ~
		pch.o \ ~
		util.o \ ~
		version.o \ ~


Notice that a backslash at the end of each line is used to indicate the line
continues.  After sorting, this is wrong!  The "backup.o" line that was at
the end didn't have a backslash.  Now that it sorts to another place, it
must have a backslash.
   The simplest solution is to add the backslash with "A \<Esc>".  You can
keep the backslash in the last line, if you make sure an empty line comes
after it.  That way you don't have this problem again.

==============================================================================
*12.4*	Reverse line order

The |:global| command can be combined with the |:move| command to move all the
lines before the first line, resulting in a reversed file.  The command is: >

	:global/^/move 0

Abbreviated: >

	:g/^/m 0

The "^" regular expression matches the beginning of the line (even if the line
is blank).  The |:move| command moves the matching line to after the imaginary
zeroth line, so the current matching line becomes the first line of the file.
As the |:global| command is not confused by the changing line numbering,
|:global| proceeds to match all remaining lines of the file and puts each as
the first.

This also works on a range of lines.  First move to above the first line and
mark it with "mt".  Then move the cursor to the last line in the range and
type: >

	:'t+1,.g/^/m 't

==============================================================================
*12.5*	Count words

Sometimes you have to write a text with a maximum number of words.  Vim can
count the words for you.
   When the whole file is what you want to count the words in, use this
command: >

	g CTRL-G

Do not type a space after the g, this is just used here to make the command
easy to read.
   The output looks like this:

	Col 1 of 0; Line 141 of 157; Word 748 of 774; Byte 4489 of 4976 ~

You can see on which word you are (748), and the total number of words in the
file (774).

When the text is only part of a file, you could move to the start of the text,
type "g CTRL-G", move to the end of the text, type "g CTRL-G" again, and then
use your brain to compute the difference in the word position.  That's a good
exercise, but there is an easier way.  With Visual mode, select the text you
want to count words in.  Then type g CTRL-G.  The result:

	Selected 5 of 293 Lines; 70 of 1884 Words; 359 of 10928 Bytes ~

For other ways to count words, lines and other items, see |count-items|.

==============================================================================
*12.6*	Find a man page					*find-manpage*

While editing a shell script or C program, you are using a command or function
that you want to find the man page for (this is on Unix).  Let's first use a
simple way: Move the cursor to the word you want to find help on and press >

	K

Vim will run the external "man" program on the word.  If the man page is
found, it is displayed.  This uses the normal pager to scroll through the text
(mostly the "more" program).  When you get to the end pressing <Enter> will
get you back into Vim.

A disadvantage is that you can't see the man page and the text you are working
on at the same time.  There is a trick to make the man page appear in a Vim
window.  First, load the man filetype plugin: >

	:runtime! ftplugin/man.vim

Put this command in your vimrc file if you intend to do this often.  Now you
can use the ":Man" command to open a window on a man page: >

	:Man csh

You can scroll around and the text is highlighted.  This allows you to find
the help you were looking for.  Use CTRL-W w to jump to the window with the
text you were working on.
   To find a man page in a specific section, put the section number first.
For example, to look in section 3 for "echo": >

	:Man 3 echo

To jump to another man page, which is in the text with the typical form
"word(1)", press CTRL-] on it.  Further ":Man" commands will use the same
window.

To display a man page for the word under the cursor, use this: >

	\K

(If you redefined the <Leader>, use it instead of the backslash).
For example, you want to know the return value of "strstr()" while editing
this line:

	if ( strstr (input, "aap") == ) ~

Move the cursor to somewhere on "strstr" and type "\K".  A window will open
to display the man page for strstr().

==============================================================================
*12.7*	Trim blanks

Some people find spaces and tabs at the end of a line useless, wasteful, and
ugly.  To remove whitespace at the end of every line, execute the following
command: >

	:%s/\s\+$//

The line range "%" is used, thus this works on the whole file.  The pattern
that the ":substitute" command matches with is "\s\+$".  This finds white
space characters (\s), 1 or more of them (\+), before the end-of-line ($).
Later will be explained how you write patterns like this, see |usr_27.txt|.
   The "to" part of the substitute command is empty: "//".  Thus it replaces
with nothing, effectively deleting the matched white space.

Another wasteful use of spaces is placing them before a tab.  Often these can
be deleted without changing the amount of white space.  But not always!
Therefore, you can best do this manually.  Use this search command: >

	/

You cannot see Frissítve but there is a space before a tab in this command.  Thus
it's "/<Space><Tab>".   Now use "x" to delete the space and check that the
amount of white space doesn't change.  You might have to insert a tab if it
does change.  Type "n" to find the next match.  Repeat this until no more
matches can be found.

==============================================================================
*12.8*	Find where a word is used

If you are a UNIX user, you can use a combination of Vim and the grep command
to edit all the files that contain a given word.  This is extremely useful if
you are working on a program and want to view or edit all the files that
contain a specific variable.
   For example, suppose you want to edit all the C program files that contain
the word "frame_counter".  To do this you use the command: >

	vim `grep -l frame_counter *.c`

Let's look at this command in detail.  The grep command searches through a set
of files for a given word.  Because the -l argument is specified, the command
will only list the files containing the word and not print the matching lines.
The word it is searching for is "frame_counter".  Actually, this can be any
regular expression.  (Note: What grep uses for regular expressions is not
exactly the same as what Vim uses.)
   The entire command is enclosed in backticks (`).  This tells the UNIX shell
to run this command and pretend that the results were typed on the command
line.  So what happens is that the grep command is run and produces a list of
files, these files are put on the Vim command line.  This results in Vim
editing the file list that is the output of grep.  You can then use commands
like ":next" and ":first" to browse through the files.


FINDING EACH LINE

The above command only finds the files in which the word is found.  You still
have to find the word within the files.
   Vim has a built-in command that you can use to search a set of files for a
given string.  If you want to find all occurrences of "error_string" in all C
program files, for example, enter the following command: >

	:grep error_string *.c

This causes Vim to search for the string "error_string" in all the specified
files (*.c).  The editor will now open the first file where a match is found
and position the cursor on the first matching line.  To go to the next
matching line (no matter in what file it is), use the ":cnext" command.  To go
to the previous match, use the ":cprev" command.  Use ":clist" to see all the
matches and where they are.
   The ":grep" command uses the external commands grep (on Unix) or findstr
(on Windows).  You can change this by setting the option 'grepprg'.

==============================================================================

Következő fejezet: |usr_20.txt| Command-line parancsok gépelése gyorsan 

Jogi információk: lásd |manual-copyright|  vim:tw=78:ts=8:noet:ft=help:norl:
