*usr_10.txt*	Vim verzió 8.2.  Frissítve: 2019 Nov 22

		  Bram Moolenaar: Vim felhasználói kézikönyv

			    Nagyobb változtatások


A 4. fejezetben eddig a kisebb változtatásokról esett szó. Ebben a fejezetben
olyan változtatásokról lesz szó, melyek ismételhetőek vagy a fájl jelentős
részét megváltoztatják. Visual blokk módban számos dolgot tehetünk a
szöveggel. Külső programokkal pedig egészen bonyolult műveleteket végezhetünk.

|10.1|	Parancsok felvétele és visszajátszása
|10.2|	Helyettesítés
|10.3|	Parancs-tartományok
|10.4|	A global parancs
|10.5|	Visual blokk mód
|10.6|	Fájl részeinek olvasása, írása
|10.7|	Szöveg formázása
|10.8|	Kis- nagybetű váltása
|10.9|	Külső programok használata

Következő fejezet: |usr_11.txt|  Helyreállítása
    Előző fejezet: |usr_09.txt|  A GUI használata
  Tartalomjegyzék: |usr_toc.txt|

==============================================================================
*10.1*	Parancsok felvétele és visszajátszása

A "." parancs megismétli az utolsó szerkesztést. De mi van akkor, ha többre
van szükséged, mint egyszerű változtatás? Itt jön be parancsok felvétele,
három lépésben:

1. A "q{register}" parancs elkezdi rögzíteni a kiadott parancsokat a {register}
   nevű regiszterbe. A regiszter csak a-z karakter lehet.
2. Add ki a parancsaidat.
3. A felvétel befejezéséhez nyomj q billentyűt (Normál módban).

A makró futtatásához írd be az alábbi parancsot "@{register}".


Egy példával demonstrálható, hogy hogyan működik ez élesben. A programunkba
fájlokat kell importáljunk:

	stdio.h ~
	fcntl.h ~
	unistd.h ~
	stdlib.h ~

A végeredmények így kell kinéznie:

	#include "stdio.h" ~
	#include "fcntl.h" ~
	#include "unistd.h" ~
	#include "stdlib.h" ~

A bal felső sarokba viszed a kurzort, a stdio.h s betűjére. A parancsok pedig:

	qa			Elkezdjük a makró rögzítését az a jelű
	^			regiszterbe.
	i#include "<Esc>	Beírjuk azt, hogy:  #include " a sor elejére.
	$			A sor végére ugrunk.
	a"<Esc>			Hozzáfűzzük az idézőjelet (") a sor végére.
	j			A következő sorra ugrunk.
	0			A sor elejére ugrunk.
	q			Leállítjuk a makró rögzítését.

A munka elvégezve. Futtassuk a makrót a "@a" parancs kiadásával.
   A makróhívások prefixálhatóak, így az fenti hívást így ismételhetjük meg
háromszor egy lépésben: >

	3@a


MOZGÁS ÉS FUTTATÁS

A szerencse forgandó, lesznek olyan szituációk, amikor a makrókat nem egy
helyen kell futtatnod, hanem szanaszét szórva a fájlban. Ugorj a következő
helyre és futtasd a makrót újra a "@a" paranccsal. Ha egyszer már futtattad a
makrók, akkor elérhetővé válik a "@@" makróhivatkozás, mely legutolsó
futtatott makrót hívja meg. Gépelni is sokkal kellemesebb. Ha a b jelű makrót
futtatod "@b", "@@" a b jelű makrót fogja hívni.
   Ha össze szeretnénk hasonlítani a makrókat és a "." parancsot, akkor a
különbség számottevő. Először is, "." parancs csak egy szerkesztés tud
ismételni, "@a"-val pedig számos apró lépést alkalmaztunk. "." csak Insert
parancs alatti szerkesztéseinket ismétli meg ("@a" során Normál módból
váltottunk Insert módba, aztán vissza Normál, vissza Insert és Normál).
   Ráadásul, összesen 26 regiszter áll rendelkezésünkre ("." csak egy, mely
állandóan felülíródik).


REGISZTEREK HASZNÁLATA

A regiszterekkel tudjuk rögzíteni a parancsainkat, akár csak a törlés vagy
másolás parancsok (a különbség csak a regiszter azonosítója). Ezen tulajdonság
még magasabb szintű manipulációt tesz lehetővé.
   Tegyük fel, hogy rögzítettél már valamit az n jelű regiszterbe. Futtatáskor
kiderül, hogy valami baj történt. Megpróbálhatod újra rögzíteni a szekvenciát,
de semmi garancia nincs arra, hogy hiba nélkül tudod rögzíteni. Csináld így:

	G			Fájl végére ugrás
	o<Esc>			Üres sor kurzor alá
	"np			Szöveg másolása n regiszterből.  Láthatóvá
				válnak a makrót tartalmazó parancsok.
	{rögzített parancsok}   Javítsd ki a parancsot. Mintha szöveget
				szerkesztenél.
	0			Sor elejére ugrás
	"ny$			A helyes parancs visszamásolása az n jelű
				regiszterbe.
	dd			Ideiglenes sor törlése.

Most már futtathatod a korrigált "@n" makrót. Ha olyan parancsot rögzítettél,
amely sortörést tartalmaz, akkor az utolsó két lépést értelemszerűen egészítsd
ki, hogy az összes sort tartalmazza).


HOZZÁFŰZÉS A REGISZTERHEZ

Eddig csak kisbetűs regisztereket használtunk. Hozzáfűzéshez használj
nagybetűs regiszter azonosítót.
   Tegyük fel, hogy felvettél valamit a c regiszterbe, amivel változtatsz egy
szót. Remekül működik, de hozzá szeretnéd adni, hogy keresse meg a következő
szót. Semmi akadály: >

	qC/word<Enter>q

A "qC" paranccsal nyitsz, mely hozzá fog fűzni a c jelű regiszterhez. A
nagybetű regiszterazonosító mindig a kisbetűshöz fűz hozzá (C -> c).

Ez működik másolás és törlés rögzítése esetében is. Például tegyük fel, hogy
össze szeretnél gyűjteni adott sorokat az "a regiszterbe, hogy aztán egyszerre
bemásolhasd őket. Az első sort másold be így: >

	"aY

A másodiktól kezdve pedig így: >

	    "AY

Ismételd amíg jól esik. Az "a jelű regiszter tartalmazni fogja a kimásolt
sorokat pontosan abban a sorrendben, ahogy kimásoltad őket.

==============================================================================
*10.2*	Csere						*find-replace*

A ":substitute" paranccsal cserélhetsz szöveget, akár több soron, vagy az
egész fájlon keresztül. A parancs általános alakja: >

	:[range]substitute/from/to/[flags]

A parancs lecseréli az összes [range] tartományban lévő "from" szót a "to" szóra.
Például, lecseréled az összes "Professor" szót "Teacher"-re az összes sorban:
>
	:%substitute/Professor/Teacher/
<
	Megjegyzés:
	A ":substitute" parancsot szinte kivétel nélkül sohasem írjuk ki
	teljes alakban. Az esetek nagy százalékában az emberek csak ":s"-ként
	rövidítik. Ezentúl a kézikönyv is így fog a cserére hivatkozni.

A "%" a csere parancs előtt jelenti azt, hogy a csere az összes sorra érvényes
lesz (teljes fájlon át). "%" nélkül ":s" csak az aktív sorban cserél. A
tartományokról bővebben a 1. "%" nélkül ":s" csak az aktív sorban cserél. A
tartományokról bővebben a |10.3| fejezetben.

Alapértelmezés szerint a ":substitute" parancs csak az első előfordulást
cseréli le. Például, az előző parancs az alábbit eredményezi, ha a sorban
egynél több előfordulás van:


	Professor Smith criticized Professor Johnson today. ~

Erre:

	Teacher Smith criticized Professor Johnson today. ~

Ahhoz, hogy az összes előfordulást lecseréld, add a g (global) flaget a
parancs végéhez: >

	:%s/Professor/Teacher/g

Eredmény (a 171. sorban szereplő példa alapján):

	Teacher Smith criticized Teacher Johnson today. ~

Egyéb flagek, többek között a p (print), melynek hatására a ":substitute"
kiírja az utolsó sort, melyben cserélt. A c (confirm) flag arra utasítja a
":substitute" parancsot, hogy megerősítést kérjen minden csere előtt. Írd be
az alábbit: >

	:%s/Professor/Teacher/c

Mihelyst a vim megtalálja a "Professor" előfordulását, udvariasan, de végképp
sem tolakodóan megkérdez, hogy mit tegyek. Valahogy így: >

	replace with Teacher (y/n/a/q/l/^E/^Y)?

A válaszok pedig lehetnek:

	y		Igen; cseréld le.
	n		Ne; hagyjuk ki.
	a		Az összesen; cseréld le ezt, és minden továbbit kérdés
			nélkül.
	q		Kilépés; ne változtass többet.
	l		Utolsó; még ezt cseréld le és lépj ki.
	CTRL-E		Görgetés egy sorral feljebb.
	CTRL-Y		Görgetés egy sorral lejjebb.


A "from" része a csere parancsnak (azaz amit keresünk) valójában egy minta.
Ugyanezen a mintán alapul a keresés is. Például, az alábbi parancs csak akkor
cserél, ha "the" szó a sor legelején található: >

	:s/^the/these/

Ha a "from" vagy a "to" mezők per jelet tartalmaznak akkor  visszaperjellel
escapelni kell. Egyszerűbb azonban, ha perjel helyett egy másik karaktert
használunk. Például "+" karaktert:

???  Teszt
A simpler way is to use another character instead of the slash.  A plus, for 
example: >

	:s+one/two+one or two+

==============================================================================
*10.3*	Tartományok

A ":substitute" parancs, mint megannyi más ":" parancs, alkalmazhatóak
meghatározott sorokra. Ezt hívjuk tartományoknak.
   A legegyszerűbb tartomány a {number},{number}. Például: >

	:1,5s/this/that/g

Futtatja a csere parancsot az első öt soron (beleértve 1., valamint az 5.
sort is). A tartomány mindig a parancs elé kerül.

Egyetlen egy számmal a csere csak az adott számú sorban hajtódik végre: >

	:54s/President/Fool/

Néhány parancs a teljes fájlon hajtódik végre, ha nem határozol meg
tartományt. Ahhoz, hogy a parancs az aktuális sorban fusson, alkalmazhatod a
"." tartományt. A ":write" parancs így működik. Tartomány nélkül a fájl összes
sora kiíródik, viszont ha csak az aktuális sort szeretnéd kiírni:  >

	:.write otherfile

A fájl első sora tartományok meghatározásánál mindig számmal szerepel. De mi
can az utolsó sorral? A "$" karaktert használjuk erre a célra. Például, csere
az aktív sortól a fájl végéig. >

	:.,$s/yes/no/

A "%" tartomány gyakorlatilag csak egy rövidítése a "1,$" tartománynak.


MINTÁK HASZNÁLATA A TARTOMÁNYOKBAN

Tegyük fel, hogy egy könyv fejezetét írod és ki szeretnél cserélni minden
"grey" szót a "gray" szóra, de csak ebben a fejezetben, a következőben nem.
Tudod, hogy a "Chapter" szó csak a fejezetek címében a sor elején szerepelhet, 
így fel tudod használni a tartomány pontos megállapításához. A feladat
megoldása: >

	:?^Chapter?,/^Chapter/s=grey=gray=g

A keresési mintát kétszer láthatod. Az első "?^Chapter?" találja meg a
kurzortól felfelé elhelyezkedő sorokot egészen az előző Chapterig. A ?minta? 
tehát az adott pozíciótól visszafelé keres. Hasonlóan a "/^Chapter/" minta
pedig előre irányban találja meg a következő Chaptert.
   A káosz elkerülése érdekében a perjelek helyett itt "=" jel szerepel. A
perjel is működőképes, de jelen esetben túl zajos.


BŐVÍTÉS ÉS SZŰKÍTÉS

A keresési parancsunkkal már csak az az egy baj van, hogy ha a következő
fejezet címében szerepel a "grey" szó, akkor a keresés azt is kigyomlálja.
Talán ezt akarod, de mi van ha nem? Ha nem, akkor offszetelned kell a
tartományt.
   Szőkítsük le a tartományt egy sorral (a következő Chapter szó fölötti sor):
   >
	/Chapter/-1

Az egész számok halmazába tartozó bármely számot használhattuk volna 1 helyett.
Így pedig bővíthetjük a tartományt (következő Chapter alatti második sorig): >

	/Chapter/+2

Nevesített tartományokat is offszetelhetünk. Nézzük: >

	:.+3,$-5

A tartomány három sorral a kurzor alatt kezdődik és a fájl vége előtt öt
sorral ér véget. 


JELÖLŐK HASZNÁLATA

Ahelyett, hogy azon töprengenél, hogy hogyan adj meg egy komplex tartományt,
használj jelölőket. Gyorsabb.
   Rakd le a jelölőid a 3. fejezetben leírtak szerint. Például, "mt"
jelöléssel a tartomány tetejét (top), "mb"-vel pedig az alját (bottom). Ezt
így hasznosíthatod (a jelölők sora még a tartományhoz tartozik): >

	:'t,'b


VISUAL MÓD ÉS A TARTOMÁNYOK

Tartományokat Visual módban egyszerűen, könnyen és gyorsan megadhatunk.
Részben erre is való a mód. Jelöljünk ki valamit, hogy nyomjunk egy ":" a
command-line módba lépéshez, melybe azonnal az alábbi érdekességet láthatjuk:
>
	:'<,'>

A működés teljesen normális. Ezek a karakterek a vizuális tartomány elejét és
végét jelentik. A parancsaidat ugyanúgy folytathatod, viszont az összes művelet 
a kijelölt tartományon lesz elvégezve.

	Megjegyzés:
	Visual módban a CTRL-V-vel jelölhetünk ki szövegblokkokat, azonban a
	leírtakkal ellentétben a művelet végrehajtódik minden olyan sor
	egészén, amelynek a blokk megelőzőleg a részét képezte. Ez változhat a
	későbbi Vim verziók során.

A '< és '> nem mások mint jelölők, melyeket a Vim a vizuális kijelölés elejére
és végére helyez. A jelölők addig maradnak érvényben, amíg egy másik Visual
módú kijelöléssel ki nem jelölünk valamit. Ebből az következik, hogy
újrahasznosíthatóak. Azaz, a pozíciójukhoz ugorhatsz "'<" (a ' csak a sor
számát jelöli), de fel is használhatod őket további tartományok definiáláshoz.
>
	:'>,$

Az alábbi címzéssel  a az utolsó vizuális kijelöléstől a fájl végéig tartó
tartományt hozunk létre.


A SOROK SZÁMA

Ha pontosan tudod, hogy mennyi sorban szeretnél dolgozni, az aktív sorhoz
hozzáfűzheted számformátumban:  >

	:.,.+4


A végére pedig jöhet a parancs. Az így képzett művelet az aktív sor "." és az
azt követő négy sor ".+4" (azaz összesen ötre) értendő.

==============================================================================
*10.4*	A global parancs

The ":global" command is one of the more powerful features of Vim.  It allows
you to find a match for a pattern and execute a command there.  The general
form is: >

	:[range]global/{pattern}/{command}

This is similar to the ":substitute" command.  But, instead of replacing the
matched text with other text, the command {command} is executed.

	Note:
	The command executed for ":global" must be one that starts with a
	colon.  Normal mode commands can not be used directly.  The |:normal|
	command can do this for you.

Suppose you want to change "foobar" to "barfoo", but only in C++ style
comments.  These comments start with "//".  Use this command: >

	:g+//+s/foobar/barfoo/g

This starts with ":g".  That is short for ":global", just like ":s" is short
for ":substitute".  Then the pattern, enclosed in plus characters.  Since the
pattern we are looking for contains a slash, this uses the plus character to
separate the pattern.  Next comes the substitute command that changes "foobar"
into "barfoo".
   The default range for the global command is the whole file.  Thus no range
was specified in this example.  This is different from ":substitute", which
works on one line without a range.
   The command isn't perfect, since it also matches lines where "//" appears
halfway through a line, and the substitution will also take place before the
"//".

Just like with ":substitute", any pattern can be used.  When you learn more
complicated patterns later, you can use them here.

==============================================================================
*10.5*	Visual block mode

With CTRL-V you can start selection of a rectangular area of text.  There are
a few commands that do something special with the text block.

There is something special about using the "$" command in Visual block mode.
When the last motion command used was "$", all lines in the Visual selection
will extend until the end of the line, also when the line with the cursor is
shorter.  This remains effective until you use a motion command that moves the
cursor horizontally.  Thus using "j" keeps it, "h" stops it.


INSERTING TEXT

The command  "I{string}<Esc>" inserts the text {string} in each line, just
left of the visual block.  You start by pressing CTRL-V to enter visual block
mode.  Now you move the cursor to define your block.  Next you type I to enter
Insert mode, followed by the text to insert.  As you type, the text appears on
the first line only.
   After you press <Esc> to end the insert, the text will magically be
inserted in the rest of the lines contained in the visual selection.  Example:

	include one ~
	include two ~
	include three ~
	include four ~

Move the cursor to the "o" of "one" and press CTRL-V.  Move it down with "3j"
to "four".  You now have a block selection that spans four lines.  Now type: >

	Imain.<Esc>

The result:

	include main.one ~
	include main.two ~
	include main.three ~
	include main.four ~

If the block spans short lines that do not extend into the block, the text is
not inserted in that line.  For example, make a Visual block selection that
includes the word "long" in the first and last line of this text, and thus has
no text selected in the second line:

	This is a long line ~
	short ~
	Any other long line ~

		  ^^^^ selected block

Now use the command "Ivery <Esc>".  The result is:

	This is a very long line ~
	short ~
	Any other very long line ~

In the short line no text was inserted.

If the string you insert contains a newline, the "I" acts just like a Normal
insert command and affects only the first line of the block.

The "A" command works the same way, except that it appends after the right
side of the block.  And it does insert text in a short line.  Thus you can
make a choice whether you do or don't want to append text to a short line.
   There is one special case for "A": Select a Visual block and then use "$"
to make the block extend to the end of each line.  Using "A" now will append
the text to the end of each line.
   Using the same example from above, and then typing "$A XXX<Esc>, you get
this result:

	This is a long line XXX ~
	short XXX ~
	Any other long line XXX ~

This really requires using the "$" command.  Vim remembers that it was used.
Making the same selection by moving the cursor to the end of the longest line
with other movement commands will not have the same result.


CHANGING TEXT

The Visual block "c" command deletes the block and then throws you into Insert
mode to enable you to type in a string.  The string will be inserted in each
line in the block.
   Starting with the same selection of the "long" words as above, then typing
"c_LONG_<Esc>", you get this:

	This is a _LONG_ line ~
	short ~
	Any other _LONG_ line ~

Just like with "I" the short line is not changed.  Also, you can't enter a
newline in the new text.

The "C" command deletes text from the left edge of the block to the end of
line.  It then puts you in Insert mode so that you can type in a string,
which is added to the end of each line.
   Starting with the same text again, and typing "Cnew text<Esc>" you get:

	This is a new text ~
	short ~
	Any other new text ~

Notice that, even though only the "long" word was selected, the text after it
is deleted as well.  Thus only the location of the left edge of the visual
block really matters.
   Again, short lines that do not reach into the block are excluded.

Other commands that change the characters in the block:

	~	swap case	(a -> A and A -> a)
	U	make uppercase  (a -> A and A -> A)
	u	make lowercase  (a -> a and A -> a)


FILLING WITH A CHARACTER

To fill the whole block with one character, use the "r" command.  Again,
starting with the same example text from above, and then typing "rx":

	This is a xxxx line ~
	short ~
	Any other xxxx line ~


	Note:
	If you want to include characters beyond the end of the line in the
	block, check out the 'virtualedit' feature in chapter 25.


SHIFTING

The command ">" shifts the selected text to the right one shift amount,
inserting whitespace.  The starting point for this shift is the left edge of
the visual block.
   With the same example again, ">" gives this result:

	This is a	  long line ~
	short ~
	Any other	  long line ~

The shift amount is specified with the 'shiftwidth' option.  To change it to
use 4 spaces: >

	:set shiftwidth=4

The "<" command removes one shift amount of whitespace at the left
edge of the block.  This command is limited by the amount of text that is
there; so if there is less than a shift amount of whitespace available, it
removes what it can.


JOINING LINES

The "J" command joins all selected lines together into one line.  Thus it
removes the line breaks.  Actually, the line break, leading white space and
trailing white space is replaced by one space.  Two spaces are used after a
line ending (that can be changed with the 'joinspaces' option).
   Let's use the example that we got so familiar with now.  The result of
using the "J" command:

	This is a long line short Any other long line ~

The "J" command doesn't require a blockwise selection.  It works with "v" and
"V" selection in exactly the same way.

If you don't want the white space to be changed, use the "gJ" command.

==============================================================================
*10.6*	Reading and writing part of a file

When you are writing an e-mail message, you may want to include another file.
This can be done with the ":read {filename}" command.  The text of the file is
put below the cursor line.
   Starting with this text:

	Hi John, ~
	Here is the diff that fixes the bug: ~
	Bye, Pierre. ~

Move the cursor to the second line and type: >

	:read patch

The file named "patch" will be inserted, with this result:

	Hi John, ~
	Here is the diff that fixes the bug: ~
	2c2 ~
	<	for (i = 0; i <= length; ++i) ~
	--- ~
	>	for (i = 0; i < length; ++i) ~
	Bye, Pierre. ~

The ":read" command accepts a range.  The file will be put below the last line
number of this range.  Thus ":$r patch" appends the file "patch" at the end of
the file.
   What if you want to read the file above the first line?  This can be done
with the line number zero.  This line doesn't really exist, you will get an
error message when using it with most commands.  But this command is allowed:
>
	:0read patch

The file "patch" will be put above the first line of the file.


WRITING A RANGE OF LINES

To write a range of lines to a file, the ":write" command can be used.
Without a range it writes the whole file.  With a range only the specified
lines are written: >

	:.,$write tempo

This writes the lines from the cursor until the end of the file into the file
"tempo".  If this file already exists you will get an error message.  Vim
protects you from accidentally overwriting an existing file.  If you know what
you are doing and want to overwrite the file, append !: >

	:.,$write! tempo

CAREFUL: The ! must follow the ":write" command immediately, without white
space.  Otherwise it becomes a filter command, which is explained later in
this chapter.


APPENDING TO A FILE

In the first section of this chapter was explained how to collect a number of
lines into a register.  The same can be done to collect lines in a file.
Write the first line with this command: >

	:.write collection

Now move the cursor to the second line you want to collect, and type this: >

	:.write >>collection

The ">>" tells Vim the "collection" file is not to be written as a new file,
but the line must be appended at the end.   You can repeat this as many times
as you like.

==============================================================================
*10.7*	Formatting text

When you are typing plain text, it's nice if the length of each line is
automatically trimmed to fit in the window.  To make this happen while
inserting text, set the 'textwidth' option: >

	:set textwidth=72

You might remember that in the example vimrc file this command was used for
every text file.  Thus if you are using that vimrc file, you were already
using it.  To check the current value of 'textwidth': >

	:set textwidth

Now lines will be broken to take only up to 72 characters.  But when you
insert text halfway through a line, or when you delete a few words, the lines
will get too long or too short.  Vim doesn't automatically reformat the text.
   To tell Vim to format the current paragraph: >

	gqap

This starts with the "gq" command, which is an operator.  Following is "ap",
the text object that stands for "a paragraph".  A paragraph is separated from
the next paragraph by an empty line.

	Note:
	A blank line, which contains white space, does NOT separate
	paragraphs.  This is hard to notice!

Instead of "ap" you could use any motion or text object.  If your paragraphs
are properly separated, you can use this command to format the whole file: >

	gggqG

"gg" takes you to the first line, "gq" is the format operator and "G" the
motion that jumps to the last line.

In case your paragraphs aren't clearly defined, you can format just the lines
you manually select.  Move the cursor to the first line you want to format.
Start with the command "gqj".  This formats the current line and the one below
it.  If the first line was short, words from the next line will be appended.
If it was too long, words will be moved to the next line.  The cursor moves to
the second line.  Now you can use "." to repeat the command.  Keep doing this
until you are at the end of the text you want to format.

==============================================================================
*10.8*	Changing case

You have text with section headers in lowercase.  You want to make the word
"section" all uppercase.  Do this with the "gU" operator.  Start with the
cursor in the first column: >

			     gUw
<	section header	    ---->      SECTION header

The "gu" operator does exactly the opposite: >

			     guw
<	SECTION header	    ---->      section header

You can also use "g~" to swap case.  All these are operators, thus they work
with any motion command, with text objects and in Visual mode.
   To make an operator work on lines you double it.  The delete operator is
"d", thus to delete a line you use "dd".  Similarly, "gugu" makes a whole line
lowercase.  This can be shortened to "guu".  "gUgU" is shortened to "gUU" and
"g~g~" to "g~~".  Example: >

				g~~
<	Some GIRLS have Fun    ---->   sOME girls HAVE fUN ~

==============================================================================
*10.9*	Using an external program

Vim has a very powerful set of commands, it can do anything.  But there may
still be something that an external command can do better or faster.
   The command "!{motion}{program}" takes a block of text and filters it
through an external program.  In other words, it runs the system command
represented by {program}, giving it the block of text represented by {motion}
as input.  The output of this command then replaces the selected block.
   Because this summarizes badly if you are unfamiliar with UNIX filters, take
a look at an example.  The sort command sorts a file.  If you execute the
following command, the unsorted file input.txt will be sorted and written to
output.txt.  (This works on both UNIX and Microsoft Windows.) >

	sort <input.txt >output.txt

Now do the same thing in Vim.  You want to sort lines 1 through 5 of a file.
You start by putting the cursor on line 1.  Next you execute the following
command: >

	!5G

The "!" tells Vim that you are performing a filter operation.  The Vim editor
expects a motion command to follow, indicating which part of the file to
filter.  The "5G" command tells Vim to go to line 5, so it now knows that it
is to filter lines 1 (the current line) through 5.
   In anticipation of the filtering, the cursor drops to the bottom of the
screen and a ! prompt displays.  You can now type in the name of the filter
program, in this case "sort".  Therefore, your full command is as follows: >

	!5Gsort<Enter>

The result is that the sort program is run on the first 5 lines.  The output
of the program replaces these lines.

	line 55			      line 11
	line 33			      line 22
	line 11		-->	      line 33
	line 22			      line 44
	line 44			      line 55
	last line		      last line

The "!!" command filters the current line through a filter.  In Unix the "date"
command prints the current time and date.  "!!date<Enter>" replaces the current
line with the output of "date".  This is useful to add a timestamp to a file.


WHEN IT DOESN'T WORK

Starting a shell, sending it text and capturing the output requires that Vim
knows how the shell works exactly.  When you have problems with filtering,
check the values of these options:

	'shell'		specifies the program that Vim uses to execute
			external programs.
	'shellcmdflag'	argument to pass a command to the shell
	'shellquote'	quote to be used around the command
	'shellxquote'	quote to be used around the command and redirection
	'shelltype'	kind of shell (only for the Amiga)
	'shellslash'	use forward slashes in the command (only for
			MS-Windows and alikes)
	'shellredir'	string used to write the command output into a file

On Unix this is hardly ever a problem, because there are two kinds of shells:
"sh" like and "csh" like.  Vim checks the 'shell' option and sets related
options automatically, depending on whether it sees "csh" somewhere in
'shell'.
   On MS-Windows, however, there are many different shells and you might have
to tune the options to make filtering work.  Check the help for the options
for more information.


READING COMMAND OUTPUT

To read the contents of the current directory into the file, use this:

on Unix: >
	:read !ls
on MS-Windows: >
	:read !dir

The output of the "ls" or "dir" command is captured and inserted in the text,
below the cursor.  This is similar to reading a file, except that the "!" is
used to tell Vim that a command follows.
   The command may have arguments.  And a range can be used to tell where Vim
should put the lines: >

	:0read !date -u

This inserts the current time and date in UTC format at the top of the file.
(Well, if you have a date command that accepts the "-u" argument.)  Note the
difference with using "!!date": that replaced a line, while ":read !date" will
insert a line.


WRITING TEXT TO A COMMAND

The Unix command "wc" counts words.  To count the words in the current file: >

	:write !wc

This is the same write command as before, but instead of a file name the "!"
character is used and the name of an external command.  The written text will
be passed to the specified command as its standard input.  The output could
look like this:

       4      47     249 ~

The "wc" command isn't verbose.  This means you have 4 lines, 47 words and 249
characters.

Watch out for this mistake: >

	:write! wc

This will write the file "wc" in the current directory, with force.  White
space is important here!


REDRAWING THE SCREEN

If the external command produced an error message, the display may have been
messed up.  Vim is very efficient and only redraws those parts of the screen
that it knows need redrawing.  But it can't know about what another program
has written.  To tell Vim to redraw the screen: >

	CTRL-L

==============================================================================

Next chapter: |usr_11.txt|  Recovering from a crash

Copyright: see |manual-copyright|  vim:tw=78:ts=8:noet:ft=help:norl:
