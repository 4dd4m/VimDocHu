*usr_41.txt*	For Vim version 8.2.	Last change: 2021 Aug 08

		  Bram Moolenaar: Vim felhasználói kézikönyv

				Vim szkriptek


A Vim szkriptnyelv a vimrc fájl leírónyelve és még sok egyéb másé. A fejezet
elmagyarázza, hogy milyen elemeket használhatunk Vim szkriptben. Elég sokat,
ezért a fejzet hosszú

|41.1|	Bevezetés
|41.2|	Változók
|41.3|	Kifejezések
|41.4|	Feltételek
|41.5|	Kifejezések futtatása
|41.6|	Függvények használata
|41.7|	Függvények definiálása
|41.8|	Listák és szótárak
|41.9|	Kivételek
|41.10|	Egyéb megjegyzések
|41.11|	Beépülő írása
|41.12|	FileType beépülő írása
|41.13|	Fordító beépülő írása
|41.14|	A gyors beépülő ismérvei
|41.15|	Szkript könyvtárak írása
|41.16|	VimSzkriptek közzététele

Következő fejezet: |usr_42.txt|  Új menük hozzáadása
    Előző fejezet: |usr_40.txt|  Új parancsok készítése
  Tartalomjegyzék: |usr_toc.txt|

==============================================================================
*41.1*	Bevezetés				*vim-script-intro* *script*

A Vim szkriptel való első találkozásod a vimrc fájl. Induláskor a szerkesztő
olvassa a fájl tartalmát. Olyan opciókat állíthatsz be, amilyeneket szeretnél.
Bármilyen ":" parancsot használhatsz, ezekre Ex parancsok, vagy command-line
parancsok néven hivatkozhatunk.
   A szintaxis kiemelés fájljai szintén Vim szkriptek, melyek csak
meghatározott opciókat állítanak be adott fájltípus esetén.  Egy bonyolult
makróra tekinthetünk úgy, mint egy különálló Vim szkript fájlt.

	Ha van tapasztalatod a Pzthonnal, akkor itt találhatsz egy rövid
	összehasonlítást, pointerekkel és egyéb dokumentumokkal.
	   https://gist.github.com/yegappan/16d964a37ead0979b05e655aa036cad0
	Ha a jJavaScriptben vagy járatos.:
	   https://w0rp.com/blog/post/vim-script-for-the-javascripter/

Kezdjük egy egyszerű példával: >

	:let i = 1
	:while i < 5
	:  echo "count is" i
	:  let i += 1
	:endwhile
<
	Megjegyzés:
	A ":" karakterre itt nincs igazán szükség. Csak akkor kötelező
	használni, ha command-lineban dolgozunk. A Vim szkriptekben
	kihagyhatjuk őket, használatukkal csak indikálni szeretnénk, hogy ezek
	":" parancsok (a Normal módtól való elkülöníthetőség végett).
	Megjegyzés:
	A példákat úgy futtathatjuk, hogy másoljuk forráskódot (y), majd kiadjuk a :@"
	parancsot.

A példa kimenete:

	count is 1 ~
	count is 2 ~
	count is 3 ~
	count is 4 ~

Az első sorban található :let" paranccsal adunk értéket a változónak.
Általános formája: >

	:let {variable} = {expression}

A példában a változó neve "i" a kifejezés pedig egy szimpla érték: 1.
   A ":while" parancs elkezdi a ciklust. Általános alakja: >

	:while {condition}
	:  {statements}
	:endwhile

A kódblokk a ciklust végét jelző ":endwhile" parancsig tart, a köztes
kódrészlet pedig addig fut, amíg a feltétel (condition) igaz. Az alkalmazott
feltétel: "i < 5", mely igaz, ha i kisebb, mint öt.
	Megjegyzés:
	Ha véletlenül végtelen ciklust írunk, akkor a CTRL-C billentyűvel
	(CTRL-Break Ms-Windows) szakíthatjuk meg.

Az ":echo" parancs kiírja az argumentumait. Ebben az esetben a stringet "count
is" és az i változó értékét. Mivel i értéke egy, ezért a kimenet:

	count is 1 ~

aj következik a ":let 1 += 1" parancs, mely ebben az alakban is szabályos:
":let i = i + 1". A kifejezés i változó értékét megnöveli eggyel.
Megjegyzés: Ebben a fájlban a régi Vim szkriptet tárgyaljuk, mely nem
összetévesztendő a Vim9 szkripttel, ami sokkal másabb, lásd: |usr_46.txt|.

A fenti példában lévő ciklus csak szemléltetés volt. Azonban minek írnánk
ilyen szintaktikával egy ciklust, ha ezt kompaktabban is megtehetjük:

	:for i in range(1, 4)
	:  echo "count is" i
	:endfor

Most nem térünk ki a |:for| és |range()| működési elveire. Kövesd a linkeket,
ha türelmetlen vagy.


NÉGYFÉLE SZÁM

A számok lehetnek decimálisak, hexadecimálisak, oktálisak és binárisak.

A hexadecimális számok "0x", vagy "0X"-el kezdődne. Például "0x1f" a
decimálist 31 megfelelője.

Az oktális számok "0o", "0O" vagy nullával és egy másik számmal kezdődhetnek.
"0o17" decimális számrendszerben 15. A csak 0 prefixum használata nem
megengedett a Vim9 szkriptben.

A bináris számok kezdete "0b" vagy "0B". Például "0b101", ami decimális
számrendszerben 5.

A decimális számok csak szám karakterekből állnak. Óvatosan: ne tegyünk
vezető nullát a szám elé, különben a Vimszkript oktális számnak fogja
tekinteni!

Az ":echo" parancs mindig decimális számokat ír ki. Például:   >

	:echo 0x7f 0o36
<	127 30 ~

A negatív előjellel ellátott számok negatív számként értelmeződnek, mely az
összes többi szám esetében is igaz. A negatív előjelet ezen túl kivonáshoz is
használjuk.  Összehasonlítva ezt az előző példával: >

	:echo 0x7f -0o36
<	97 ~

A szóközök a kifejezésekben nem számítanak. Bár, javasolt a használatuk
olvashatósági okok miatt. Például, hogy a fenti példában lévő nehogy
összetévesszük, tegyünk szóközt a kötőjel és a szám közé: >

	:echo 0x7f - 0o36

==============================================================================
*41.2*	Változók

A változónevek ASCII karakterekből, számokból és "_" jelből állhat. Nem
kezdődhet számmal. Érvényes változónevek:

	counter
	_aap3
	very_long_variable_name_with_underscores
	FuncLength
	LENGTH

Érvénytelen nevek: "foo+bar" and "6var".
   Ezek a változók globálisak. Az eddig definiált változókat listázhatod: >

	:let

A globális változókat bárhol használhatjuk. Ez azt jelent, hogy az általunk
használt "count" változót nem csak saját fájlja, hanem más szrkiptfájlok is
használhatják, mely zavart okozhat és előbb utóbb problémát természetesen.
Ennek elkerülésére a változót lokálissá tehetjük az "s:" prefixummal. Például,
a szkriptünk ezt tartalmazza: >

	:let s:count = 1
	:while s:count < 5
	:  source other.vim
	:  let s:count += 1
	:endwhile

Mivel "s:count" lokális a szkriptben, biztosak lehetünk benne, hogy
"other.vim" szkriptfájl betöltése nem fogja megváltoztatni az értékét. Ha
"other.vim" szkriptben is van egy "s:count" jellegű változó, az sem okoz
problémát, mert mindegyik lokális az adott szkriptjéhez. Még több a lokális
változókról itt: |script-variable|.
Ennél ayonban több változótípus létezik:  |internal-variables|. A
leggyakrabban használt típusok (névtér szerint):

	b:name		csak a buffer számára érehető el
	w:name		csak az ablak számára érehető el
	g:name		globális változó (függvényekben is)
	v:name		a Vim által definiált változók


VÁLTOZÓ TÖRLÉSE

A változók a memóriában tárolódnak a ":let" parancs által. Változó törléséhez
használjuk az ":unlet" parancsot. Például:  >

	:unlet s:count

Ez törli a szkript lokális "s:count" változóját, helyet szabadítva fel a
memóriában. Ha nem vagyunk benne biztosak, hogy egy adott változó létezik, és
például nem szeretnénk hibaüzenetet kapna, ha mégsem létezne, akkor használjuk
a "!" jelet:j >

	:unlet! s:count

Ha a szkript lefutott, a lokális változó automatikusan nem szabdul fel. A
szkrip követkző futásakor is használható lesz a régi értékével. Például: >

	:if !exists("s:call_count")
	:  let s:call_count = 0
	:endif
	:let s:call_count = s:call_count + 1
	:echo "called" s:call_count "times"

Az exist() függvény ellenőrzi, hogy a változó definiálva van-e. Argumentumként
a változó nevét fogadja, tehát nem magát a változót! Ha így hívnánk: >

	:if !exists(s:call_count)

Akkor az s:call_count változót használná az ellenőrzése és nem a nevét. Ez nem
az, amit szeretnénk.
   A "!" jel negációt jelenti. Ha az érték igaz, akkor hamisra vált. Ha hamis,
akkor pedig igazra. A kifejezést "nem"-ként olvashtajuk, ezért "if !exists()"
így mondjuk: "ha nem létezik()".
   Amit a Vim igaznak hív az gyakorlatilag minden, ami nem nulla. A nulla
(Zero) természetesen hamis.
	Megjegyzés:
	A Vim automatikusan konvertája a stringeket számmá, ha erre van
	szüksége. Ha olyan stringet használunk, amely nem számmal kezdődik, az
	mindig nulla lesz. Ezért vizsgáljuk meg az alábbit: >

		:if "true"

<	A "true" zéróként interpretálódik (nem számmal kezdődik), ezért hamis
	lesz az értéke.


STRING VÁLTOZÓK ÉS KONSTANSOK

Eddig a változókhoz csak számokat rendeltünk. Stringeket is használhatunk. A
számok és  stringek az alaptípusok, melyeket a Vim támogat. A típusadás
dinamikus, mely a ":let"-el való értékadáskor következik be. A típusokról
bővebben a |41.8| fejezetben.
   Egy változó típusa akkor lehet string, ha stringet rendelünk hozzá, melyet
kétféleképpen végezhetünk el: a stringet dupla idézőjelek közé tesszük: >

	:let name = "peter"
	:echo name
<	peter ~

Ha a stringben idézőjeleket szeretnénk használni, akkor a belső idézőjeleket \
karakterrel escapelnünk kell (enélkül a Vim nem tudja eldönteni, hogy hol ér
véget a változó): >

	:let name = "\"peter\""
	:echo name
<	"peter" ~

Hogy ne kelljen állandóan escapelnünk, a külső idézőjeleket aposztrófra
cserélhetjük: >

	:let name = '"peter"'
	:echo name
<	"peter" ~


Az aposztrófos 'stringekben ' minden karakter reprezentálódik. Csak és kizárólag
az aposztróf speciális: kettőt kell használjunk '', hogy egy megjelenjen. A \ szó
szerint értelmeződik (karakterként), azért escapelésre nem használható.
   Az "idézőjeles" stringekben a speciális karakterek használata megengedett,
néhány hasznos belőlük:

	\t		<Tab>
	\n		<NL>, sortörés
	\r		<CR>, <Enter>
	\e		<Esc>
	\b		<BS>, backspace
	\"		"
	\\		\, backslash
	\<Esc>		<Esc>
	\<C-W>		CTRL-W

Az utolsó kettő csak példa. A "\<name>" formátumot használjuk a "name"
billentyű reprezentálására.
   Lásd |expr-quote| a stringekben használható speciális karakterek teljes
listája.

==============================================================================
*41.3*	Kifejezések

A vim gazdag de mégis egyszerű módon kezeli a kifejezéseket. A definíciót itt
elolvashatod: |expressions-syntax|. Itt bemutatjuk a leggyakoribb elemeket.
    A számok, stringek és változók melyeket fent láthattunk, már önmagukban is
kifejezések. Ezért bárhol, ahol kifejezés az elvárt érték, használhatod őket.
Alapvető kifejezések továbbá:

	$NAME		Környezeti változó
	&name		opció
	@r		regiszter

Példa: >

	:echo "The value of 'tabstop' is" &ts
	:echo "Your home directory is" $HOME
	:if @a > 5

A &name alakot az opció értékének tárolására használjuk, új értéket adunk
neki, csinálunk valamit és visszaállítjuk a régi értékére. Például: >

	:let save_ic = &ic
	:set noic
	:/The Start/,$delete
	:let &ic = save_ic

Így biztosak lehetünk benne, hogy a "The Start" minta használatakor az 'ignorecase' opció ki lesz kapcsolva.
Ráadásul még meg is tartja a régi értékét, amit a felhasználó beállított. (Egy
másik módja ennek a "\C" hozzáadása lett volna a mintához, lásd |/\C|.)


MATEMATIKA

Még érdekesebbé válik, ha az alapelemeket elkezdjük kombinálni. Kezdjük a
számokon végzett matematikai műveletekkel:

	a + b		add
	a - b		subtract
	a * b		multiply
	a / b		divide
	a % b		modulo

A műveleti sorrend a szokásos. Például:   >

	:echo 10 + 5 * 2
<	20 ~

A műveletek csoportosíthatóak zárójelekkel. Semmi extra. Például:   >

	:echo (10 + 5) * 2
<	30 ~

A stringeket konkatenálhatjuk az ".." operátorral (lásd |expr6|). Például:   >

	:echo "foo" .. "bar"
<	foobar ~

Ha az ":echo parancs több argumentumot kap, akkor elválasztja őket szóközzel.
A példában az argumentum egy egyszerű kifejezés, ezért nincs szóköz közötte.

A C nyelvből kölcsönözve a feltételes kifejezés: >

	a ? b : c

Ha "a" igazra értékelődik ki, akkor "b"-t használjuk, egyébként pedig "c"-t.
Például:   >

	:let i = 4
	:echo i > 5 ? "i is big" : "i is small"
<	i is small ~

A három kifejezés először mindig kiértékelődik, ezért így is ábrázolhatnánk:

	(a) ? (b) : (c)

==============================================================================
*41.4*	Feltételek

Az ":if" parancs lefuttatja a kódblokkot az ":endif"-ig, de csak akkor, ha a
feltétel teljesül. Az általános alakja:

	:if {condition}
	   {statements}
	:endif

Csak ha {condition} kifejezés igazzá értékelődik ki (nem nulla), akkor a
{statement} rész lefut, melyeknek maguknak is érvényes kifejezéseknek kell
lenniük, különben. Ha szemetet tartalmaznak, akkor a Vim nem fogja megtalálni
az ":endif" parancsot.
   Használhatunk ":else"-t is. Általános alakja:

	:if {condition}
	   {statements}
	:else
	   {statements}
	:endif

A második {statements} csak akkor fut le, ha az első nem.
   Végül pedig az ":elseif":

	:if {condition}
	   {statements}
	:elseif {condition}
	   {statements}
	:endif

Működése tökéletesen megegyezik az ":else" és "if" használatával, de anélkül,
hogy egy extra ":endif"-et feltüntetnénk. >

	:if &term == "xterm"
	:  " Do stuff for xterm
	:elseif &term == "vt100"
	:  " Do stuff for a vt100 terminal
	:else
	:  " Do something for other terminals
	:endif


LOGIKAI OPERÁTOROK

Némelyiket már használtuk. Itt vannak a leggyakoribbak:

	a == b		egyenlő
	a != b		nem egyenlő
	a >  b		nagyobb, mint
	a >= b		nagyobb, vagy egyenlő, mint
	a <  b		kisebb, mint
	a <= b		kisebb, vagy egyenlő, mint

A végeredmény 1, ha a feltétel teljesül, és 0, ha nem. Például:   >

	:if v:version >= 700
	:  echo "congratulations"
	:else
	:  echo "you are using an old version, upgrade!"
	:endif

Itt a "v:version" változót a Vim definiálta, melynek tartalma a Vim verziója.
600 a 6.0-ás verzióhoz. A 6.1 verzió 601 lenne. Így verzió specifikus
szkripteket tudunk létrehozni |v:version|.

A logikai operátorok számok és stringek esetén is működik. Ha két stringet
hasonlítunk össze, akkor a matematikai különbséget kapjuk. Az eredmény a
bájtok összehasonlításával keletkezik, így nyelvek és nyelvek között a kimenet
eltérhet.
   Ha stringet hasonlítunk számhoz, akkor a string először számmá
konvertálódik. Ez trükkös, hiszen ha string nem számnak néz ki, akkor a
konvertálás eredménye nulla. Például:   >

	:if 0 == "one"
	:  echo "yes"
	:endif

A kód kimenete "yes", mert "one" nem néz ki számnak (az első karaktere nem
szám), ezért nullává konvertálódik.

Stringek összehasonlítására a további két operátor áll rendelkezésre:

	a =~ b		egyezik
	a !~ b		nem egyezik

A bal oldali "a"-t stringként használjuk. A jobb oldalon szereplő "b"
mintaként van használva, mintha keresnénk. Például:   >

	:if str =~ " "
	:  echo "str contains a space"
	:endif
	:if str !~ '\.$'
	:  echo "str does not end in a full stop"
	:endif

Figyeljünk arra, hogy a keresési mintát aposztrófok közé zártuk, így nem kell
escapelnünk \ karakterrel (amit idézőjelek esetén meg kellett volna tenni).

Az 'ignorecase' opció hatással van a stringek összehasonlítására. Ha ezt nem
szeretnénk, akkor fűzzük a "#" karaktert (betűérzékeny), vagy a "?" karaktert
(nem betűérzékeny) az operátorhoz. Ezért "==?" két stringet hasonlít össze a
betűérzékenységet figyelmen kívül hagyva. "!~#" megvizsgálja, hogy a két
string egyenlő-e a betűérzékenység figyelembevételével. A teljes táblázathoz
lásd |expr-==|.


MÉG TÖBB CIKLUS

A ":while" ciklust már említettük. Két parancsot használhatunk a ciklusban (a
":while" és ":endwhile" között):

	:continue		Visszaugrik a while ciklus kezdetéhez és
				folytatja azt
	:break			a vezérlés az ":endwhile"-ra ugrik, a ciklus
				megszakad

Például:  >

	:while counter < 40
	:  call do_something()
	:  if skip_flag
	:    continue
	:  endif
	:  if finished_flag
	:    break
	:  endif
	:  sleep 50m
	:endwhile

A ":sleep" paranccsal a szkript futtatását függeszthetjük fel. Az "50m" ötven
milliszekondumot jelent. Másik példa a ":sleep 4", mely négy másodpercig tart.

A ":for" ciklushoz lásd |41.8|.

==============================================================================
*41.5*	Kifejezés futtatása

Eddig a parancsokat a Vimben adtuk ki. Az ":execute" paranccsal lefuttathatjuk
a kifejezés értékét, mellyel bonyolult parancsokat is írhatunk.
   Például ugrás taghez, melyet a változó tartalmaz: >

	:execute "tag " .. tag_name

A ".." operátorral fűztük össze a "tag " stringet a "tag_name" változóval.
Feltételezzük, hogy a "tag_name" értéke "get_cmd", mely kiértékelés után: >

	:tag get_cmd

Az ":execute" parancs csak ":" futtatására alkalmas. A ":normal" parancs a
Normal módú parancsokat tudja futtatni. Bár az argumentum nem egy kifejezés
értéke, stringként adjuk át a ":normal" parancsnak. Például:   >

	:normal gg=G

A parancs az első sorra ugrik és formázza az összes sort a "=" operátorral.
   ":normal" módban úgy dolgozhatunk kifejezéssel, hogy átadjuk az ":execute"
parancsnak. Például:   >

	:execute "normal " .. normal_commands

A "normal_commands" változónak normál módú parancsokat kell tartalmaznia.
   Győződjünk meg arról, hogy a ":normal" parancsnak átadott argumentum teljes
értékű parancs. Például, ha Insert módba lépünk, akkor ki is kell lépnünk
belőle. Így működik: >

	:execute "normal Inew text \<Esc>"

Futtatás beilleszti a "new text" szöveget az aktív sorba. Figyeljük meg a
speciális billentyűk használatát: a "\<Esc>" a normál módba küldi a
billentyűleütést, és közvetlenül a szkriptnek (<Esc> a szkriptben azonnal
értelmeződne).

Ha nem szeretnénk egy stringet futtatni, csak kiértékelni a kifejezés értékét,
akkor az eval() függvényt használhatjuk: >

	:let optname = "path"
	:let optval = eval('&' .. optname)

A "&" karaktert a "path" elé fűztük, ezért az eval() függvény argumentumként a
"&path"-t kapja. Az eredmény pedig a 'path' opció értéke lesz.
   Ezzel egyenértékű: >

	:exe 'let optval = &' .. optname

==============================================================================
*41.6*	Függvények használata

A Vim a beépített függvényei révén hatalmas funkcionalitást biztosít. Néhány
példán keresztül ezt bemutatjuk. A teljes függvénylista: |functions|.

Függvényeket a ":call" paranccsal hívhatunk. A paramétereket a zárójelek
között kell átadnunk vesszővel elválasztva. Például:   >

	:call search("Date: ", "W")

Ez meghívja a search() függvényt a "Date: " és a "W" argumentumokkal. A search
függvény első paramétere a keresési minta, a második pedig a flag. A "W" flag
azt jelenti, hogy a keresés nem folytatódik a fájl végéhez érve.

A függvényeket kifejezésekben is meghívhatjuk. Például:   >

	:let line = getline(".")
	:let repl = substitute(line, '\a', "*", "g")
	:call setline(".", repl)

A getline() függvény a buffer egy sorával tér vissza. Argumentumként a sor
számát várja. A példában "."-t használtunk, mely a kurzor sorára utal.
   A substitute() függvény a ":substitute" parancs megfelelője. Az első
argumentum a string, melyen a műveletet végezzük, második a minta, a harmadik
pedig a csere string. Végül utolsó argumentumként pedig a flag.
   A setline() függvény felülírja az első argumentumban hivatkozott sort a
második argumentumban szereplő értékkel. A példában a kurzor sorát cseréljük
le a substitute() függvény eredményével. A három kifejezés egyenlő: >

	:substitute/\a/*/g

A függvények használata akkor válik érdekesebbé, ha a substitute() hívás előtt
és után több munkát kell végeznünk.


FÜGGVÉNYEK						*function-list*

Rengeted függvény létezik. Használati jellegük alapján csoportosítottuk a
listát. A betűrendi lista itt található: |functions|. CTRL-] a függvény nevén
megnyitja a részletes leírást.

String manipuláció:					*string-functions*
	nr2char()		karaktert ad vissza számérték alapján
	list2str()		stringet ad listában szereplő számok alapján
	char2nr()		számot ad vissza karakterből
	str2list()		stringből szám alapú listát generál
	str2nr()		stringből Számot konvertál
	str2float()		stgringből Floatot konvertál
	printf()		szöveg formázása a % elemek szerint
	escape()		karakterek escapelése a stringben '\'-el
	shellescape()		string escapelése shell parancs számára
	fnameescape()		fájlnév escapelése Vim parancs számára
	tr()			másolás karakterszettek között
	strtrans()		string nyomtathatóvá alakítása
	tolower()		string kisbetűssé alakítása
	toupper()		string nagybetűssé alakítása
	charclass()		karakter osztálya
	match()			egyezés pozíciója
	matchend()		egyezés végének a pozíciója
	matchfuzzy()		fuzzy stílusú egyezés a stringben
	matchfuzzypos()		fuzzy stílusú egyezés a stringben
	matchstr()		egyező minta értéke a stringben
	matchstrpos()		egyezés a stringben és azok pozíciója
	matchlist()		mint a  matchstr() rész egyezések is
	stridx()		first index of a short string in a long string
	strridx()		last index of a short string in a long string
	strlen()		length of a string in bytes
	strcharlen()		length of a string in characters
	strchars()		karakterek száma a stringben
	strwidth()		megjelenített string hossza
	strdisplaywidth()	megjelenített string hossza, tabokkal
	setcellwidths()		karakter-cella beállítása, felülírással
	substitute()		string helyettesítés mintával
	submatch()		rész egyezések ":s" és substitute()
	strpart()		string része (byte index alapján)
	strcharpart()		string része (char index alapján)
	slice()			string szelet (char index alapján) Vim9
	strgetchar()		string szelet (char index)
	expand()		speciális kulcsszavak kibontása
	expandcmd()		parancsok kibontása (mint az `:edit`)
	iconv()			kódolások közötti konvertálás
	byteidx()		string karakterének byte indexe
	byteidxcomp()		mint a  byteidx() alkotó karakter számít
	charidx()		byte karakterindexe stringben
	repeat()		string ismétlés
	eval()			string kifejezés kiértékelése
	execute()		Ex parancs futtatása
	win_execute()		mint az execute() de meghatározott ablakban
	trim()			karakterek trimmelése stringből
	gettext()		üzenet fordításának keresése

Lista manipuláció:					*list-functions*
	get()			érték listából hibaüzenet nélkül (index)
	len()			listaelemek száma
	empty()			üres-e a lista
	insert()		elem beszúrása
	add()			elem hozzáfűzése
	extend()		listát listához fűz
	extendnew()		új lista, majd hozzáfűz
	remove()		egy vagy több elem eltávolítása
	copy()			shallow másolat
	deepcopy()		lista teljes másolata
	filter()		kiválasztott elemek eltávolítása
	map()			minden listaelem változtatása
	mapnew()		új lista a változott értékekkel
	reduce()		lista redukálása értékhez
	slice()			lista-szelet
	sort()			list rendezése
	reverse()		fordított sorrend
	uniq()			egyedi listaelemek
	split()			string bontása listába
	join()			listaelemek összefűzése stringgé
	range()			számsorozatból lista összeállítás
	string()		lista string reprezentációja
	call()			függvényhívás lista argumentumokkal
	index()			elem indexe a listában
	max()			lista maximum értéke
	min()			lista minimum értéke
	count()			elem gyakorisága listában
	repeat()		lista ismétlése
	flatten()		lista dimenziójának redukálása
	flattennew()		lista dimenziójának redukálása másolással

Szótár manipuláció:				*dict-functions*
	get()			bejegyzés lekérése hiba nélkül (key)
	len()			bejegyzések száma
	has_key()		kulcs ellenőrzés
	empty()			üres-e
	remove()		bejegyzés eltávolítása
	extend()		hozzáadás szótárból szótárba
	extendnew()		hozzáadás szótárból szótárba, összefűzéssel
	filter()		kiválasztott elemek eltávolítása
	map()			minden bejegyzés megváltoztatása
	mapnew()		változtatott elemekből új lista
	keys()			kulcsot listája
	values()		értékek listája
	items()			kulcs-érték párokból lista
	copy()			shallow másolat
	deepcopy()		teljes másolat
	string()		szótár string reprezentációja
	max()			szótár maximum értéke
	min()			szótár minimum értéke
	count()			elem gyakorisága

Lebegőpontos számítások:			*float-functions*
	float2nr()		float számmá
	abs()			abszolút érték (Számokkal is)
	round()			kerekítés
	ceil()			kerekítés fel
	floor()			kerekítés le
	trunc()			tizedes utáni értékek eltávolítása
	fmod()			maradék
	exp()			exponenciális
	log()			természetes logaritmus (e alapú)
	log10()			10 alapú logaritmus
	pow()			négyzetre emelés
	sqrt()			négyzetgyök
	sin()			szinusz
	cos()			koszinusz
	tan()			tangens
	asin()			arc szinusz
	acos()			arc koszinusz
	atan()			arc tangens
	atan2()			arc tangens
	sinh()			hyperbolic szinusz
	cosh()			hyperbolic koszinusz
	tanh()			hyperbolic tangens
	isinf()			végtelen ellenőrzése
	isnan()			nem szám?

Egyéb számítások:				*bitwise-function*
	and()			bitenkénti ÉS
	invert()		bitenkénti inverz
	or()			bitenkénti VAGY
	xor()			bitenkénti KIZÁRÓ VAGY
	sha256()		SHA-256 hash
	rand()			pseudo-random szám
	srand()			kezdeti seed, rand()

Változók:					*var-functions*
	type()			változó típusa számként
	typename()		változó típusa szövegként
	islocked()		változó locked állapotának ellenőrzése
	funcref()		függvényhivatkozás referencia alapján
	function()		függvényhivatkozás név lapján
	setbufvar()		buffer változójának lekérése
	getwinvar()		ablak  változójának lekérése
	gettabvar()		fül    változójának lekérése
	gettabwinvar()		ablak és fül változójának lekérése
	setwinvar()		ablak változójának beállítása
	settabvar()		fül változójának beállítása
	settabwinvar()		ablak és fül változójának beállítása
	garbagecollect()	elérhető szabad memória

Kurzor és mark pozíciók:			*cursor-functions* *mark-functions*
	col()			kurzor vagy mark oszlopa
	virtcol()		kurzor vagy mark virtuális sora
	line()			kurzor vagy mark sora
	wincol()		kurzor vagy mark oszlopa ablakban
	winline()		kurzor vagy mark sora ablakban
	cursor()		kurzor pozíciója sora és oszlopa
	screencol()		kurzor oszlopa a képernyőn
	screenrow()		kurzor sora a képernyőn
	screenpos()		szöveg pozíciója sor és oszlop képernyő
	getcurpos()		kurzor pozíciója
	getpos()		kurzor, mark pozíciója
	setpos()		kurzor, mark pozíciójának beállítása
	getmarklist()		globális és lokális markok
	byte2line()		byte érték sora
	line2byte()		sor byte értéke
	diff_filler()		sor fölött lévő kitöltősorok száma
	screenattr()		képernyő sorának tulajdonságai
	screenchar()		karakter kódja sor-oszlop alapján képernyő
	screenchars()		mint screenchar(), listát ad vissza
	screenstring()		mint screenchars(), stringet ad vissza
	charcol()		mint col(), karaktert ad vissza
	getcharpos()		mint getpos(), karakter indexet ad vissza
	setcharpos()		set character position of cursor, mark, etc.
	getcursorcharpos()	mint setpos(), oszlopszámmal
	setcursorcharpos()	mint cursor(), oszlopszámot használ

Munka az aktív bufferben lévő szöveggel:	*text-functions*
	getline()		sor, vagy sorok listája a bufferből
	setline()		buffer sorának cseréje
	append()		sor, vagy sorok hozzáfűzése
	indent()		behúzás
	cindent()		C stílusú behúzás
	lispindent()		Lisp stílusú behúzás
	nextnonblank()		következő nem üres sor
	prevnonblank()		előző nem üres sor
	search()		minta egyezése
	searchpos()		minta egyezésének helye
	searchcount()		egyezések száma a kurzor előtt és után
	searchpair()		másik vég, kezdet
	searchpairpos()		másik vég, kezdet
	searchdecl()		név deklarációjának keresése
	getcharsearch()		karakter keresési információi
	setcharsearch()		karakter keresési info. beállítása

Munka egy másik bufferben lévő szöveggel:
	getbufline()		buffer sorának lekérése
	setbufline()		buffer sorának cseréje
	appendbufline()		sorok hozzáfűzése a bufferhez
	deletebufline()		buffer sorainak törlése

					*system-functions* *file-functions*
Rendszerfüggvények, manipuláció fájlokkal:
	glob()			fájl metakarakterek kibontása
	globpath()		mint glob(), a 'path' könyvtárait
	glob2regpat()		glob minta konvertálása keresési mintává
	findfile()		fájlkeresés
	finddir()		könyvtárkeresés
	resolve()		parancsikon, linkek feloldása
	fnamemodify()		fájl átnevezés
	pathshorten()		könyvtárnevek rövidítése a path ban
	simplify()		elérési utak egyszerűsítése
	executable()		futtatható állomány ellenőrzése
	exepath()		futtatható program teljes elérési útja
	filereadable()		ellenőrzés: fájl olvasható
	filewritable()		ellenőrzés: fájl írható
	getfperm()		fájl engedélyek
	setfperm()		fájl engedélyek beállítása
	getftype()		fájltípus lekérés
	isdirectory()		ellenőrzés: létező könyvtár
	getfsize()		fájlméret
	getcwd()		munkakönyvtár
	haslocaldir()		ellenőrzés: ablak |:lcd| vagy |:tcd|
	tempname()		ideiglenes fájl neve
	mkdir()			új könyvtár
	chdir()			könyvtárváltás
	delete()		fájl törlése
	rename()		fájl átnevezése
	system()		shell parancs kimenete stringként
	systemlist()		shell parancs kimenete listaként
	environ()		összes környezeti változó
	getenv()		egy környezeti változó
	setenv()		környezeti változó értékének beállítása
	hostname()		gép neve
	readfile()		fájl olvasása listába
	readblob()		olvasás Blobként
	readdir()		könyvtárban lévő fájlok nevei listába
	readdirex()		könyvtárban lévő fájlok információi listába
	writefile()		lista sorai vagy Blob fájlba

Dátum és Idő:				*date-functions* *time-functions*
	getftime()		utolsó módosítás dátuma
	localtime()		időbélyeg másodpercben
	strftime()		idő stringgé konvertálása
	strptime()		dátum/idő string konvertálás időbélyeggé
	reltime()		pontos idő, vagy eltelt idő
	reltimestr()		reltime() konvertálása,  string
	reltimefloat()		reltime() konvertálása,  Float

			*buffer-functions* *window-functions* *arg-functions*
Bufferek, ablakok és az argumentum lista:
	argc()			argumentumlista elemeinek száma
	argidx()		argumentumlista pozíciója
	arglistid()		argumentumlista azonosítója
	argv()			argumentumlista egy eleme
	bufadd()		fájl hozzáadása a bufferek listájához
	bufexists()		ellenőrzés: buffer létezik
	buflisted()		ellenőrzés: buffer létezik és listázott
	bufload()		a buffer betöltött
	bufloaded()		ellenőrzés: buffer létezik és betöltött
	bufname()		buffer neve
	bufnr()			buffer száma
	tabpagebuflist()	bufferek listája fülről
	tabpagenr()		fülek száma
	tabpagewinnr()		mint winnr() meghat. fülön
	winnr()			aktív ablak neve
	bufwinid()		ablak ID-je buffer alapján
	bufwinnr()		ablak száma bufferből
	winbufnr()		buffer száma ablakból
	listener_add()		callback a változásokhoz
	listener_flush()	callback hívása
	listener_remove()	callback eltávolítása
	win_findbuf()		buffert tartalmazó ablak keresése
	win_getid()		ablak ID lekérés
	win_gettype()		ablak típusa
	win_gotoid()		váltás ablakra ID alapján
	win_id2tabwin()		fül és ablakszám ablak ID alapján
	win_id2win()		ablakszám ablak ID alapján
	win_splitmove()		ablak mozgatása másik ablakba (split)
	getbufinfo()		buffer információi | lista
	gettabinfo()		fül információi | lista
	getwininfo()		ablak információi | lista
	getchangelist()		változások listája | lista
	getjumplist()		jump list bejegyzések | lista
	swapinfo()		swap fájl információk
	swapname()		buffer swapfájlja

Command line:					*command-line-functions*
	getcmdline()		command-line tartalma
	getcmdpos()		kurzor pozíciója a command-lineban
	setcmdpos()		kurzor pozíciójának beállítása a command-lineban
	getcmdtype()		command-line típusa
	getcmdwintype()		mint getcmdtype() visszatérhet üres stringgel
	getcompletion()		command-line kiegészítések | lista
	fullcommand()		get full command name

Quickfix és location lista:			*quickfix-functions*
	getqflist()		quickfix hibák listája
	setqflist()		quickfix lista módosítása
	getloclist()		location lista elemeinek helye
	setloclist()		location lista módosítása

Insert mód kiegészítés:				*completion-functions*
	complete()		kiegészítés
	complete_add()		kiegészítés hozzáadása
	complete_check()	ellenőrzés: kiegészítés megszakítása
	complete_info()		kiegészítésre vonatkozó információ | szótár
	pumvisible()		ellenőrzés: popup menü megjelenítve
	pum_getpos()		popup mérete és pozíciója

Foldolás:					*folding-functions*
	foldclosed()		ellenőrzés: meghat. sorban zárt fold
	foldclosedend()		mint foldclosed(), de az utolsó sort
				visszaadja
	foldlevel()		meghatározott sor fold szintje
	foldtext()		zárt fold megjelenített szövege
	foldtextresult()	zárt fold megjelenített szövege | string

Szintaxis és kiemelés:	    	  *syntax-functions* *highlighting-functions*
	clearmatches()		|matchadd()| és |:match| összes egyezésének
				törlése
	getmatches()		|matchadd()| és |:match| összes egyezése
	hlexists()		ellenőrzés: highlight csoport megléte
	hlID()			highlight csoport ID-je
	synID()			meghat. pozíció sztanxis ID-je
	synIDattr()		szintaxis ID attribútuma
	synIDtrans()		lefordított szintaxis ID
	synstack()		meghat. pozíció szintaxis ID listája
	synconcealed()		conceal információk
	diff_hlID()		get highlight ID for diff mode at a position
	matchadd()		kiemelési minta meghatározása
	matchaddpos()		define a list of positions to highlight
	matcharg()		|:match| argumentum információi
				|:match| által definiált egyezés törlése
	setmatches()		|getmatches()| által mentett egyezések
				visszaállítása

Helyesírás ellenőrzés:				*spell-functions*
	spellbadword()		elgépel szó a kurzor után
	spellsuggest()		javaslatok
	soundfold()		hasonlóan hangzó szavak

History:					*history-functions*
	histadd()		elem hozzáadása a historyhoz
	histdel()		elem eltávolítása a historyból
	histget()		elem a historyból
	histnr()		history legmagasabb indexe

Interaktív:					*interactive-functions*
	browse()		fájlválasztó
	browsedir()		könyvtárválasztó
	confirm()		felhasználói megerősítése
	getchar()		karakter a felhasználótól
	getcharstr()		karakter a felhasználótól stringként
	getcharmod()		utolsó karakter módosítóbillentyűje
	getmousepos()		egér utolsó pozíciója
	echoraw()		karakter kiírása (formázatlanul)
	feedkeys()		karakter typeahead-sorba helyezése
	input()			felhasználótól bekért sor
	inputlist()		felhasználó választhat listából
	inputsecret()		felhasználó bekért sor (kimenet nélkül)
	inputdialog()		sor bekérése párbeszédablakkal
	inputsave()		mentés és typeahead törlése
	inputrestore()		typeahead visszaállítása

GUI:						*gui-functions*
	getfontname()		használatban lévő betűtípus
	getwinpos()		Vim ablak pozíciója
	getwinposx()		Vim ablak X pozíciója
	getwinposy()		Vim ablak Y pozíciója
	balloon_show()		buboréksúgó
	balloon_split()		üzenet felosztása buboréksúgóban
	balloon_gettext()	buboréksúgó szövege

Vim szerver:					*server-functions*
	serverlist()		szervernevek listája
	remote_startserver()	szerver futtatása
	remote_send()		parancs küldése a szervernek
	remote_expr()		kifejezés kiértékelése a szerver
	server2client()		válasz a kliensnek
	remote_peek()		ellenőrzés: válasz a Vim szervertől
	remote_read()		válasz olvasása a Vim szervertől
	foreground()		Vim ablakot előtérbe helyez
	remote_foreground()	Vim szerver ablakot előtérbe helyez

Ablak méret és pozíció:				*window-size-functions*
	winheight()		ablak magassága
	winwidth()		ablak szélessége
	win_screenpos()		ablak pozíciója a képernyőn
	winlayout()		ablakelrendezés lekérése a fülről
	winrestcmd()		ablakméretek visszaállítása
	winsaveview()		aktív ablak nézete
	winrestview()		aktív ablak mentett nézetének visszaállítása

Mappek és menük:				*mapping-functions*
	digraph_get()		|digraph|
	digraph_getlist()	összes |digraph|
	digraph_set()		|digraph| beállítása
	digraph_setlist()	több |digraph| beállítása
	hasmapto()		mappelés ellenőrzése
	mapcheck()		egyező mappelés ellenőrzése
	maparg()		mapping jobb-értéke
	mapset()		map visszaállítása
	menu_info()		menüelem információi
	wildmenumode()		ellenőrzés: 'wildmenu'

Tesztelés:					*test-functions*
	assert_equal()		két kifejezés értéke egyenlő
	assert_equalfile()	két fájl tartalma azonos
	assert_notequal()	két kifejezés értéke nem egyenlő
	assert_inrange()	kifejezés értéke tartományon belül
	assert_match()		minta illeszkedik
	assert_notmatch()	minta nem illeszkedik
	assert_false()		kifejelés hamis
	assert_true()		kifejezés igaz
	assert_exception()	kifejezés kivétel dob
	assert_beeps()		parancs hangjelzést ad
	assert_nobeep()		parancs nem ad hangjelzést
	assert_fails()		parancs hiba
	assert_report()		hibás teszt eredményének megjelenítése
	test_alloc_fail()	hibás memória-foglalás
	test_autochdir()	'autochdir' engedélyezése indításnál
	test_override()		tesztelés a Vim belső overridejaival
	test_garbagecollect_now()   memória felszabadítása most
	test_garbagecollect_soon()  flag a hamarosan felszabaduló memóriának
	test_getvalue()		belső változó értéke
	test_gui_drop_files()	fájlok ablakba ejtése
	test_gui_mouse_event()	GUI egér esemény ablakhoz rendelése
	test_ignore_error()	maghat. hibaüzenetek ignorálása
	test_null_blob()	visszatérési érték:  null Blob
	test_null_channel()	visszatérési érték:  null Channel
	test_null_dict()	visszatérési érték:  null Dict
	test_null_function()	visszatérési érték:  null Funcref
	test_null_job()		visszatérési érték:  null Job
	test_null_list()	visszatérési érték:  null List
	test_null_partial()	visszatérési érték:  null Partial function
	test_null_string()	visszatérési érték:  null String
	test_settime()		Vim belső időbélyeg
	test_setmouse()		egér pozíciójának beállítása
	test_feedinput()	billentyű-szekvencia az input buffernek
	test_option_not_set()	flag visszaállítása:  opció nincs beállítva
	test_scrollbar()	görgetősáv szimulációja a GUIban
	test_refcount()		kifejezés referenciaértéke
	test_srand_seed()	srand() seed értéke
	test_unknown()		visszatérési érték ismeretlen típusú
	test_void()		visszatérési érték void típusú

Belső-folyamtok között kommunikáció:	    *channel-functions*
	ch_canread()		beolvasási állapot ellenőrzése
	ch_open()		csatorna nyitása
	ch_close()		csatorna zárása
	ch_close_in()		csatorna bementének zárása
	ch_read()		üzenet olvasása a csatornáról
	ch_readblob()		Blob olvasása a csatornáról
	ch_readraw()		raw message olvasása a csatornáról
	ch_sendexpr()		JSON üzenet küldése a csatornán
	ch_sendraw()		raw message küldése a csatornán
	ch_evalexpr()		kifejezés kiértékelése a csatornán
	ch_evalraw()		raw string kiértékelése a csatornán
	ch_status()		csatorna állapota
	ch_getbufnr()		csatorna bufferszáma
	ch_getjob()		csatornához társítható munkafolyamat
	ch_info()		csatorna információk
	ch_log()		üzenet írása a csatorna log fájlba
	ch_logfile()		csatorna log beállítása
	ch_setoptions()		csatorna beállításai
	json_encode()		kifejezés kódolása JSON Stringgé
	json_decode()		JSON string dekódolása Vim stringgé
	js_encode()		kifejezés kódolása JSON Stringgé
	js_decode()		JSON string dekódolása Vim típussá

Jobs:						*job-functions*
	job_start()		start a job
	job_stop()		stop a job
	job_status()		get the status of a job
	job_getchannel()	get the channel used by a job
	job_info()		get information about a job
	job_setoptions()	set options for a job

Signs:						*sign-functions*
	sign_define()		define or update a sign
	sign_getdefined()	get a list of defined signs
	sign_getplaced()	get a list of placed signs
	sign_jump()		jump to a sign
	sign_place()		place a sign
	sign_placelist()	place a list of signs
	sign_undefine()		undefine a sign
	sign_unplace()		unplace a sign
	sign_unplacelist()	unplace a list of signs

Terminal window:				*terminal-functions*
	term_start()		open a terminal window and run a job
	term_list()		get the list of terminal buffers
	term_sendkeys()		send keystrokes to a terminal
	term_wait()		wait for screen to be updated
	term_getjob()		get the job associated with a terminal
	term_scrape()		get row of a terminal screen
	term_getline()		get a line of text from a terminal
	term_getattr()		get the value of attribute {what}
	term_getcursor()	get the cursor position of a terminal
	term_getscrolled()	get the scroll count of a terminal
	term_getaltscreen()	get the alternate screen flag
	term_getsize()		get the size of a terminal
	term_getstatus()	get the status of a terminal
	term_gettitle()		get the title of a terminal
	term_gettty()		get the tty name of a terminal
	term_setansicolors()	set 16 ANSI colors, used for GUI
	term_getansicolors()	get 16 ANSI colors, used for GUI
	term_dumpdiff()		display difference between two screen dumps
	term_dumpload()		load a terminal screen dump in a window
	term_dumpwrite()	dump contents of a terminal screen to a file
	term_setkill()		set signal to stop job in a terminal
	term_setrestore()	set command to restore a terminal
	term_setsize()		set the size of a terminal
	term_setapi()		set terminal JSON API function name prefix

Popup window:					*popup-window-functions*
	popup_create()		create popup centered in the screen
	popup_atcursor()	create popup just above the cursor position,
				closes when the cursor moves away
	popup_beval()		at the position indicated by v:beval_
				variables, closes when the mouse moves away
	popup_notification()	show a notification for three seconds
	popup_dialog()		create popup centered with padding and border
	popup_menu()		prompt for selecting an item from a list
	popup_hide()		hide a popup temporarily
	popup_show()		show a previously hidden popup
	popup_move()		change the position and size of a popup
	popup_setoptions()	override options of a popup
	popup_settext()		replace the popup buffer contents
	popup_close()		close one popup
	popup_clear()		close all popups
	popup_filter_menu()	select from a list of items
	popup_filter_yesno()	block until 'y' or 'n' is pressed
	popup_getoptions()	get current options for a popup
	popup_getpos()		get actual position and size of a popup
	popup_findinfo()	get window ID for popup info window
	popup_findpreview()	get window ID for popup preview window
	popup_list()		get list of all popup window IDs
	popup_locate()		get popup window ID from its screen position

Timers:						*timer-functions*
	timer_start()		create a timer
	timer_pause()		pause or unpause a timer
	timer_stop()		stop a timer
	timer_stopall()		stop all timers
	timer_info()		get information about timers

Tags:						*tag-functions*
	taglist()		get list of matching tags
	tagfiles()		get a list of tags files
	gettagstack()		get the tag stack of a window
	settagstack()		modify the tag stack of a window

Prompt Buffer:					*promptbuffer-functions*
	prompt_getprompt()	get the effective prompt text for a buffer
	prompt_setcallback()	set prompt callback for a buffer
	prompt_setinterrupt()	set interrupt callback for a buffer
	prompt_setprompt()	set the prompt text for a buffer

Text Properties:				*text-property-functions*
	prop_add()		attach a property at a position
	prop_add_list()		attach a property at multiple positions
	prop_clear()		remove all properties from a line or lines
	prop_find()		search for a property
	prop_list()		return a list of all properties in a line
	prop_remove()		remove a property from a line
	prop_type_add()		add/define a property type
	prop_type_change()	change properties of a type
	prop_type_delete()	remove a text property type
	prop_type_get()		return the properties of a type
	prop_type_list()	return a list of all property types

Sound:							*sound-functions*
	sound_clear()		stop playing all sounds
	sound_playevent()	play an event's sound
	sound_playfile()	play a sound file
	sound_stop()		stop playing a sound

Various:					*various-functions*
	mode()			get current editing mode
	state()			get current busy state
	visualmode()		last visual mode used
	exists()		check if a variable, function, etc. exists
	exists_compiled()	like exists() but check at compile time
	has()			check if a feature is supported in Vim
	changenr()		return number of most recent change
	cscope_connection()	check if a cscope connection exists
	did_filetype()		check if a FileType autocommand was used
	eventhandler()		check if invoked by an event handler
	getpid()		get process ID of Vim
	getimstatus()		check if IME status is active
	interrupt()		interrupt script execution
	windowsversion()	get MS-Windows version
	terminalprops()		properties of the terminal

	libcall()		call a function in an external library
	libcallnr()		idem, returning a number

	undofile()		get the name of the undo file
	undotree()		return the state of the undo tree

	getreg()		get contents of a register
	getreginfo()		get information about a register
	getregtype()		get type of a register
	setreg()		set contents and type of a register
	reg_executing()		return the name of the register being executed
	reg_recording()		return the name of the register being recorded

	shiftwidth()		effective value of 'shiftwidth'

	wordcount()		get byte/word/char count of buffer

	luaeval()		evaluate |Lua| expression
	mzeval()		evaluate |MzScheme| expression
	perleval()		evaluate Perl expression (|+perl|)
	py3eval()		evaluate Python expression (|+python3|)
	pyeval()		evaluate Python expression (|+python|)
	pyxeval()		evaluate |python_x| expression
	rubyeval()		evaluate |Ruby| expression

	debugbreak()		interrupt a program being debugged

==============================================================================
*41.7*	Függvények létrehozása

A Vimben létrehozhatjuk saját függvényeinket. Az alapvető függvénydeklaráció a
következő: >

	:function {name}({var1}, {var2}, ...)
	:  {body}
	:endfunction
<
	Megjegyzés:
	A függvényneveknek nagy kezdőbetűvel kell kezdődniük

Hozzunk lére egy olyan függvényt, mely két számból a kissebbel tért vissza.
Kezdjük ezzel a sorral: >

	:function Min(num1, num2)

Ezzel meghatároztuk a függvény nevét "Min", illetve a két argumentumot: "num1"
és "num2".
   Első lépésben ellenőriznünk kell, hogy melyik szám kissebb:
   >
	:  if a:num1 < a:num2

Az "a:" prefixum azt jelenti, hogy a változó egy függvényargumentum. Rendeljük
 hozzá a kisebb számot a "smaller" nevű változóhoz: >

	:  if a:num1 < a:num2
	:    let smaller = a:num1
	:  else
	:    let smaller = a:num2
	:  endif

A "smaller" változó lokális. Minden változó lokális a függvényre nézve, amíg
ezt máshogyan nem jelöljük, mint például: "g:", "a:", vagy "s:".

	Megjegyzés:
	Ahhoz, hogy egy globális változót el tudjuk érni a függvényen
	belülről, "g:" prefixummal kell ellássuk. Ezért "g:today" változóra
	globális változóként tekintünk, "today"-t egy külön változóként
	kezeljük, ami a függvény lokális változója.

Végül használjuk a ":return" parancsot a visszatéréshez, amely a kisebb
számmal tér vissza, májd zárjuk a függvényt: >

	:  return smaller
	:endfunction

A teljes függvénydefiníció: >

	:function Min(num1, num2)
	:  if a:num1 < a:num2
	:    let smaller = a:num1
	:  else
	:    let smaller = a:num2
	:  endif
	:  return smaller
	:endfunction

Akik szeretik a rövid függvényeket: >

	:function Min(num1, num2)
	:  if a:num1 < a:num2
	:    return a:num1
	:  endif
	:  return a:num2
	:endfunction

A felhasználó által definiált függvényeket ugyanúgy kell meghívnunk, mint a
beépítetteket. A Min függvényt így tudjuk meghívni: >

	:echo Min(5, 8)


A függvény futtatása elkezdődik és a Vim soronként végrehajtja a prancsokat.
Hiba esetén (például ismeretlen változó vagy függvény esetén) hibaüzenetet
ebben a szakaszban kapjuk meg. A függvény írásakor nincs mód a hibák
észlelésére.

Amikor a függvény eléri az ":endfunction" vagy ":return" kulcsszavakat,
argumentum használata nélkül a függvény automatikusan nulla (0) értékkel tér
vissza.

Létező függvény újradefiniálásához  a "!" jelet kell használjuk a ":function"
parancsban: >

	:function!  Min(num1, num2, num3)


TARTOMÁNY HASZNÁLATA

A ":call" parnacsnak sorokra hivatkozó tartományt is átadhatunk. Ennek két
értelme lehet. Ha a függvényt a "range" kulcsszóval definiáltuk, akkor ennek
kezeléséről magának gondoskodik.
  Ekkor a függvény megkapja a "a:firstline" és a "a:lastline" változókat,
melyek tartalmazzák a tartomány kezdeti- és végpontját. Például: >

	:function Count_words() range
	:  let lnum = a:firstline
	:  let n = 0
	:  while lnum <= a:lastline
	:    let n = n + len(split(getline(lnum)))
	:    let lnum = lnum + 1
	:  endwhile
	:  echo "found " .. n .. " words"
	:endfunction

A függvényt meghívatjuk így: >

	:10,30call Count_words()

A függvény egyszer fut le és kiírja a szavak számát.
   A másik módszer, ha  a függvényt a "range" kulcsszó nélkül definiáljuk. Így
a függvény minden sorban külön meghívódik. Például: >

	:function  Number()
	:  echo "line " .. line(".") .. " contains: " .. getline(".")
	:endfunction

Ha a függvényt így hívjuk meg: >

	:10,15call Number()

Akkor az hat hívást jelent.


VÁLTOZÓ ARGUMENTUMLISTA

A Vim függvényeiben egynél több argumentum is szerepelhet. Az alábbi
paranccsal, például egy olyan függvényt definiálunk, melyben kötelezően kell
szerepelnie egy (start) argumentumnak. (A függvények maximálisan 20
argumentumot képesek kezelni: >

	:function Show(start, ...)

Az "a:1" változó tartalmazza az első argumentumot, a "a:2" a másodikat és így
tovább. Az "a:0" tartalmazza az extra argumentumok számát. Például: >

	:function Show(start, ...)
	:  echohl Title
	:  echo "start is " .. a:start
	:  echohl None
	:  let index = 1
	:  while index <= a:0
	:    echo "  Arg " .. index .. " is " .. a:{index}
	:    let index = index + 1
	:  endwhile
	:  echo ""
	:endfunction

A példa "echohl" a következő ":echo" parancs kiemelését határozza meg.
":echohl None" visszaállítja a kiemelést. Az ":echon" parancs ugyanúgy
működik, mint az ":echo", sortörést viszont nem alkalmaz.

Az "a:000" speciális változó, egy lista, mely az összes "..." argumentumot
tartalmazza. Lásd |a:000|.


LISTÁZÓ FÜGGVÉNYEK

A ":function" parancs az összes felhasználó által definiált (beleértve a
telepített beépülőket is) neveket és argumentumokat lisázza: >

	:function
<	function Show(start, ...) ~
	function GetVimIndent() ~
	function SetSyn(name) ~

Ha meg szeretnénk tekinteni magát a függvényt, akkor adjuk át a függvény nevét
argumentumként a ":function" parancsnak: >

	:function SetSyn
<	1     if &syntax == '' ~
	2       let &syntax = a:name ~
	3     endif ~
	   endfunction ~


HIBAKERESÉS

A sor száma nagyon hasznos hibaüzenetek értelmezésekor, vagy hibakeresésnél.
Lásd |debug-scripts|.
   A 'verbose' opció 12, vagy annál nagyobbra állításával láthatóvá válik
minden függvényhívás. 15, vagy annál nagyobb esetén az összes futtatott sor
látszik.


FÜGGVÉNY TÖRLÉSE

A Show() függvény törlése: >

	:delfunction Show

Ha a függvény nem létezik, akkor hibaüzenetet kapunk.


FÜGGVÉNYHIVATKOZÁSOK

Olykor hasznos, ha egy függvényt változóhoz tudunk rendelni, ezt a function()
függvénnyel tudjuk megtenni, mely átalakítja a függvény nevét hivatkozássá. >

	:let result = 0		" or 1
	:function! Right()
	:  return 'Right!'
	:endfunc
	:function! Wrong()
	:  return 'Wrong!'
	:endfunc
	:
	:if result == 1
	:  let Afunc = function('Right')
	:else
	:  let Afunc = function('Wrong')
	:endif
	:echo call(Afunc, [])
<	Wrong! ~

Megjegyzés: a függvényhivatkozást tartalmazó változó nevének nagy betűvel kell
kezdődnie, különben könnyen egy beépített függvénynek tekinthetjük.
   A hivatkozott függvényt a call() függvénnyel tudjuk meghívni, melynek első
argumentuma a függvényhivatkozást tartalmazó változó, a második pedig az
argumentumokat tartalmazó lista.

A függvényhivatkozások szótárakkal való kombinálása további lehetőségeket
nyújt, erről azonban a következő fejezetben.
==============================================================================
*41.8*	Listák és szótárak

Eddig az alap String és szám típusokat használtuk. A Vim további két összetett
változó típust támogat: a listákat és a szótárakat.

A lista különböző adatok rendezett sora. Az adatok bármik lehetnek, ezért
létrehozhatunk listát számokkal, listát tartalmazó listákat, vagy akár a kettő
kombinációját. Lista három elemmel: >

	:let alist = ['aap', 'mies', 'noot']

A listát szögletes zárójelek határolják és értékeit vesszők választják el
egymástól. Üres lista létrehozása: >

	:let alist = []

Az add() függvénnyel a listához elemeket rendelhetünk: >

	:let alist = []
	:call add(alist, 'foo')
	:call add(alist, 'bar')
	:echo alist
<	['foo', 'bar'] ~

Listák összefűzéséhez a "+" operátort használhatjuk: >

	:echo alist + ['foo', 'bar']
<	['foo', 'bar', 'foo', 'bar'] ~

Vagy, ha közvetlenül szeretnéd kiegészíteni: >

	:let alist = ['one']
	:call extend(alist, ['two', 'three'])
	:echo alist
<	['one', 'two', 'three'] ~

Vegyük észre az add() és extend() közötti különbséget:  >

	:let alist = ['one']
	:call add(alist, ['two', 'three'])
	:echo alist
<	['one', ['two', 'three']] ~

Az add() második argumentuma egy elemeként adódik a listához.


FOR CIKLUS

A listák egyik jó tulajdonsága, hogy bejárhatjuk őket: >

	:let alist = ['one', 'two', 'three']
	:for n in alist
	:  echo n
	:endfor
<	one ~
	two ~
	three ~

A példa az "alist" lista összes elemét bejárja, az értéket "n"-hez rendelve
kiírja a kimenetre. A for ciklus általános formája: >

	:for {varname} in {listexpression}
	:  {commands}
	:endfor

Meghatározott ismétlésszámhoz a range() függvényt használhatjuk: >

	:for a in range(3)
	:  echo a
	:endfor
<	0 ~
	1 ~
	2 ~

Jegyezzük meg, hogy a range() függvény első eleme mindig nullával kezdődik,
ezért az utolsó elem eggyel kevesebb lesz, mint a lista hossza.
   Maximum értéket is meghatározhatunk, sőt, akár visszafelé is haladhatunk: >

	:for a in range(8, 4, -2)
	:  echo a
	:endfor
<	8 ~
	6 ~
	4 ~

Még hasznosabb példa: a bufer sorainak bejárása: >

	:for line in getline(1, 20)
	:  if line =~ "Date: "
	:    echo matchstr(line, 'Date: \zs.*')
	:  endif
	:endfor

Mely végighalad az első húsz soron (1-20 inkluzív) és kiírja a megtalált
dátumokat.


SZÓTÁRAK

A szótárak kulcs-értekpárokat tárolnak. A bejárás nagyon gyors, ha ismerjük a
kulcsokat. A szótárakat kapcsos zárójelek határolják: >

	:let uk2nl = {'one': 'een', 'two': 'twee', 'three': 'drie'}

A kulcsokhoz tartozó értékeket így érhetjük el: >

	:echo uk2nl['two']
<	twee ~

A szótár általános definíciója: >

	{<key> : <value>, ...}

Üres szótár definiálása kulcsok nélkül: >

	{}

A szótárakban rejlő potenciál hatalmas. Kezelésükhöz számos beépített függvény
elérhető. Például, a lista kulcsainak bejárása: >

	:for key in keys(uk2nl)
	:  echo key
	:endfor
<	three ~
	one ~
	two ~

Észrevehetjük, hogy a kulcsok nem rendezettek. Így rendezhetjük őket: >

	:for key in sort(keys(uk2nl))
	:  echo key
	:endfor
<	one ~
	three ~
	two ~

A szótárban tárolt elemek eredeti elrendezését soha nem kapjuk meg, ehhez
listát kell használnunk, mely sorrendben tárolja az elemeket.


SZÓTÁRFÜGGVÉNYEK

A szótár elemeit a szögletes zárójelek közötti kulcs átadásával érthetjük el.
>
	:echo uk2nl['one']
<	een ~

Az alábbi módszerrel is elérhetjük az elemeket, speciális karakterek írása
nálkül: >

	:echo uk2nl.one
<	een ~

A módszer csak az ASCII karakterek betűivel, számokkal és "_" karakterrel
működik. Így akár új elemeket is létrehozhatunk:  >

	:let uk2nl.four = 'vier'
	:echo uk2nl
<	{'three': 'drie', 'four': 'vier', 'one': 'een', 'two': 'twee'} ~

És most valami specialitás, függvényeket is létrehozhatunk listaelemként. >

	:function uk2nl.translate(line) dict
	:  return join(map(split(a:line), 'get(self, v:val, "???")'))
	:endfunction

Próbáljuk ki: >

	:echo uk2nl.translate('three two five one')
<	drie twee ??? een ~

The first special thing you notice is the "dict" at the end of the ":function"
line.  This marks the function as being used from a Dictionary.  The "self"
local variable will then refer to that Dictionary.
   Now let's break up the complicated return command: >

	split(a:line)

The split() function takes a string, chops it into whitespace separated words
and returns a list with these words.  Thus in the example it returns: >

	:echo split('three two five one')
<	['three', 'two', 'five', 'one'] ~

This list is the first argument to the map() function.  This will go through
the list, evaluating its second argument with "v:val" set to the value of each
item.  This is a shortcut to using a for loop.  This command: >

	:let alist = map(split(a:line), 'get(self, v:val, "???")')

Is equivalent to: >

	:let alist = split(a:line)
	:for idx in range(len(alist))
	:  let alist[idx] = get(self, alist[idx], "???")
	:endfor

The get() function checks if a key is present in a Dictionary.  If it is, then
the value is retrieved.  If it isn't, then the default value is returned, in
the example it's '???'.  This is a convenient way to handle situations where a
key may not be present and you don't want an error message.

The join() function does the opposite of split(): it joins together a list of
words, putting a space in between.
  This combination of split(), map() and join() is a nice way to filter a line
of words in a very compact way.


OBJECT ORIENTED PROGRAMMING

Now that you can put both values and functions in a Dictionary, you can
actually use a Dictionary like an object.
   Above we used a Dictionary for translating Dutch to English.  We might want
to do the same for other languages.  Let's first make an object (aka
Dictionary) that has the translate function, but no words to translate: >

	:let transdict = {}
	:function transdict.translate(line) dict
	:  return join(map(split(a:line), 'get(self.words, v:val, "???")'))
	:endfunction

It's slightly different from the function above, using 'self.words' to lookup
word translations.  But we don't have a self.words.  Thus you could call this
an abstract class.

Now we can instantiate a Dutch translation object: >

	:let uk2nl = copy(transdict)
	:let uk2nl.words = {'one': 'een', 'two': 'twee', 'three': 'drie'}
	:echo uk2nl.translate('three one')
<	drie een ~

And a German translator: >

	:let uk2de = copy(transdict)
	:let uk2de.words = {'one': 'eins', 'two': 'zwei', 'three': 'drei'}
	:echo uk2de.translate('three one')
<	drei eins ~

You see that the copy() function is used to make a copy of the "transdict"
Dictionary and then the copy is changed to add the words.  The original
remains the same, of course.

Now you can go one step further, and use your preferred translator: >

	:if $LANG =~ "de"
	:  let trans = uk2de
	:else
	:  let trans = uk2nl
	:endif
	:echo trans.translate('one two three')
<	een twee drie ~

Here "trans" refers to one of the two objects (Dictionaries).  No copy is
made.  More about List and Dictionary identity can be found at |list-identity|
and |dict-identity|.

Now you might use a language that isn't supported.  You can overrule the
translate() function to do nothing: >

	:let uk2uk = copy(transdict)
	:function! uk2uk.translate(line)
	:  return a:line
	:endfunction
	:echo uk2uk.translate('three one wladiwostok')
<	three one wladiwostok ~

Notice that a ! was used to overwrite the existing function reference.  Now
use "uk2uk" when no recognized language is found: >

	:if $LANG =~ "de"
	:  let trans = uk2de
	:elseif $LANG =~ "nl"
	:  let trans = uk2nl
	:else
	:  let trans = uk2uk
	:endif
	:echo trans.translate('one two three')
<	one two three ~

For further reading see |Lists| and |Dictionaries|.

==============================================================================
*41.9*	Exceptions

Let's start with an example: >

	:try
	:   read ~/templates/pascal.tmpl
	:catch /E484:/
	:   echo "Sorry, the Pascal template file cannot be found."
	:endtry

The ":read" command will fail if the file does not exist.  Instead of
generating an error message, this code catches the error and gives the user a
nice message.

For the commands in between ":try" and ":endtry" errors are turned into
exceptions.  An exception is a string.  In the case of an error the string
contains the error message.  And every error message has a number.  In this
case, the error we catch contains "E484:".  This number is guaranteed to stay
the same (the text may change, e.g., it may be translated).

When the ":read" command causes another error, the pattern "E484:" will not
match in it.  Thus this exception will not be caught and result in the usual
error message.

You might be tempted to do this: >

	:try
	:   read ~/templates/pascal.tmpl
	:catch
	:   echo "Sorry, the Pascal template file cannot be found."
	:endtry

This means all errors are caught.  But then you will not see errors that are
useful, such as "E21: Cannot make changes, 'modifiable' is off".

Another useful mechanism is the ":finally" command: >

	:let tmp = tempname()
	:try
	:   exe ".,$write " .. tmp
	:   exe "!filter " .. tmp
	:   .,$delete
	:   exe "$read " .. tmp
	:finally
	:   call delete(tmp)
	:endtry

This filters the lines from the cursor until the end of the file through the
"filter" command, which takes a file name argument.  No matter if the
filtering works, something goes wrong in between ":try" and ":finally" or the
user cancels the filtering by pressing CTRL-C, the "call delete(tmp)" is
always executed.  This makes sure you don't leave the temporary file behind.

More information about exception handling can be found in the reference
manual: |exception-handling|.

==============================================================================
*41.10*	Various remarks

Here is a summary of items that apply to Vim scripts.  They are also mentioned
elsewhere, but form a nice checklist.

The end-of-line character depends on the system.  For Unix a single <NL>
character is used.  For MS-Windows and the like, <CR><NL> is used.  This is
important when using mappings that end in a <CR>.  See |:source_crnl|.


WHITE SPACE

Blank lines are allowed and ignored.

Leading whitespace characters (blanks and TABs) are always ignored.  The
whitespaces between parameters (e.g. between the "set" and the "cpoptions" in
the example below) are reduced to one blank character and plays the role of a
separator, the whitespaces after the last (visible) character may or may not
be ignored depending on the situation, see below.

For a ":set" command involving the "=" (equal) sign, such as in: >

	:set cpoptions    =aABceFst

the whitespace immediately before the "=" sign is ignored.  But there can be
no whitespace after the "=" sign!

To include a whitespace character in the value of an option, it must be
escaped by a "\" (backslash)  as in the following example: >

	:set tags=my\ nice\ file

The same example written as: >

	:set tags=my nice file

will issue an error, because it is interpreted as: >

	:set tags=my
	:set nice
	:set file


COMMENTS

The character " (the double quote mark) starts a comment.  Everything after
and including this character until the end-of-line is considered a comment and
is ignored, except for commands that don't consider comments, as shown in
examples below.  A comment can start on any character position on the line.

There is a little "catch" with comments for some commands.  Examples: >

	:abbrev dev development		" shorthand
	:map <F3> o#include		" insert include
	:execute cmd			" do it
	:!ls *.c			" list C files

The abbreviation 'dev' will be expanded to 'development     " shorthand'.  The
mapping of <F3> will actually be the whole line after the 'o# ....' including
the '" insert include'.  The "execute" command will give an error.  The "!"
command will send everything after it to the shell, causing an error for an
unmatched '"' character.
   There can be no comment after ":map", ":abbreviate", ":execute" and "!"
commands (there are a few more commands with this restriction).  For the
":map", ":abbreviate" and ":execute" commands there is a trick: >

	:abbrev dev development|" shorthand
	:map <F3> o#include|" insert include
	:execute cmd			|" do it

With the '|' character the command is separated from the next one.  And that
next command is only a comment.  For the last command you need to do two
things: |:execute| and use '|': >
	:exe '!ls *.c'			|" list C files

Notice that there is no white space before the '|' in the abbreviation and
mapping.  For these commands, any character until the end-of-line or '|' is
included.  As a consequence of this behavior, you don't always see that
trailing whitespace is included: >

	:map <F4> o#include

To spot these problems, you can set the 'list' option when editing vimrc
files.

For Unix there is one special way to comment a line, that allows making a Vim
script executable: >
	#!/usr/bin/env vim -S
	echo "this is a Vim script"
	quit

The "#" command by itself lists a line with the line number.  Adding an
exclamation mark changes it into doing nothing, so that you can add the shell
command to execute the rest of the file. |:#!| |-S|


PITFALLS

Even bigger problem arises in the following example: >

	:map ,ab o#include
	:unmap ,ab

Here the unmap command will not work, because it tries to unmap ",ab ".  This
does not exist as a mapped sequence.  An error will be issued, which is very
hard to identify, because the ending whitespace character in ":unmap ,ab " is
not visible.

And this is the same as what happens when one uses a comment after an 'unmap'
command: >

	:unmap ,ab     " comment

Here the comment part will be ignored.  However, Vim will try to unmap
',ab     ', which does not exist.  Rewrite it as: >

	:unmap ,ab|    " comment


RESTORING THE VIEW

Sometimes you want to make a change and go back to where the cursor was.
Restoring the relative position would also be nice, so that the same line
appears at the top of the window.
   This example yanks the current line, puts it above the first line in the
file and then restores the view: >

	map ,p ma"aYHmbgg"aP`bzt`a

What this does: >
	ma"aYHmbgg"aP`bzt`a
<	ma			set mark a at cursor position
	  "aY			yank current line into register a
	     Hmb		go to top line in window and set mark b there
		gg		go to first line in file
		  "aP		put the yanked line above it
		     `b		go back to top line in display
		       zt	position the text in the window as before
			 `a	go back to saved cursor position


PACKAGING

To avoid your function names to interfere with functions that you get from
others, use this scheme:
- Prepend a unique string before each function name.  I often use an
  abbreviation.  For example, "OW_" is used for the option window functions.
- Put the definition of your functions together in a file.  Set a global
  variable to indicate that the functions have been loaded.  When sourcing the
  file again, first unload the functions.
Example: >

	" This is the XXX package

	if exists("XXX_loaded")
	  delfun XXX_one
	  delfun XXX_two
	endif

	function XXX_one(a)
		... body of function ...
	endfun

	function XXX_two(b)
		... body of function ...
	endfun

	let XXX_loaded = 1

==============================================================================
*41.11*	Writing a plugin				*write-plugin*

You can write a Vim script in such a way that many people can use it.  This is
called a plugin.  Vim users can drop your script in their plugin directory and
use its features right away |add-plugin|.

There are actually two types of plugins:

  global plugins: For all types of files.
filetype plugins: Only for files of a specific type.

In this section the first type is explained.  Most items are also relevant for
writing filetype plugins.  The specifics for filetype plugins are in the next
section |write-filetype-plugin|.


NAME

First of all you must choose a name for your plugin.  The features provided
by the plugin should be clear from its name.  And it should be unlikely that
someone else writes a plugin with the same name but which does something
different.  And please limit the name to 8 characters, to avoid problems on
old MS-Windows systems.

A script that corrects typing mistakes could be called "typecorr.vim".  We
will use it here as an example.

For the plugin to work for everybody, it should follow a few guidelines.  This
will be explained step-by-step.  The complete example plugin is at the end.


BODY

Let's start with the body of the plugin, the lines that do the actual work: >

 14	iabbrev teh the
 15	iabbrev otehr other
 16	iabbrev wnat want
 17	iabbrev synchronisation
 18		\ synchronization
 19	let s:count = 4

The actual list should be much longer, of course.

The line numbers have only been added to explain a few things, don't put them
in your plugin file!


HEADER

You will probably add new corrections to the plugin and soon have several
versions lying around.  And when distributing this file, people will want to
know who wrote this wonderful plugin and where they can send remarks.
Therefore, put a header at the top of your plugin: >

  1	" Vim global plugin for correcting typing mistakes
  2	" Last Change:	2000 Oct 15
  3	" Maintainer:	Bram Moolenaar <Bram@vim.org>

About copyright and licensing: Since plugins are very useful and it's hardly
worth restricting their distribution, please consider making your plugin
either public domain or use the Vim |license|.  A short note about this near
the top of the plugin should be sufficient.  Example: >

  4	" License:	This file is placed in the public domain.


LINE CONTINUATION, AVOIDING SIDE EFFECTS		*use-cpo-save*

In line 18 above, the line-continuation mechanism is used |line-continuation|.
Users with 'compatible' set will run into trouble here, they will get an error
message.  We can't just reset 'compatible', because that has a lot of side
effects.  To avoid this, we will set the 'cpoptions' option to its Vim default
value and restore it later.  That will allow the use of line-continuation and
make the script work for most people.  It is done like this: >

 11	let s:save_cpo = &cpo
 12	set cpo&vim
 ..
 42	let &cpo = s:save_cpo
 43	unlet s:save_cpo

We first store the old value of 'cpoptions' in the s:save_cpo variable.  At
the end of the plugin this value is restored.

Notice that a script-local variable is used |s:var|.  A global variable could
already be in use for something else.  Always use script-local variables for
things that are only used in the script.


NOT LOADING

It's possible that a user doesn't always want to load this plugin.  Or the
system administrator has dropped it in the system-wide plugin directory, but a
user has his own plugin he wants to use.  Then the user must have a chance to
disable loading this specific plugin.  This will make it possible: >

  6	if exists("g:loaded_typecorr")
  7	  finish
  8	endif
  9	let g:loaded_typecorr = 1

This also avoids that when the script is loaded twice it would cause error
messages for redefining functions and cause trouble for autocommands that are
added twice.

The name is recommended to start with "loaded_" and then the file name of the
plugin, literally.  The "g:" is prepended just to avoid mistakes when using
the variable in a function (without "g:" it would be a variable local to the
function).

Using "finish" stops Vim from reading the rest of the file, it's much quicker
than using if-endif around the whole file.


MAPPING

Now let's make the plugin more interesting: We will add a mapping that adds a
correction for the word under the cursor.  We could just pick a key sequence
for this mapping, but the user might already use it for something else.  To
allow the user to define which keys a mapping in a plugin uses, the <Leader>
item can be used: >

 22	  map <unique> <Leader>a  <Plug>TypecorrAdd;

The "<Plug>TypecorrAdd;" thing will do the work, more about that further on.

The user can set the "mapleader" variable to the key sequence that he wants
this mapping to start with.  Thus if the user has done: >

	let mapleader = "_"

the mapping will define "_a".  If the user didn't do this, the default value
will be used, which is a backslash.  Then a map for "\a" will be defined.

Note that <unique> is used, this will cause an error message if the mapping
already happened to exist. |:map-<unique>|

But what if the user wants to define his own key sequence?  We can allow that
with this mechanism: >

 21	if !hasmapto('<Plug>TypecorrAdd;')
 22	  map <unique> <Leader>a  <Plug>TypecorrAdd;
 23	endif

This checks if a mapping to "<Plug>TypecorrAdd;" already exists, and only
defines the mapping from "<Leader>a" if it doesn't.  The user then has a
chance of putting this in his vimrc file: >

	map ,c  <Plug>TypecorrAdd;

Then the mapped key sequence will be ",c" instead of "_a" or "\a".


PIECES

If a script gets longer, you often want to break up the work in pieces.  You
can use functions or mappings for this.  But you don't want these functions
and mappings to interfere with the ones from other scripts.  For example, you
could define a function Add(), but another script could try to define the same
function.  To avoid this, we define the function local to the script by
prepending it with "s:".

We will define a function that adds a new typing correction: >

 30	function s:Add(from, correct)
 31	  let to = input("type the correction for " .. a:from .. ": ")
 32	  exe ":iabbrev " .. a:from .. " " .. to
 ..
 36	endfunction

Now we can call the function s:Add() from within this script.  If another
script also defines s:Add(), it will be local to that script and can only
be called from the script it was defined in.  There can also be a global Add()
function (without the "s:"), which is again another function.

<SID> can be used with mappings.  It generates a script ID, which identifies
the current script.  In our typing correction plugin we use it like this: >

 24	noremap <unique> <script> <Plug>TypecorrAdd;  <SID>Add
 ..
 28	noremap <SID>Add  :call <SID>Add(expand("<cword>"), 1)<CR>

Thus when a user types "\a", this sequence is invoked: >

	\a  ->  <Plug>TypecorrAdd;  ->  <SID>Add  ->  :call <SID>Add()

If another script also maps <SID>Add, it will get another script ID and
thus define another mapping.

Note that instead of s:Add() we use <SID>Add() here.  That is because the
mapping is typed by the user, thus outside of the script.  The <SID> is
translated to the script ID, so that Vim knows in which script to look for
the Add() function.

This is a bit complicated, but it's required for the plugin to work together
with other plugins.  The basic rule is that you use <SID>Add() in mappings and
s:Add() in other places (the script itself, autocommands, user commands).

We can also add a menu entry to do the same as the mapping: >

 26	noremenu <script> Plugin.Add\ Correction      <SID>Add

The "Plugin" menu is recommended for adding menu items for plugins.  In this
case only one item is used.  When adding more items, creating a submenu is
recommended.  For example, "Plugin.CVS" could be used for a plugin that offers
CVS operations "Plugin.CVS.checkin", "Plugin.CVS.checkout", etc.

Note that in line 28 ":noremap" is used to avoid that any other mappings cause
trouble.  Someone may have remapped ":call", for example.  In line 24 we also
use ":noremap", but we do want "<SID>Add" to be remapped.  This is why
"<script>" is used here.  This only allows mappings which are local to the
script. |:map-<script>|  The same is done in line 26 for ":noremenu".
|:menu-<script>|


<SID> AND <Plug>					*using-<Plug>*

Both <SID> and <Plug> are used to avoid that mappings of typed keys interfere
with mappings that are only to be used from other mappings.  Note the
difference between using <SID> and <Plug>:

<Plug>	is visible outside of the script.  It is used for mappings which the
	user might want to map a key sequence to.  <Plug> is a special code
	that a typed key will never produce.
	To make it very unlikely that other plugins use the same sequence of
	characters, use this structure: <Plug> scriptname mapname
	In our example the scriptname is "Typecorr" and the mapname is "Add".
	We add a semicolon as the terminator.  This results in
	"<Plug>TypecorrAdd;".  Only the first character of scriptname and
	mapname is uppercase, so that we can see where mapname starts.

<SID>	is the script ID, a unique identifier for a script.
	Internally Vim translates <SID> to "<SNR>123_", where "123" can be any
	number.  Thus a function "<SID>Add()" will have a name "<SNR>11_Add()"
	in one script, and "<SNR>22_Add()" in another.  You can see this if
	you use the ":function" command to get a list of functions.  The
	translation of <SID> in mappings is exactly the same, that's how you
	can call a script-local function from a mapping.


USER COMMAND

Now let's add a user command to add a correction: >

 38	if !exists(":Correct")
 39	  command -nargs=1  Correct  :call s:Add(<q-args>, 0)
 40	endif

The user command is defined only if no command with the same name already
exists.  Otherwise we would get an error here.  Overriding the existing user
command with ":command!" is not a good idea, this would probably make the user
wonder why the command he defined himself doesn't work.  |:command|


SCRIPT VARIABLES

When a variable starts with "s:" it is a script variable.  It can only be used
inside a script.  Outside the script it's not visible.  This avoids trouble
with using the same variable name in different scripts.  The variables will be
kept as long as Vim is running.  And the same variables are used when sourcing
the same script again. |s:var|

The fun is that these variables can also be used in functions, autocommands
and user commands that are defined in the script.  In our example we can add
a few lines to count the number of corrections: >

 19	let s:count = 4
 ..
 30	function s:Add(from, correct)
 ..
 34	  let s:count = s:count + 1
 35	  echo s:count .. " corrections now"
 36	endfunction

First s:count is initialized to 4 in the script itself.  When later the
s:Add() function is called, it increments s:count.  It doesn't matter from
where the function was called, since it has been defined in the script, it
will use the local variables from this script.


THE RESULT

Here is the resulting complete example: >

  1	" Vim global plugin for correcting typing mistakes
  2	" Last Change:	2000 Oct 15
  3	" Maintainer:	Bram Moolenaar <Bram@vim.org>
  4	" License:	This file is placed in the public domain.
  5
  6	if exists("g:loaded_typecorr")
  7	  finish
  8	endif
  9	let g:loaded_typecorr = 1
 10
 11	let s:save_cpo = &cpo
 12	set cpo&vim
 13
 14	iabbrev teh the
 15	iabbrev otehr other
 16	iabbrev wnat want
 17	iabbrev synchronisation
 18		\ synchronization
 19	let s:count = 4
 20
 21	if !hasmapto('<Plug>TypecorrAdd;')
 22	  map <unique> <Leader>a  <Plug>TypecorrAdd;
 23	endif
 24	noremap <unique> <script> <Plug>TypecorrAdd;  <SID>Add
 25
 26	noremenu <script> Plugin.Add\ Correction      <SID>Add
 27
 28	noremap <SID>Add  :call <SID>Add(expand("<cword>"), 1)<CR>
 29
 30	function s:Add(from, correct)
 31	  let to = input("type the correction for " .. a:from .. ": ")
 32	  exe ":iabbrev " .. a:from .. " " .. to
 33	  if a:correct | exe "normal viws\<C-R>\" \b\e" | endif
 34	  let s:count = s:count + 1
 35	  echo s:count .. " corrections now"
 36	endfunction
 37
 38	if !exists(":Correct")
 39	  command -nargs=1  Correct  :call s:Add(<q-args>, 0)
 40	endif
 41
 42	let &cpo = s:save_cpo
 43	unlet s:save_cpo

Line 33 wasn't explained yet.  It applies the new correction to the word under
the cursor.  The |:normal| command is used to use the new abbreviation.  Note
that mappings and abbreviations are expanded here, even though the function
was called from a mapping defined with ":noremap".

Using "unix" for the 'fileformat' option is recommended.  The Vim scripts will
then work everywhere.  Scripts with 'fileformat' set to "dos" do not work on
Unix.  Also see |:source_crnl|.  To be sure it is set right, do this before
writing the file: >

	:set fileformat=unix


DOCUMENTATION						*write-local-help*

It's a good idea to also write some documentation for your plugin.  Especially
when its behavior can be changed by the user.  See |add-local-help| for how
they are installed.

Here is a simple example for a plugin help file, called "typecorr.txt": >

  1	*typecorr.txt*	Plugin for correcting typing mistakes
  2
  3	If you make typing mistakes, this plugin will have them corrected
  4	automatically.
  5
  6	There are currently only a few corrections.  Add your own if you like.
  7
  8	Mappings:
  9	<Leader>a   or   <Plug>TypecorrAdd;
 10		Add a correction for the word under the cursor.
 11
 12	Commands:
 13	:Correct {word}
 14		Add a correction for {word}.
 15
 16							*typecorr-settings*
 17	This plugin doesn't have any settings.

The first line is actually the only one for which the format matters.  It will
be extracted from the help file to be put in the "LOCAL ADDITIONS:" section of
help.txt |local-additions|.  The first "*" must be in the first column of the
first line.  After adding your help file do ":help" and check that the entries
line up nicely.

You can add more tags inside ** in your help file.  But be careful not to use
existing help tags.  You would probably use the name of your plugin in most of
them, like "typecorr-settings" in the example.

Using references to other parts of the help in || is recommended.  This makes
it easy for the user to find associated help.


FILETYPE DETECTION					*plugin-filetype*

If your filetype is not already detected by Vim, you should create a filetype
detection snippet in a separate file.  It is usually in the form of an
autocommand that sets the filetype when the file name matches a pattern.
Example: >

	au BufNewFile,BufRead *.foo			set filetype=foofoo

Write this single-line file as "ftdetect/foofoo.vim" in the first directory
that appears in 'runtimepath'.  For Unix that would be
"~/.vim/ftdetect/foofoo.vim".  The convention is to use the name of the
filetype for the script name.

You can make more complicated checks if you like, for example to inspect the
contents of the file to recognize the language.  Also see |new-filetype|.


SUMMARY							*plugin-special*

Summary of special things to use in a plugin:

s:name			Variables local to the script.

<SID>			Script-ID, used for mappings and functions local to
			the script.

hasmapto()		Function to test if the user already defined a mapping
			for functionality the script offers.

<Leader>		Value of "mapleader", which the user defines as the
			keys that plugin mappings start with.

:map <unique>		Give a warning if a mapping already exists.

:noremap <script>	Use only mappings local to the script, not global
			mappings.

exists(":Cmd")		Check if a user command already exists.

==============================================================================
*41.12*	Writing a filetype plugin	*write-filetype-plugin* *ftplugin*

A filetype plugin is like a global plugin, except that it sets options and
defines mappings for the current buffer only.  See |add-filetype-plugin| for
how this type of plugin is used.

First read the section on global plugins above |41.11|.  All that is said there
also applies to filetype plugins.  There are a few extras, which are explained
here.  The essential thing is that a filetype plugin should only have an
effect on the current buffer.


DISABLING

If you are writing a filetype plugin to be used by many people, they need a
chance to disable loading it.  Put this at the top of the plugin: >

	" Only do this when not done yet for this buffer
	if exists("b:did_ftplugin")
	  finish
	endif
	let b:did_ftplugin = 1

This also needs to be used to avoid that the same plugin is executed twice for
the same buffer (happens when using an ":edit" command without arguments).

Now users can disable loading the default plugin completely by making a
filetype plugin with only this line: >

	let b:did_ftplugin = 1

This does require that the filetype plugin directory comes before $VIMRUNTIME
in 'runtimepath'!

If you do want to use the default plugin, but overrule one of the settings,
you can write the different setting in a script: >

	setlocal textwidth=70

Now write this in the "after" directory, so that it gets sourced after the
distributed "vim.vim" ftplugin |after-directory|.  For Unix this would be
"~/.vim/after/ftplugin/vim.vim".  Note that the default plugin will have set
"b:did_ftplugin", but it is ignored here.


OPTIONS

To make sure the filetype plugin only affects the current buffer use the >

	:setlocal

command to set options.  And only set options which are local to a buffer (see
the help for the option to check that).  When using |:setlocal| for global
options or options local to a window, the value will change for many buffers,
and that is not what a filetype plugin should do.

When an option has a value that is a list of flags or items, consider using
"+=" and "-=" to keep the existing value.  Be aware that the user may have
changed an option value already.  First resetting to the default value and
then changing it is often a good idea.  Example: >

	:setlocal formatoptions& formatoptions+=ro


MAPPINGS

To make sure mappings will only work in the current buffer use the >

	:map <buffer>

command.  This needs to be combined with the two-step mapping explained above.
An example of how to define functionality in a filetype plugin: >

	if !hasmapto('<Plug>JavaImport;')
	  map <buffer> <unique> <LocalLeader>i <Plug>JavaImport;
	endif
	noremap <buffer> <unique> <Plug>JavaImport; oimport ""<Left><Esc>

|hasmapto()| is used to check if the user has already defined a map to
<Plug>JavaImport;.  If not, then the filetype plugin defines the default
mapping.  This starts with |<LocalLeader>|, which allows the user to select
the key(s) he wants filetype plugin mappings to start with.  The default is a
backslash.
"<unique>" is used to give an error message if the mapping already exists or
overlaps with an existing mapping.
|:noremap| is used to avoid that any other mappings that the user has defined
interferes.  You might want to use ":noremap <script>" to allow remapping
mappings defined in this script that start with <SID>.

The user must have a chance to disable the mappings in a filetype plugin,
without disabling everything.  Here is an example of how this is done for a
plugin for the mail filetype: >

	" Add mappings, unless the user didn't want this.
	if !exists("no_plugin_maps") && !exists("no_mail_maps")
	  " Quote text by inserting "> "
	  if !hasmapto('<Plug>MailQuote;')
	    vmap <buffer> <LocalLeader>q <Plug>MailQuote;
	    nmap <buffer> <LocalLeader>q <Plug>MailQuote;
	  endif
	  vnoremap <buffer> <Plug>MailQuote; :s/^/> /<CR>
	  nnoremap <buffer> <Plug>MailQuote; :.,$s/^/> /<CR>
	endif

Two global variables are used:
|no_plugin_maps|	disables mappings for all filetype plugins
|no_mail_maps|		disables mappings for the "mail" filetype


USER COMMANDS

To add a user command for a specific file type, so that it can only be used in
one buffer, use the "-buffer" argument to |:command|.  Example: >

	:command -buffer  Make  make %:r.s


VARIABLES

A filetype plugin will be sourced for each buffer of the type it's for.  Local
script variables |s:var| will be shared between all invocations.  Use local
buffer variables |b:var| if you want a variable specifically for one buffer.


FUNCTIONS

When defining a function, this only needs to be done once.  But the filetype
plugin will be sourced every time a file with this filetype will be opened.
This construct makes sure the function is only defined once: >

	:if !exists("*s:Func")
	:  function s:Func(arg)
	:    ...
	:  endfunction
	:endif
<

UNDO						*undo_indent* *undo_ftplugin*

When the user does ":setfiletype xyz" the effect of the previous filetype
should be undone.  Set the b:undo_ftplugin variable to the commands that will
undo the settings in your filetype plugin.  Example: >

	let b:undo_ftplugin = "setlocal fo< com< tw< commentstring<"
		\ .. "| unlet b:match_ignorecase b:match_words b:match_skip"

Using ":setlocal" with "<" after the option name resets the option to its
global value.  That is mostly the best way to reset the option value.

This does require removing the "C" flag from 'cpoptions' to allow line
continuation, as mentioned above |use-cpo-save|.

For undoing the effect of an indent script, the b:undo_indent variable should
be set accordingly.


FILE NAME

The filetype must be included in the file name |ftplugin-name|.  Use one of
these three forms:

	.../ftplugin/stuff.vim
	.../ftplugin/stuff_foo.vim
	.../ftplugin/stuff/bar.vim

"stuff" is the filetype, "foo" and "bar" are arbitrary names.


SUMMARY							*ftplugin-special*

Summary of special things to use in a filetype plugin:

<LocalLeader>		Value of "maplocalleader", which the user defines as
			the keys that filetype plugin mappings start with.

:map <buffer>		Define a mapping local to the buffer.

:noremap <script>	Only remap mappings defined in this script that start
			with <SID>.

:setlocal		Set an option for the current buffer only.

:command -buffer	Define a user command local to the buffer.

exists("*s:Func")	Check if a function was already defined.

Also see |plugin-special|, the special things used for all plugins.

==============================================================================
*41.13*	Writing a compiler plugin		*write-compiler-plugin*

A compiler plugin sets options for use with a specific compiler.  The user can
load it with the |:compiler| command.  The main use is to set the
'errorformat' and 'makeprg' options.

Easiest is to have a look at examples.  This command will edit all the default
compiler plugins: >

	:next $VIMRUNTIME/compiler/*.vim

Use |:next| to go to the next plugin file.

There are two special items about these files.  First is a mechanism to allow
a user to overrule or add to the default file.  The default files start with: >

	:if exists("current_compiler")
	:  finish
	:endif
	:let current_compiler = "mine"

When you write a compiler file and put it in your personal runtime directory
(e.g., ~/.vim/compiler for Unix), you set the "current_compiler" variable to
make the default file skip the settings.
							*:CompilerSet*
The second mechanism is to use ":set" for ":compiler!" and ":setlocal" for
":compiler".  Vim defines the ":CompilerSet" user command for this.  However,
older Vim versions don't, thus your plugin should define it then.  This is an
example: >

  if exists(":CompilerSet") != 2
    command -nargs=* CompilerSet setlocal <args>
  endif
  CompilerSet errorformat&		" use the default 'errorformat'
  CompilerSet makeprg=nmake

When you write a compiler plugin for the Vim distribution or for a system-wide
runtime directory, use the mechanism mentioned above.  When
"current_compiler" was already set by a user plugin nothing will be done.

When you write a compiler plugin to overrule settings from a default plugin,
don't check "current_compiler".  This plugin is supposed to be loaded
last, thus it should be in a directory at the end of 'runtimepath'.  For Unix
that could be ~/.vim/after/compiler.

==============================================================================
*41.14*	Writing a plugin that loads quickly	*write-plugin-quickload*

A plugin may grow and become quite long.  The startup delay may become
noticeable, while you hardly ever use the plugin.  Then it's time for a
quickload plugin.

The basic idea is that the plugin is loaded twice.  The first time user
commands and mappings are defined that offer the functionality.  The second
time the functions that implement the functionality are defined.

It may sound surprising that quickload means loading a script twice.  What we
mean is that it loads quickly the first time, postponing the bulk of the
script to the second time, which only happens when you actually use it.  When
you always use the functionality it actually gets slower!

Note that since Vim 7 there is an alternative: use the |autoload|
functionality |41.15|.

The following example shows how it's done: >

	" Vim global plugin for demonstrating quick loading
	" Last Change:	2005 Feb 25
	" Maintainer:	Bram Moolenaar <Bram@vim.org>
	" License:	This file is placed in the public domain.

	if !exists("s:did_load")
		command -nargs=* BNRead  call BufNetRead(<f-args>)
		map <F19> :call BufNetWrite('something')<CR>

		let s:did_load = 1
		exe 'au FuncUndefined BufNet* source ' .. expand('<sfile>')
		finish
	endif

	function BufNetRead(...)
		echo 'BufNetRead(' .. string(a:000) .. ')'
		" read functionality here
	endfunction

	function BufNetWrite(...)
		echo 'BufNetWrite(' .. string(a:000) .. ')'
		" write functionality here
	endfunction

When the script is first loaded "s:did_load" is not set.  The commands between
the "if" and "endif" will be executed.  This ends in a |:finish| command, thus
the rest of the script is not executed.

The second time the script is loaded "s:did_load" exists and the commands
after the "endif" are executed.  This defines the (possible long)
BufNetRead() and BufNetWrite() functions.

If you drop this script in your plugin directory Vim will execute it on
startup.  This is the sequence of events that happens:

1. The "BNRead" command is defined and the <F19> key is mapped when the script
   is sourced at startup.  A |FuncUndefined| autocommand is defined.  The
   ":finish" command causes the script to terminate early.

2. The user types the BNRead command or presses the <F19> key.  The
   BufNetRead() or BufNetWrite() function will be called.

3. Vim can't find the function and triggers the |FuncUndefined| autocommand
   event.  Since the pattern "BufNet*" matches the invoked function, the
   command "source fname" will be executed.  "fname" will be equal to the name
   of the script, no matter where it is located, because it comes from
   expanding "<sfile>" (see |expand()|).

4. The script is sourced again, the "s:did_load" variable exists and the
   functions are defined.

Notice that the functions that are loaded afterwards match the pattern in the
|FuncUndefined| autocommand.  You must make sure that no other plugin defines
functions that match this pattern.

==============================================================================
*41.15*	Writing library scripts			*write-library-script*

Some functionality will be required in several places.  When this becomes more
than a few lines you will want to put it in one script and use it from many
scripts.  We will call that one script a library script.

Manually loading a library script is possible, so long as you avoid loading it
when it's already done.  You can do this with the |exists()| function.
Example: >

	if !exists('*MyLibFunction')
	   runtime library/mylibscript.vim
	endif
	call MyLibFunction(arg)

Here you need to know that MyLibFunction() is defined in a script
"library/mylibscript.vim" in one of the directories in 'runtimepath'.

To make this a bit simpler Vim offers the autoload mechanism.  Then the
example looks like this: >

	call mylib#myfunction(arg)

That's a lot simpler, isn't it?  Vim will recognize the function name and when
it's not defined search for the script "autoload/mylib.vim" in 'runtimepath'.
That script must define the "mylib#myfunction()" function.

You can put many other functions in the mylib.vim script, you are free to
organize your functions in library scripts.  But you must use function names
where the part before the '#' matches the script name.  Otherwise Vim would
not know what script to load.

If you get really enthusiastic and write lots of library scripts, you may
want to use subdirectories.  Example: >

	call netlib#ftp#read('somefile')

For Unix the library script used for this could be:

	~/.vim/autoload/netlib/ftp.vim

Where the function is defined like this: >

	function netlib#ftp#read(fname)
		"  Read the file fname through ftp
	endfunction

Notice that the name the function is defined with is exactly the same as the
name used for calling the function.  And the part before the last '#'
exactly matches the subdirectory and script name.

You can use the same mechanism for variables: >

	let weekdays = dutch#weekdays

This will load the script "autoload/dutch.vim", which should contain something
like: >

	let dutch#weekdays = ['zondag', 'maandag', 'dinsdag', 'woensdag',
		\ 'donderdag', 'vrijdag', 'zaterdag']

Further reading: |autoload|.

==============================================================================
*41.16*	Distributing Vim scripts			*distribute-script*

Vim users will look for scripts on the Vim website: http://www.vim.org.
If you made something that is useful for others, share it!

Vim scripts can be used on any system.  There might not be a tar or gzip
command.  If you want to pack files together and/or compress them the "zip"
utility is recommended.

For utmost portability use Vim itself to pack scripts together.  This can be
done with the Vimball utility.  See |vimball|.

It's good if you add a line to allow automatic updating.  See |glvs-plugins|.

==============================================================================

Következő fejezet: |usr_42.txt|  Add new menus

Jogi információk: lásd |manual-copyright|  vim:tw=78:ts=8:noet:ft=help:norl:
