*Usr_41.txt*	Vim Verzió 8.2.	Utolsó módosítás: 2022 Jan 01


		  Bram Moolenaar: Vim felhasználói kézikönyv

				Vim szkriptek


A Vim szkriptnyelv a vimrc fájl leírónyelve és még sok egyéb másé. A fejezet
elmagyarázza, hogy milyen elemeket használhatunk Vim szkriptben. Elég sokat,
ezért a fejezet hosszú

|41.1|	Bevezetés
|41.2|	Változók
|41.3|	Kifejezések
|41.4|	Feltételek
|41.5|	Kifejezések futtatása
|41.6|	Függvények használata
|41.7|	Függvények definiálása
|41.8|	Listák és szótárak
|41.9|	Kivételek
|41.10|	Általános információk
|41.11|	Beépülő írása
|41.12|	Filetype beépülő írása
|41.13|	Compiler beépülő írása
|41.14|	A gyors beépülő ismérvei
|41.15|	Szkript könyvtárak írása
|41.16|	Vim szkriptek megosztása

Következő fejezet: |usr_42.txt|  Új menüelemek hozzáadása
    Előző fejezet: |usr_40.txt|  Új parancsok létrehozása
  Tartalomjegyzék: |usr_toc.txt|

==============================================================================
*41.1*	Bevezetés			     	   *vim-script-intro* *script*
					     *vim-szkript-bevezetés* *szkript*

A Vim szkripttél való első találkozásod a vimrc fájl. Induláskor a szerkesztő
olvassa a fájl tartalmát. Olyan opciókat állíthatsz be, amilyeneket szeretnél.
Bármilyen ":" parancsot használhatsz, ezekre Ex parancsok, vagy command-line
parancsok néven hivatkozhatunk.

   A szintaxis kiemelés fájljai szintén Vim szkriptek, melyek csak
meghatározott opciókat állítanak be adott fájltípus esetén.  Egy bonyolult
makróra tekinthetünk úgy, mint egy különálló Vim szkript fájlt.

	Ha van tapasztalatod a Pythonnal, akkor itt találhatsz egy rövid
	összehasonlítást, pointerekkel és egyéb dokumentumokkal.
	   https://gist.github.com/yegappan/16d964a37ead0979b05e655aa036cad0
	Ha a JavaScriptben vagy járatos.:
	   https://w0rp.com/blog/post/vim-script-for-the-javascripter/

A Vim szkripteknek két típusa van: a régi és a |Vim9|. Mivel a kézikönyv a
kezdő felhasználók számára íródott, ezért az újabb, |Vim9| szintaxis kerül
bemutatásra.

A Vim szkriptek kipróbálásához írjuk egy szkript fájlt, majd sourceoljuk azt
(ez a legegyszerűbb módszer a kipróbálására). Gyakrolatilag: >

	:edit test.vim
	[insert the script lines you want]
	:w
	:source %
< 
Kezdjük egy egyszerű példával: >

	vim9script
	var i = 1
	while i < 5
	  echo "count is" i
	  i += 1
	endwhile
<
A példa kimenete:

	count is 1 ~
	count is 2 ~
	count is 3 ~
	count is 4 ~

Az első sorban található vim9script parancs világossá teszi, hogy a Vim9
szkript verzióját használjuk, amely a teljes fájlra érvényes lesz.

A `var i=1` parancs deklarálja az "i" változót és inicializálja azt. Az
általános alakja:  
>
	var {name} = {expression}

A példában a változó neve "i" a kifejezés pedig egy szimpla érték: 1.

A ":while" parancs elkezdi a ciklust. Általános alakja: >

	while {condition}
	  {statements}
	endwhile

A kódblokk a ciklust végét jelző "endwhile" parancsig tart, a köztes
kódrészlet pedig addig fut, amíg a feltétel (condition) igaz. Az alkalmazott
feltétel: "i < 5", mely igaz, ha i kisebb, mint öt.
	Megjegyzés:
	Ha véletlenül végtelen ciklust írunk, akkor a CTRL-C billentyűvel
	(CTRL-Break Ms-Windows) szakíthatjuk meg.

Az `echo` parancs kiírja az argumentumait. Ebben az esetben a stringet "count
is" és az i változó értékét. Mivel i értéke egy, ezért a kimenet:

	count is 1 ~

majd következik az "i += 1" parancs, mely egyenértékű a "i = i + 1"
paranccsal. A kifejezés i változó értékét megnöveli eggyel.

A fenti példában lévő ciklus csak szemléltetés volt. Azonban minek írnánk
ilyen szintaktikával egy ciklust, ha ezt kompaktabban is megtehetjük:
>
	for i in range(1, 4)
	  echo "count is" i
	endfor

Most nem térünk ki a |for| és |range()| működési elveire. Kövesd a linkeket,
ha türelmetlen vagy.


NÉGYFÉLE SZÁM

A számok lehetnek decimálisak, hexadecimálisak, oktálisak és binárisak.

A hexadecimális számok "0x", vagy "0X"-el kezdődne. Például "0x1f" a
decimálist 31 megfelelője.

Az oktális számok: "0o", "0O". "0o17" decimális számrendszerben 15.

A bináris számok kezdete "0b" vagy "0B". Például "0b101", ami decimális
számrendszerben 5.

A decimális számok csak szám karakterekből állnak. Óvatosan: a régi verziójú
szkriptben ne tegyünk vezető nullát a szám elé, különben a Vimszkript oktális
számnak fogja tekinteni!

Az `echo` parancs mindig kiértékeli az argumentumait és minden esetben
decimális számokat ír ki. Például:   >

	echo 0x7f 0o36
<	127 30 ~

A számokat egy mínusz jellel negatív számokká alakíthatjuk, mely működik
hexadecimális, oktális és bináris számok esetén is. Például:
>
	echo -0x7f 
<	-127 ~

A negatív előjelet kivonáshoz is használhatjuk, mely néha zavaró lehet. Ha
mindkét szám elé negatív előjelet teszünk, akkor hibaüzenetet kapunk: 
>
	echo -0x7f -0o36
<	E1004: White space required before and after '-' at "-0o36" ~

Megjegyzés: Ha nem |Vim9| szkriptet használunk, akkor a prancsok
kipróbálásához futtassuk őket direkt módon, így a régi verziójú szkript
szerint értelmeződnek. Végül az echo parancs a második negatív előjelet
kivonásként fogja értelmezni. A hibaüzenet kiváltásához prefixáljuk a
parancsot `vim9cmd`-vel: >

	vim9cmd echo -0x7f -0o36
<	E1004: White space required before and after '-' at "-0o36" ~

Az üres karaktereke használatával (szóköz) a kódot olvashatóbbá tehetjük, mely
segíti a hibamegelőzést. Az gondolnánk, hogy a "-0o36" negatív számként
értelmeződik, holott valójában kivonásként.

Ahhoz, hogy valójában negatív számot jelentsen, tegyük azt zárójelbe: >

	echo -0x7f (-0o36)

==============================================================================
*41.2*	Változók

A változónevek ASCII karakterekből, számokból és "_" jelből állhat. Nem
kezdődhet számmal. Érvényes változónevek:

	counter
	_aap3
	very_long_variable_name_with_underscores
	FuncLength
	LENGTH

Érvénytelen nevek: "foo+bar" and "6var".

Néhány változó globális. A jelenleg definiált globális változók listája: >

	:let

A globális változókat bárhol használhatjuk, viszont nagyon egyszerű két
különálló szkripteben két azonos nevű változó deklarálása. Ezért
megkülönböztetünk globális és lokális változókat. Például az alábbi szerepel a
"script1.vim" fájlunkban: >

	vim9script
	var counter = 5
	echo counter
<	5 ~

Ha ezt a "script2.vim" fájlunkban szeretnénnk használni, akkor: >

	vim9script
	echo counter
<	E121: Undefined variable: counter ~

Lokális változó használata esetén biztosíthatjuk, hogy csak az a szkript
legyen képes módosítani a változót, amelyben deklaráltuk.

Ha meg szeretnénk osztani egy változót két szkript között, akkor a "g:"
prefixumot kell használnunk, ne használjuk a `var` kulcsszót. Ezért
"script1.vim": >

	vim9script
	g:counter = 5
	echo g:counter
<	5 ~

És "script2.vim": >

	vim9script
	echo g:counter
<	5 ~

A lokális változókról még többet megtudhatunk: |script-variable|.

Ennél azonban több változótípus létezik:  |internal-variables|. A
leggyakrabban használt típusok (névtér szerint):

	b:name		csak a buffer számára érhető el
	w:name		csak az ablak számára érhető el
	g:name		globális változó (függvényekben is)
	v:name		a Vim által definiált változók


VÁLTOZÓ TÖRLÉSE

A változók a memóriában tárolódnak a `let` parancs által. Változó törléséhez
használjuk az `unlet` parancsot. Például:  >

	unlet g:counter

Ez törli a szkript globális "g:counter" változóját, helyet szabadítva fel a
memóriában. Ha nem vagyunk benne biztosak, hogy egy adott változó létezik, és
például nem szeretnénk hibaüzenetet kapna, ha mégsem létezne, akkor használjuk
a "!" jelet: >

	:unlet! g:counter

A Vim9 szkriptben nem használhatjuk az `unlet` parancsot a szkript lokális
változóira. A régi verzióban viszont igen. 

Ha a szkript lefutott, a lokális változó nem törlődik. A függvények tovább
használhatják őket. Például: >
>
	vim9script
	var counter = 0
	def g:GetCount(): number
	  s:counter += 1
	  return s:counter
	enddef

Minden alkalommal, ha meghívjuk a függvényt, akkor visszatér a következő count
értékkel: >
	:echo g:GetCount()
<	1 ~
>
	:echo g:GetCount()
<	2 ~

Ha aggódunk amiatt, hogy a lokális változók túl sok memóriát foglalnának,
akkor állítsuk az értéküket üres értékre, ha már nincs szükség rájuk.

Megjegyzés: a továbbiakban nem tüntetjük fel a `vim9script` sort az
olvashatóság miatt, azonban ezt nekünk meg kell tenni a szkriptfájlunk első
sorában. >

STRING VÁLTOZÓK ÉS KONSTANSOK

Eddig a változókhoz csak számokat rendeltünk. Stringeket is használhatunk. A
számok és  stringek az alaptípusok, melyeket a Vim támogat. Például: >

	var name = "Peter"
	echo name
<	Peter ~

Minden változónak van típusa. Gyakran, mint ebben a példában is, a típus az
értékadás dönti el. Ha nem szeretnénk a változónak értéket adni, akkor a
típusát minimum meg kell adnunk: >

	var name: string
	var age: number
	...
	name = "Peter"
	age = 42


Ha a változónak típusának nem megfelelő értéket adunk, akkor hibaüzenetet
kapunk. >
	
	age = "Peter"
<	E1012: Type mismatch; expected number but got string ~

A típusokról bővebben a |41.8| pontban.

A változó értékéhez úgy tudunk egy string értéket rendelni, hogy a string
konstansot használjuk. Ennek két típusa van. Az első ha a string már dupla
idézőjelek között van, mint ahogyan azt már láthattuk. Ha a stringben dupla
idézőjelet szeretnénk használni, akkor tegyünk elé visszaperjelet: >

	var name = "he is \"Peter\""
	echo name
<	he is "Peter" ~

A visszaperjel használata elkerülhető, ha stringet aposztrófok közé foglaljuk:
>
	var name = 'he is "Peter"'
	echo name
<	he is "Peter" ~

Az aposztrófos 'stringekben ' minden karakter reprezentálódik. Csak és
kizárólag az aposztróf speciális: kettőt kell használjunk '', hogy egy
megjelenjen. A \ szó szerint értelmeződik (karakterként), azért nem
használható arra, hogy az azt követő karaktert megváltoztassuk: >

	var name = 'P\e''ter'''
	echo name
<	P\e'ter' ~

Az "idézőjeles" stringekben a speciális karakterek használata megengedett,
néhány hasznos belőlük:

	\t		<Tab>
	\n		<NL>, sortörés
	\r		<CR>, <Enter>
	\e		<Esc>
	\b		<BS>, backspace
	\"		"
	\\		\, backslash
	\<Esc>		<Esc>
	\<C-W>		CTRL-W

Az utolsó kettő csak példa. A "\<name>" formátumot használjuk a "name"
billentyű reprezentálására.

Lásd |expr-quote| a stringekben használható speciális karakterek teljes
listája.

==============================================================================
*41.3*	Kifejezések

A vim viszonylag sztenderd de mégis egyszerű módon kezeli a kifejezéseket. A
definíciót itt elolvashatod: |expressions-syntax|. Itt bemutatjuk a
leggyakoribb elemeket.

    A számok, stringek és változók melyeket fent láthattunk, már önmagukban is
kifejezések. Ezért bárhol, ahol kifejezés az elvárt érték, használhatod őket.
Alapvető kifejezések továbbá:

	$NAME		Környezeti változó
	&name		opció
	@r		regiszter

Példa: >

	echo "The value of 'tabstop' is" &ts
	echo "Your home directory is" $HOME
	if @a == 'text'

A &name alakot az opció értékének tárolására használjuk, új értéket adunk
neki, csinálunk valamit és visszaállítjuk a régi értékére. Például: >

	var save_ic = &ic
	set noic
	s/The Start/The Beginning/
	&ic = save_ic

Így biztosak lehetünk benne, hogy a "The Start" minta használatakor az 'ignorecase' opció ki lesz kapcsolva.
Ráadásul még meg is tartja a régi értékét, amit a felhasználó beállított. (Egy
másik módja ennek a "\C" hozzáadása lett volna a mintához, lásd |/\C|.)


MATEMATIKA

Még érdekesebbé válik, ha az alapelemeket elkezdjük kombinálni. Kezdjük a
számokon végzett matematikai műveletekkel:

	a + b		add
	a - b		subtract
	a * b		multiply
	a / b		divide
	a % b		modulo

A műveleti sorrend a szokásos. Például:   >

	echo 10 + 5 * 2
<	20 ~

A műveletek csoportosíthatóak zárójelekkel. Semmi extra. Például:   >

	echo (10 + 5) * 2
<	30 ~

A stringeket konkatenálhatjuk az ".." operátorral (lásd |expr6|). Például:   >

	echo "foo" .. "bar"
<	foobar ~

Ha az `echo` parancs több argumentumot kap, akkor elválasztja őket szóközzel.
A példában az argumentum egy egyszerű kifejezés, ezért nincs szóköz közötte.

A C nyelvből kölcsönözve a feltételes kifejezés: >

	a ? b : c

Ha "a" igazra értékelődik ki, akkor "b"-t használjuk, egyébként pedig "c"-t.
Például:   >

	var nr = 4
	echo nr > 5 ? "nr is big" : "nr is small"
<	nr is small ~

A három kifejezés először mindig kiértékelődik, ezért így is ábrázolhatnánk:

	(a) ? (b) : (c)

==============================================================================
*41.4*	Feltételek

Az `if` parancs lefuttatja a kódblokkot az `endif`-ig, de csak akkor, ha a
feltétel teljesül. Az általános alakja:

	if {condition}
	   {statements}
	endif

Csak ha {condition} kifejezés igazzá értékelődik ki (nem nulla), akkor a
{statement} rész lefut, melyeknek maguknak is érvényes kifejezéseknek kell
lenniük, különben. Ha szemetet tartalmaznak, akkor a Vim nem fogja megtalálni
az `endif` parancsot.

Használhatunk `else`-t is. Általános alakja:

	if {condition}
	   {statements}
	else
	   {statements}
	endif

Végül pedig az `elseif`:

	if {condition}
	   {statements}
	elseif {condition}
	   {statements}
	endif

Működése tökéletesen megegyezik az `else` és `if` használatával, de anélkül,
hogy egy extra `endif`-et feltüntetnénk. >

Hasznos ellenőrzés lehet a vimrc fájlunkban, a 'term' opció értéke, majd annak
értéktől függően futtathatunk valamit: >

	if &term == "xterm"
	  # Do stuff for xterm
	elseif &term == "vt100"
	  # Do stuff for a vt100 terminal
	else
	  # Do something for other terminals
	endif

A "#" karakter a komment kezdetét jelenti, de erről később.

LOGIKAI OPERÁTOROK

Némelyiket már használtuk. Itt vannak a leggyakoribbak:

	a == b		egyenlő
	a != b		nem egyenlő
	a >  b		nagyobb, mint
	a >= b		nagyobb, vagy egyenlő, mint
	a <  b		kisebb, mint
	a <= b		kisebb, vagy egyenlő, mint

A végeredmény true, ha a feltétel teljesül, és false, ha nem. Például:   >

	if v:version >= 700
	  echo "congratulations"
	else
	  echo "you are using an old version, upgrade!"
	endif

Itt a "v:version" változót a Vim definiálta, melynek tartalma a Vim verziója.
600 a 6.0-ás verzióhoz. A 6.1 verzió 601 lenne. Így verzió specifikus
szkripteket tudunk létrehozni |v:version|.

A logikai operátorok számok és stringek esetén is működik. Ha két stringet
hasonlítunk össze, akkor a matematikai különbséget kapjuk. Az eredmény a
bájtok összehasonlításával keletkezik, így nyelvek és nyelvek között a kimenet
eltérhet.

Ha egy stringet számmal szeretnénk összehasonlítani, akkor hibaüzenetet
kapunk.

Stringek összehasonlítására a további két operátor áll rendelkezésre:

	str =~ pat		egyezik
	str !~ pat		nem egyezik

A bal oldali "str"-t stringként használjuk. A jobb oldalon szereplő "pat"
mintaként van használva, mintha keresnénk. Például:   >

	if str =~ " "
	  echo "str contains a space"
	endif
	if str !~ '\.$'
	  echo "str does not end in a full stop"
	endif

Figyeljünk arra, hogy a keresési mintát aposztrófok közé zártuk, így nem kell
escapelnünk \ karakterrel (amit idézőjelek esetén meg kellett volna tenni).

Ha egy teljes stringet szeretnénk, akkor kezdjük a mintát "^"-el és zárjuk
"$"-al.

Az 'ignorecase' opció nincs hatással a stringek összehasonlítására.

Ha ezt nem szeretnénk, akkor fűzzük hozzá a "?" karaktert.  Ezért "==?" két
stringet hasonlít össze a betűérzékenységet figyelmen kívül hagyva.  A teljes
táblázathoz lásd |expr-==|.


MÉG TÖBB CIKLUS

A `while` ciklust már említettük. Két parancsot használhatunk a ciklusban (a
`while` és `endwhile` között):

	continue		Visszaugrik a while ciklus kezdetéhez és
				folytatja azt
	break			a vezérlés az `endwhile`-ra ugrik, a ciklus
				megszakad

Például:  >

	var counter = 1
	while counter < 40
	  if skip_number(counter)
	    continue
	  endif
	  if last_number(counter)
	    break
	  endif
	  sleep 50m
	  ++counter
	endwhile

A `sleep` paranccsal a szkript futtatását függeszthetjük fel. Az "50m" ötven
milliszekondumot jelent. Másik példa a `sleep 4`, mely négy másodpercig tart.

A `for` paranccsal további ciklusokat hozhatunk létre, lásd |41.8|.

==============================================================================
*41.5*	Kifejezés futtatása

Eddig a parancsokat a Vimben adtuk ki. Az `execute` paranccsal lefuttathatjuk
a kifejezés értékét, mellyel bonyolult parancsokat is írhatunk.

   Például ugrás taghez, melyet a változó tartalmaz: >

	:execute "tag " .. tag_name

A ".." operátorral fűztük össze a "tag " stringet a "tag_name" változóval.
Feltételezzük, hogy a "tag_name" értéke "get_cmd", mely kiértékelés után: >

	tag get_cmd

Az `execute` parancs csak ":" futtatására alkalmas. A `normal` parancs a
Normal módú parancsokat tudja futtatni. Bár az argumentum nem egy kifejezés
értéke, stringként adjuk át a ":normal" parancsnak. Például:   >

	normal gg=G

A parancs az első sorra ugrik gg-vel és formázza az összes sort a "="
operátorral és G tartománnyal.

`normal` módban úgy dolgozhatunk kifejezéssel, hogy átadjuk az `execute`
parancsnak. Például:   >

	execute "normal " .. count .. "j"

A parancs lejjebb viszi a kurzort "count" értékkel.

Győződjünk meg arról, hogy a ":normal" parancsnak átadott argumentum teljes
értékű parancs. Például, törlő operátorral kezdtük a parancsot, akkor egy
elmozdulást is meg kell adnunk.
Így működik: >

	normal d$

Ez nem csinál semmit: >

	normal d
<
Ha Insert módban kezdünk és nem Esc billentyűvel fejezzük be, nem kilépünk
belőle.  Az alábbi beilleszti a "new text" stringet: >

	execute "normal inew text"

Ha Isert mód után még normál módban tenni szeretnénk avalamit, akkor el kell
hagyjuk az Insert módot: >

	execute "normal Inew text \<Esc>"

Futtatás beilleszti a "new text" szöveget az aktív sorba. Figyeljük meg a
speciális billentyűk használatát: a "\<Esc>" a normál módba küldi a
billentyűleütést, és közvetlenül a szkriptnek (<Esc> a szkriptben azonnal
értelmeződne).

Ha nem szeretnénk egy stringet futtatni, csak kiértékelni a kifejezés értékét,
akkor az eval() függvényt használhatjuk: >

	var optname = "path"
	var optvalue = eval('&' .. optname)

A "&" karaktert a "path" elé fűztük, ezért az eval() függvény argumentumként a
"&path"-t kapja. Az eredmény pedig a 'path' opció értéke lesz.

==============================================================================
*41.6*	Függvények használata

A Vim a beépített függvényei révén hatalmas funkcionalitást biztosít. Néhány
példán keresztül ezt bemutatjuk. A teljes függvénylista: |functions|.

Függvényeket a ":call" paranccsal hívhatunk. A paramétereket a zárójelek
között kell átadnunk vesszővel elválasztva. Például:   >

	:call search("Date: ", "W")

Ez meghívja a search() függvényt a "Date: " és a "W" argumentumokkal. A search
függvény első paramétere a keresési minta, a második pedig a flag. A "W" flag
azt jelenti, hogy a keresés nem folytatódik a fájl végéhez érve.

A függvényeket kifejezésekben is meghívhatjuk. Például:   >

	:let line = getline(".")
	:let repl = substitute(line, '\a', "*", "g")
	:call setline(".", repl)

A getline() függvény a buffer egy sorával tér vissza. Argumentumként a sor
számát várja. A példában "."-t használtunk, mely a kurzor sorára utal.
   A substitute() függvény a ":substitute" parancs megfelelője. Az első
argumentum a string, melyen a műveletet végezzük, második a minta, a harmadik
pedig a csere string. Végül utolsó argumentumként pedig a flag.
   A setline() függvény felülírja az első argumentumban hivatkozott sort a
második argumentumban szereplő értékkel. A példában a kurzor sorát cseréljük
le a substitute() függvény eredményével. A három kifejezés egyenlő: >

	:substitute/\a/*/g

A függvények használata akkor válik érdekesebbé, ha a substitute() hívás előtt
és után több munkát kell végeznünk.


FÜGGVÉNYEK						       *function-list*
							      *függvény-lista*

Rengeted függvény létezik. Használati jellegük alapján csoportosítottuk a
listát. A betűrendi lista itt található: |functions|. CTRL-] a függvény nevén
megnyitja a részletes leírást.

String manipuláció:					*string-functions*
							*függvények-string*
	nr2char()		karaktert ad vissza számérték alapján
	list2str()		stringet ad listában szereplő számok alapján
	char2nr()		számot ad vissza karakterből
	str2list()		stringből szám alapú listát generál
	str2nr()		stringből Számot konvertál
	str2float()		stgringből Floatot konvertál
	printf()		szöveg formázása a % elemek szerint
	escape()		karakterek escapelése a stringben '\'-el
	shellescape()		string escapelése shell parancs számára
	fnameescape()		fájlnév escapelése Vim parancs számára
	tr()			másolás karakterszettek között
	strtrans()		string nyomtathatóvá alakítása
	tolower()		string kisbetűssé alakítása
	toupper()		string nagybetűssé alakítása
	charclass()		karakter osztálya
	match()			egyezés pozíciója
	matchend()		egyezés végének a pozíciója
	matchfuzzy()		fuzzy stílusú egyezés a stringben
	matchfuzzypos()		fuzzy stílusú egyezés a stringben
	matchstr()		egyező minta értéke a stringben
	matchstrpos()		egyezés a stringben és azok pozíciója
	matchlist()		mint a  matchstr() rész egyezések is
	stridx()		first index of a short string in a long string
	strridx()		last index of a short string in a long string
	strlen()		length of a string in bytes
	strcharlen()		length of a string in characters
	strchars()		karakterek száma a stringben
	strwidth()		megjelenített string hossza
	strdisplaywidth()	megjelenített string hossza, tabokkal
	setcellwidths()		karakter-cella beállítása, felülírással
	substitute()		string helyettesítés mintával
	submatch()		rész egyezések ":s" és substitute()
	strpart()		string része (byte index alapján)
	strcharpart()		string része (char index alapján)
	slice()			string szelet (char index alapján) Vim9
	strgetchar()		string szelet (char index)
	expand()		speciális kulcsszavak kibontása
	expandcmd()		parancsok kibontása (mint az `:edit`)
	iconv()			kódolások közötti konvertálás
	byteidx()		string karakterének byte indexe
	byteidxcomp()		mint a  byteidx() alkotó karakter számít
	charidx()		byte karakterindexe stringben
	repeat()		string ismétlés
	eval()			string kifejezés kiértékelése
	execute()		Ex parancs futtatása
	win_execute()		mint az execute() de meghatározott ablakban
	trim()			karakterek trimmelése stringből
	gettext()		üzenet fordításának keresése

Lista manipuláció:					*list-functions*
							*függvények-list*
	get()			érték listából hibaüzenet nélkül (index)
	len()			listaelemek száma
	empty()			üres-e a lista
	insert()		elem beszúrása
	add()			elem hozzáfűzése
	extend()		listát listához fűz
	extendnew()		új lista, majd hozzáfűz
	remove()		egy vagy több elem eltávolítása
	copy()			shallow másolat
	deepcopy()		lista teljes másolata
	filter()		kiválasztott elemek eltávolítása
	map()			minden listaelem változtatása
	mapnew()		új lista a változott értékekkel
	reduce()		lista redukálása értékhez
	slice()			lista-szelet
	sort()			list rendezése
	reverse()		fordított sorrend
	uniq()			egyedi listaelemek
	split()			string bontása listába
	join()			listaelemek összefűzése stringgé
	range()			számsorozatból lista összeállítás
	string()		lista string reprezentációja
	call()			függvényhívás lista argumentumokkal
	index()			elem indexe a listában
	max()			lista maximum értéke
	min()			lista minimum értéke
	count()			elem gyakorisága listában
	repeat()		lista ismétlése
	flatten()		lista dimenziójának redukálása
	flattennew()		lista dimenziójának redukálása másolással

Szótár manipuláció:				*dict-functions*
					        *függvények-szótár*
	get()			bejegyzés lekérése hiba nélkül (key)
	len()			bejegyzések száma
	has_key()		kulcs ellenőrzés
	empty()			üres-e
	remove()		bejegyzés eltávolítása
	extend()		hozzáadás szótárból szótárba
	extendnew()		hozzáadás szótárból szótárba, összefűzéssel
	filter()		kiválasztott elemek eltávolítása
	map()			minden bejegyzés megváltoztatása
	mapnew()		változtatott elemekből új lista
	keys()			kulcsot listája
	values()		értékek listája
	items()			kulcs-érték párokból lista
	copy()			shallow másolat
	deepcopy()		teljes másolat
	string()		szótár string reprezentációja
	max()			szótár maximum értéke
	min()			szótár minimum értéke
	count()			elem gyakorisága

Lebegőpontos számítások:			*float-functions*
						*függvények-lebegőpontos*
	float2nr()		float számmá
	abs()			abszolút érték (Számokkal is)
	round()			kerekítés
	ceil()			kerekítés fel
	floor()			kerekítés le
	trunc()			tizedes utáni értékek eltávolítása
	fmod()			maradék
	exp()			exponenciális
	log()			természetes logaritmus (e alapú)
	log10()			10 alapú logaritmus
	pow()			négyzetre emelés
	sqrt()			négyzetgyök
	sin()			szinusz
	cos()			koszinusz
	tan()			tangens
	asin()			arc szinusz
	acos()			arc koszinusz
	atan()			arc tangens
	atan2()			arc tangens
	sinh()			hyperbolic szinusz
	cosh()			hyperbolic koszinusz
	tanh()			hyperbolic tangens
	isinf()			végtelen ellenőrzése
	isnan()			nem szám?

 
Blob manipulation:				*blob-functions*
					        *függvények-blob*
	blob2list()	    lista lekérése a blob-ból
        list2blob()	    blob lekérése a listából

Egyéb számítások:				*bitwise-function*
						*függvények-bitenkénti*
	and()			bitenkénti ÉS
	invert()		bitenkénti inverz
	or()			bitenkénti VAGY
	xor()			bitenkénti KIZÁRÓ VAGY
	sha256()		SHA-256 hash
	rand()			pseudo-random szám
	srand()			kezdeti seed, rand()

Változók:					*var-functions*
						*függvények-változók*
	type()			változó típusa számként
	typename()		változó típusa szövegként
	islocked()		változó locked állapotának ellenőrzése
	funcref()		függvényhivatkozás referencia alapján
	function()		függvényhivatkozás név lapján
	setbufvar()		buffer változójának lekérése
	getwinvar()		ablak  változójának lekérése
	gettabvar()		fül    változójának lekérése
	gettabwinvar()		ablak és fül változójának lekérése
	setwinvar()		ablak változójának beállítása
	settabvar()		fül változójának beállítása
	settabwinvar()		ablak és fül változójának beállítása
	garbagecollect()	elérhető szabad memória

Kurzor és mark pozíciók:			*cursor-functions* *mark-functions*
						*függvények-kurzor*
						*függvények-mark*
	col()			kurzor vagy mark oszlopa
	virtcol()		kurzor vagy mark virtuális sora
	line()			kurzor vagy mark sora
	wincol()		kurzor vagy mark oszlopa ablakban
	winline()		kurzor vagy mark sora ablakban
	cursor()		kurzor pozíciója sora és oszlopa
	screencol()		kurzor oszlopa a képernyőn
	screenrow()		kurzor sora a képernyőn
	screenpos()		szöveg pozíciója sor és oszlop képernyő
	getcurpos()		kurzor pozíciója
	getpos()		kurzor, mark pozíciója
	setpos()		kurzor, mark pozíciójának beállítása
	getmarklist()		globális és lokális markok
	byte2line()		byte érték sora
	line2byte()		sor byte értéke
	diff_filler()		sor fölött lévő kitöltősorok száma
	screenattr()		képernyő sorának tulajdonságai
	screenchar()		karakter kódja sor-oszlop alapján képernyő
	screenchars()		mint screenchar(), listát ad vissza
	screenstring()		mint screenchars(), stringet ad vissza
	charcol()		mint col(), karaktert ad vissza
	getcharpos()		mint getpos(), karakter indexet ad vissza
	setcharpos()		set character position of cursor, mark, etc.
	getcursorcharpos()	mint setpos(), oszlopszámmal
	setcursorcharpos()	mint cursor(), oszlopszámot használ

Munka az aktív bufferben lévő szöveggel:	*text-functions*
						*függvények-szöveg*
	getline()		sor, vagy sorok listája a bufferből
	setline()		buffer sorának cseréje
	append()		sor, vagy sorok hozzáfűzése
	indent()		behúzás
	cindent()		C stílusú behúzás
	lispindent()		Lisp stílusú behúzás
	nextnonblank()		következő nem üres sor
	prevnonblank()		előző nem üres sor
	search()		minta egyezése
	searchpos()		minta egyezésének helye
	searchcount()		egyezések száma a kurzor előtt és után
	searchpair()		másik vég, kezdet
	searchpairpos()		másik vég, kezdet
	searchdecl()		név deklarációjának keresése
	getcharsearch()		karakter keresési információi
	setcharsearch()		karakter keresési info. beállítása

Munka egy másik bufferben lévő szöveggel:
	getbufline()		buffer sorának lekérése
	setbufline()		buffer sorának cseréje
	appendbufline()		sorok hozzáfűzése a bufferhez
	deletebufline()		buffer sorainak törlése

					*system-functions* *file-functions*
					*függvények-rendszer*
					*függvények-fájl*
Rendszerfüggvények, manipuláció fájlokkal:
	glob()			fájl metakarakterek kibontása
	globpath()		mint glob(), a 'path' könyvtárait
	glob2regpat()		glob minta konvertálása keresési mintává
	findfile()		fájlkeresés
	finddir()		könyvtárkeresés
	resolve()		parancsikon, linkek feloldása
	fnamemodify()		fájl átnevezés
	pathshorten()		könyvtárnevek rövidítése a path ban
	simplify()		elérési utak egyszerűsítése
	executable()		futtatható állomány ellenőrzése
	exepath()		futtatható program teljes elérési útja
	filereadable()		ellenőrzés: fájl olvasható
	filewritable()		ellenőrzés: fájl írható
	getfperm()		fájl engedélyek
	setfperm()		fájl engedélyek beállítása
	getftype()		fájltípus lekérés
	isdirectory()		ellenőrzés: létező könyvtár
	getfsize()		fájlméret
	getcwd()		munkakönyvtár
	haslocaldir()		ellenőrzés: ablak |:lcd| vagy |:tcd|
	tempname()		ideiglenes fájl neve
	mkdir()			új könyvtár
	chdir()			könyvtárváltás
	delete()		fájl törlése
	rename()		fájl átnevezése
	system()		shell parancs kimenete stringként
	systemlist()		shell parancs kimenete listaként
	environ()		összes környezeti változó
	getenv()		egy környezeti változó
	setenv()		környezeti változó értékének beállítása
	hostname()		gép neve
	readfile()		fájl olvasása listába
	readblob()		olvasás Blobként
	readdir()		könyvtárban lévő fájlok nevei listába
	readdirex()		könyvtárban lévő fájlok információi listába
	writefile()		lista sorai vagy Blob fájlba

Dátum és Idő:				*date-functions* *time-functions*
					*függvények-dátum* *függvények-idő*
	getftime()		utolsó módosítás dátuma
	localtime()		időbélyeg másodpercben
	strftime()		idő stringgé konvertálása
	strptime()		dátum/idő string konvertálás időbélyeggé
	reltime()		pontos idő, vagy eltelt idő
	reltimestr()		reltime() konvertálása,  string
	reltimefloat()		reltime() konvertálása,  Float

			*buffer-functions* *window-functions* *arg-functions*
	      *függvények-buffer* *függvények-ablak* *függvények-argumentumok*
Bufferek, ablakok és az argumentum lista:
	argc()			argumentumlista elemeinek száma
	argidx()		argumentumlista pozíciója
	arglistid()		argumentumlista azonosítója
	argv()			argumentumlista egy eleme
	bufadd()		fájl hozzáadása a bufferek listájához
	bufexists()		ellenőrzés: buffer létezik
	buflisted()		ellenőrzés: buffer létezik és listázott
	bufload()		a buffer betöltött
	bufloaded()		ellenőrzés: buffer létezik és betöltött
	bufname()		buffer neve
	bufnr()			buffer száma
	tabpagebuflist()	bufferek listája fülről
	tabpagenr()		fülek száma
	tabpagewinnr()		mint winnr() meghat. fülön
	winnr()			aktív ablak neve
	bufwinid()		ablak ID-je buffer alapján
	bufwinnr()		ablak száma bufferből
	winbufnr()		buffer száma ablakból
	listener_add()		callback a változásokhoz
	listener_flush()	callback hívása
	listener_remove()	callback eltávolítása
	win_findbuf()		buffert tartalmazó ablak keresése
	win_getid()		ablak ID lekérés
	win_gettype()		ablak típusa
	win_gotoid()		váltás ablakra ID alapján
	win_id2tabwin()		fül és ablakszám ablak ID alapján
	win_id2win()		ablakszám ablak ID alapján
	win_splitmove()		ablak mozgatása másik ablakba (split)
	getbufinfo()		buffer információi | lista
	gettabinfo()		fül információi | lista
	getwininfo()		ablak információi | lista
	getchangelist()		változások listája | lista
	getjumplist()		jump list bejegyzések | lista
	swapinfo()		swap fájl információk
	swapname()		buffer swapfájlja

Command line:					*command-line-functions*
						*függvények-command-line*
	getcmdline()		command-line tartalma
	getcmdpos()		kurzor pozíciója a command-lineban
	setcmdpos()		kurzor pozíciójának beállítása a command-lineban
	getcmdtype()		command-line típusa
	getcmdwintype()		mint getcmdtype() visszatérhet üres stringgel
	getcompletion()		command-line kiegészítések | lista
	fullcommand()		a teljes parancs neve

Quickfix és location lista:			*quickfix-functions*
						*függvények-quickfix*
	getqflist()		quickfix hibák listája
	setqflist()		quickfix lista módosítása
	getloclist()		location lista elemeinek helye
	setloclist()		location lista módosítása

Insert mód kiegészítés:				*completion-functions*
					        *függvények-kiegészítés*
	complete()		kiegészítés
	complete_add()		kiegészítés hozzáadása
	complete_check()	ellenőrzés: kiegészítés megszakítása
	complete_info()		kiegészítésre vonatkozó információ | szótár
	pumvisible()		ellenőrzés: popup menü megjelenítve
	pum_getpos()		popup mérete és pozíciója

Foldolás:					*folding-functions*
					        *függvények-foldolás*
	foldclosed()		ellenőrzés: meghatározott sorban zárt fold
	foldclosedend()		mint foldclosed(), de az utolsó sort
				visszaadja
	foldlevel()		meghatározott sor fold szintje
	foldtext()		zárt fold megjelenített szövege
	foldtextresult()	zárt fold megjelenített szövege | string

Szintaxis és kiemelés:	    	  *syntax-functions* *highlighting-functions*
				  *függvények-kiemelés* *függvények-szintaxis*
	clearmatches()		|matchadd()| és |:match| összes egyezésének
				törlése
	getmatches()		|matchadd()| és |:match| összes egyezése
	hlexists()		ellenőrzés: highlight csoport megléte
        hlget()			kiemelés-csoportok attribútumai
        hlset()		        kiemelés-csoportok attribútumainak beállítása	
	hlID()			highlight csoport ID-je
	synID()			meghat. pozíció szintaxis ID-je
	synIDattr()		szintaxis ID attribútuma
	synIDtrans()		lefordított szintaxis ID
	synstack()		meghat. pozíció szintaxis ID listája
	synconcealed()		conceal információk
	diff_hlID()		get highlight ID for diff mode at a position
	matchadd()		kiemelési minta meghatározása
	matchaddpos()		define a list of positions to highlight
	matcharg()		|:match| argumentum információi
				|:match| által definiált egyezés törlése
	setmatches()		|getmatches()| által mentett egyezések
				visszaállítása

Helyesírás ellenőrzés:				*spell-functions*
						*függvények-helyesírás*
	spellbadword()		elgépel szó a kurzor után
	spellsuggest()		javaslatok
	soundfold()		hasonlóan hangzó szavak

History:					*history-functions*
						*függvények-előzmények*
	histadd()		elem hozzáadása a historyhoz
	histdel()		elem eltávolítása a historyból
	histget()		elem a historyból
	histnr()		history legmagasabb indexe

Interaktív:					*interactive-functions*
						*függvények-interaktív*
	browse()		fájlválasztó
	browsedir()		könyvtárválasztó
	confirm()		felhasználói megerősítése
	getchar()		karakter a felhasználótól
	getcharstr()		karakter a felhasználótól stringként
	getcharmod()		utolsó karakter módosítóbillentyűje
	getmousepos()		egér utolsó pozíciója
	echoraw()		karakter kiírása (formázatlanul)
	feedkeys()		karakter typeahead-sorba helyezése
	input()			felhasználótól bekért sor
	inputlist()		felhasználó választhat listából
	inputsecret()		felhasználó bekért sor (kimenet nélkül)
	inputdialog()		sor bekérése párbeszédablakkal
	inputsave()		mentés és typeahead törlése
	inputrestore()		typeahead visszaállítása

GUI:						*gui-functions*
					        *függvények-gui*
	getfontname()		használatban lévő betűtípus
	getwinpos()		Vim ablak pozíciója
	getwinposx()		Vim ablak X pozíciója
	getwinposy()		Vim ablak Y pozíciója
	balloon_show()		buboréksúgó
	balloon_split()		üzenet felosztása buboréksúgóban
	balloon_gettext()	buboréksúgó szövege

Vim szerver:					*server-functions*
					        *függvények-szerver*
	serverlist()		szervernevek listája
	remote_startserver()	szerver futtatása
	remote_send()		parancs küldése a szervernek
	remote_expr()		kifejezés kiértékelése a szerver
	server2client()		válasz a kliensnek
	remote_peek()		ellenőrzés: válasz a Vim szervertől
	remote_read()		válasz olvasása a Vim szervertől
	foreground()		Vim ablakot előtérbe helyez
	remote_foreground()	Vim szerver ablakot előtérbe helyez

Ablak méret és pozíció:				*window-size-functions*
						*függvények-ablak-méret*
	winheight()		ablak magassága
	winwidth()		ablak szélessége
	win_screenpos()		ablak pozíciója a képernyőn
	winlayout()		ablakelrendezés lekérése a fülről
	winrestcmd()		ablakméretek visszaállítása
	winsaveview()		aktív ablak nézete
	winrestview()		aktív ablak mentett nézetének visszaállítása

Mappek és menük:				*mapping-functions*
						*függvények-mappelés*
	digraph_get()		|digraph|
	digraph_getlist()	összes |digraph|
	digraph_set()		|digraph| beállítása
	digraph_setlist()	több |digraph| beállítása
	hasmapto()		mappelés ellenőrzése
	mapcheck()		egyező mappelés ellenőrzése
	maparg()		mapping jobb-értéke
	mapset()		map visszaállítása
	menu_info()		menüelem információi
	wildmenumode()		ellenőrzés: 'wildmenu'

Tesztelés:					*test-functions*
						*függvények-tesztelés*
	assert_equal()		két kifejezés értéke egyenlő
	assert_equalfile()	két fájl tartalma azonos
	assert_notequal()	két kifejezés értéke nem egyenlő
	assert_inrange()	kifejezés értéke tartományon belül
	assert_match()		minta illeszkedik
	assert_notmatch()	minta nem illeszkedik
	assert_false()		kifejelés hamis
	assert_true()		kifejezés igaz
	assert_exception()	kifejezés kivétel dob
	assert_beeps()		parancs hangjelzést ad
	assert_nobeep()		parancs nem ad hangjelzést
	assert_fails()		parancs hiba
	assert_report()		hibás teszt eredményének megjelenítése
	test_alloc_fail()	hibás memória-foglalás
	test_autochdir()	'autochdir' engedélyezése indításnál
	test_override()		tesztelés a Vim belső overridejaival
	test_garbagecollect_now()   memória felszabadítása most
	test_garbagecollect_soon()  flag a hamarosan felszabaduló memóriának
	test_getvalue()		belső változó értéke
	test_gui_drop_files()	fájlok ablakba ejtése
	test_gui_mouse_event()	GUI egér esemény ablakhoz rendelése
	test_ignore_error()	meghat. hibaüzenetek ignorálása
	test_null_blob()	visszatérési érték:  null Blob
	test_null_channel()	visszatérési érték:  null Channel
	test_null_dict()	visszatérési érték:  null Dict
	test_null_function()	visszatérési érték:  null Funcref
	test_null_job()		visszatérési érték:  null Job
	test_null_list()	visszatérési érték:  null List
	test_null_partial()	visszatérési érték:  null Partial function
	test_null_string()	visszatérési érték:  null String
	test_settime()		Vim belső időbélyeg
	test_setmouse()		egér pozíciójának beállítása
	test_feedinput()	billentyű-szekvencia az input buffernek
	test_option_not_set()	flag visszaállítása:  opció nincs beállítva
	test_scrollbar()	görgetősáv szimulációja a GUIban
	test_refcount()		kifejezés referenciaértéke
	test_srand_seed()	srand() seed értéke
	test_unknown()		visszatérési érték ismeretlen típusú
	test_void()		visszatérési érték void típusú

Belső-folyamtok között kommunikáció:	    *channel-functions*
					    *függvények-csatorna*
	ch_canread()		beolvasási állapot ellenőrzése
	ch_open()		csatorna nyitása
	ch_close()		csatorna zárása
	ch_close_in()		csatorna bementének zárása
	ch_read()		üzenet olvasása a csatornáról
	ch_readblob()		Blob olvasása a csatornáról
	ch_readraw()		raw message olvasása a csatornáról
	ch_sendexpr()		JSON üzenet küldése a csatornán
	ch_sendraw()		raw message küldése a csatornán
	ch_evalexpr()		kifejezés kiértékelése a csatornán
	ch_evalraw()		raw string kiértékelése a csatornán
	ch_status()		csatorna állapota
	ch_getbufnr()		csatorna bufferszáma
	ch_getjob()		csatornához társítható munkafolyamat
	ch_info()		csatorna információk
	ch_log()		üzenet írása a csatorna log fájlba
	ch_logfile()		csatorna log beállítása
	ch_setoptions()		csatorna beállításai
	json_encode()		kifejezés kódolása JSON Stringgé
	json_decode()		JSON string dekódolása Vim stringgé
	js_encode()		kifejezés kódolása JSON Stringgé
	js_decode()		JSON string dekódolása Vim típussá

Munkafolyamatok:				*job-functions*
					*függvények-munkafolyamatok*
	job_start()		munkafolyamat indítása
	job_stop()		munkafolyamat leállítása
	job_status()		munkafolyamat állapota
	job_getchannel()	munkafolyamat által használt csatorna
	job_info()		munkafolyamat információi
	job_setoptions()	munkafolyamat opcióinak beállítása

Jelek:						*sign-functions*
						*függvények-jelek*
	sign_define()		jel definiálása vagy frissítése
	sign_getdefined()	jelek listája
	sign_getplaced()	jelek helyeinek listája
	sign_jump()		ugrás jelhez
	sign_place()		jel elhelyezése
	sign_placelist()	jelek listájának elhelyezése
	sign_undefine()		undefine a sign
	sign_unplace()		jel visszavonása
	sign_unplacelist()	jelek listájának visszavonása

Terminálablak:					*terminal-functions*
						*függvények-terminál*
	term_start()		új terminálablak munkafolyamattal
	term_list()		terminál buffereinek listája
	term_sendkeys()		billentyűleütések küldése a terminálba
	term_wait()		várakozás a képernyő frissítésére
	term_getjob()		terminálhoz társított munkafolyamatok
	term_scrape()		terminálablak sorának lekérdezése
	term_getline()		terminálablak egy sorának lekérdezése
	term_getattr()		{what} attribútum értéke
	term_getcursor()	terminálablak kurzorpozíciója
	term_getscrolled()	terminálablakban görgetett sorok
	term_getaltscreen()	alternatív screen flagek
	term_getsize()		terminálablak mérete
	term_getstatus()	terminál állapota
	term_gettitle()		terminálablak neve
	term_gettty()		terminálablak tty neve
	term_setansicolors()	GUI 16 ANSI színeinek beállítása
	term_getansicolors()	GUI 16 ANSI színeinek lekérdezése
	term_dumpdiff()		két dump különbségeinek megjelenítése
	term_dumpload()		terminál-dump betöltése ablakba
	term_dumpwrite()	terminál-dump mentése fájlba
	term_setkill()		munkafolyamat megállítása a terminálban
	term_setrestore()	terminálablak visszaállításának parancsa
	term_setsize()		terminálablak méretének beállítása
	term_setapi()		terminálablak JSON API prefixuma

Felugró ablak:					*popup-window-functions*
						*függvények-felugró-ablak*
	popup_create()		felugró ablak létrehozása a képernyő közepén
	popup_atcursor()	felugró ablak létrehozása a kurzor fölött,
				mely eltűnik a kurzor mozgatása esetén
	popup_beval()		v:beval_ változó pozíciójánál a bezáródik, ha
				ha ez egér elmozog
	popup_notification()	értesítés megjelenítése három másodpercig
	popup_dialog()		középre zárt felugró ablak, szegéllyel és
				térközzel
	popup_menu()		elem kiválasztása listából (prompt)
	popup_hide()		felugró ablak elrejtése ideiglenesen
	popup_show()		elrejtett felugró ablak megjelenítése
	popup_move()		felugró ablak mozgatása
	popup_setoptions()	felugró ablak beállításai
	popup_settext()		felugró ablak tartalmának változtatása
	popup_close()		felugró ablak bezárása
	popup_clear()		az összes felugró ablak bezárása
	popup_filter_menu()	elem kiválasztása listából
	popup_filter_yesno()	'y' vagy 'n' prompt
	popup_getoptions()	felugró ablak opciói
	popup_getpos()		felugró ablak aktuális pozíciója
	popup_findinfo()	felugró ablak window ID-ja
	popup_findpreview()	betekintő ablak window ID-ja
	popup_list()		az összes felugró ablak window ID-ja
	popup_locate()		felugró ablak window ID-ja pozíció alapján

Timerek:					*timer-functions*
						*függvények-időzítők*
	timer_start()		timer létrehozása
	timer_pause()		timer megállítása, indítása
	timer_stop()		timer megállítása
	timer_stopall()		az összes timer megállítása
	timer_info()		timer-információk

Tagek:						*tag-functions*
						*függvények-tagek*
	taglist()		egyező tagek listája
	tagfiles()		tagfájlok listája
	gettagstack()		ablakhoz tartozó tag stack
	settagstack()		ablakhoz tartozó tag stack módosítása

Buffer promptok:				*promptbuffer-functions*
						*függvények-buffer-prompt*
	prompt_getprompt()	bufferhez tartozó prompt
	prompt_setcallback()	bufferhez tartozó prompt callback
	prompt_setinterrupt()	bufferhez tartozó interrupt callback
	prompt_setprompt()	bufferhez tartozó prompt szövege

Szöveg-tulajdonságok:				*text-property-functions*
					        *függvények-szöveg-tulajdonság*
	prop_add()		tulajdonság hozzáadása adott pozícióhoz
	prop_add_list()		tulajdonság hozzáadása több pozícióhoz
	prop_clear()		tulajdonság eltávolítása sor vagy sorokból
	prop_find()		tulajdonság keresése
	prop_list()		sor összes tulajdonsága (lista)
	prop_remove()		sor összes tulajdonságának eltávolítása
	prop_type_add()		tulajdonság típus definiálása
	prop_type_change()	típus beállítása
	prop_type_delete()	típus törlése
	prop_type_get()		típus tulajdonságai
	prop_type_list()	az összes típus tulajdonságai

Hangok:							*sound-functions*
							*függvények-hang*
	sound_clear()		az összes hang lejátszásásának megállítása
	sound_playevent()	esemény hangjának lejátszásása
	sound_playfile()	hangfájl lejátszása
	sound_stop()		hangfájl lejátszásának megállítása

Egyebek:						*various-functions*
							*függvények-egyéb*
	mode()			szerkesztési mód
	state()			'busy' állapot lekérése
	visualmode()		utolsó vizuális mód típusa
	exists()		változó, függvény, stb. meglétének ellenőrzése
	exists_compiled()	mint az exists(), de fordításkor ellenőriz
	has()			Vim-feature támogatásának ellenőrzése
	changenr()		legutóbbi változások száma
	cscope_connection()	cscope kapcsolatának ellenőrzése
	did_filetype()		FileType autocommand használatának ellenőrzése
	eventhandler()		eseménykezelő által kiváltva (ellenőrzés)
	getpid()		Vim PID-je
	getimstatus()		IME aktív állapotának ellenőrzése
	interrupt()		szkript futtatásának felfüggesztése
	windowsversion()	MS-Windows verziója
	terminalprops()		terminál tulajdonságai

	libcall()		külső library függvényének hívása
	libcallnr()		ugyanaz, visszatérés számmal

	undofile()		visszavonás fájl neve
	undotree()		visszavonás fa állapota

	getreg()		regiszter tartalma
	getreginfo()		regiszter-információk
	getregtype()		regiszter típusa
	setreg()		regiszter tartalmának és típusának beállítása
	reg_executing()		futtatott regiszter neve
	reg_recording()		rögzített regiszter neve

	shiftwidth()		'shiftwidth' effektív értéke

	wordcount()		buffer byte/word/char értékei

	luaeval()		|Lua| kifejezés kiértékelése
	mzeval()		|MzScheme| kifejezés kiértékelése
	perleval()		Perl kifejezés (|+perl|) kiértékelése
	py3eval()		Python kifejezés (|+python3|) kiértékelése
	pyeval()		Python kifejezés (|+python|) kiértékelése
	pyxeval()		|python_x| kifejezés kiértékelése
	rubyeval()		|Ruby| kifejezés kiértékelése

	debugbreak()		debug alatt álló program megszakítása

==============================================================================
*41.7*	Függvények definiálása

A Vimben létrehozhatjuk saját függvényeinket. Az alapvető függvénydeklaráció a
következő: >

	:function {name}({var1}, {var2}, ...)
	:  {body}
	:endfunction
<
	Megjegyzés:
	A függvényneveknek nagy kezdőbetűvel kell kezdődniük

Hozzunk lére egy olyan függvényt, mely két számból a kisebbel tért vissza.
Kezdjük ezzel a sorral: >

	:function Min(num1, num2)

Ezzel meghatároztuk a függvény nevét "Min", illetve a két argumentumot: "num1"
és "num2".
   Első lépésben ellenőriznünk kell, hogy melyik szám kisebb:
   >
	:  if a:num1 < a:num2

Az "a:" prefixum azt jelenti, hogy a változó egy függvényargumentum. Rendeljük
 hozzá a kisebb számot a "smaller" nevű változóhoz: >

	:  if a:num1 < a:num2
	:    let smaller = a:num1
	:  else
	:    let smaller = a:num2
	:  endif

A "smaller" változó lokális. Minden változó lokális a függvényre nézve, amíg
ezt máshogyan nem jelöljük, mint például: "g:", "a:", vagy "s:".

	Megjegyzés:
	Ahhoz, hogy egy globális változót el tudjuk érni a függvényen
	belülről, "g:" prefixummal kell ellássuk. Ezért "g:today" változóra
	globális változóként tekintünk, "today"-t egy külön változóként
	kezeljük, ami a függvény lokális változója.

Végül használjuk a ":return" parancsot a visszatéréshez, amely a kisebb
számmal tér vissza, majd zárjuk a függvényt: >

	:  return smaller
	:endfunction

A teljes függvénydefiníció: >

	:function Min(num1, num2)
	:  if a:num1 < a:num2
	:    let smaller = a:num1
	:  else
	:    let smaller = a:num2
	:  endif
	:  return smaller
	:endfunction

Akik szeretik a rövid függvényeket: >

	:function Min(num1, num2)
	:  if a:num1 < a:num2
	:    return a:num1
	:  endif
	:  return a:num2
	:endfunction

A felhasználó által definiált függvényeket ugyanúgy kell meghívnunk, mint a
beépítetteket. A Min függvényt így tudjuk meghívni: >

	:echo Min(5, 8)


A függvény futtatása elkezdődik és a Vim soronként végrehajtja a parancsokat.
Hiba esetén (például ismeretlen változó vagy függvény esetén) hibaüzenetet
ebben a szakaszban kapjuk meg. A függvény írásakor nincs mód a hibák
észlelésére.

Amikor a függvény eléri az ":endfunction" vagy ":return" kulcsszavakat,
argumentum használata nélkül a függvény automatikusan nulla (0) értékkel tér
vissza.

Létező függvény újradefiniálásához  a "!" jelet kell használjuk a ":function"
parancsban: >

	:function!  Min(num1, num2, num3)


TARTOMÁNY HASZNÁLATA

A ":call" parancsnak sorokra hivatkozó tartományt is átadhatunk. Ennek két
értelme lehet. Ha a függvényt a "range" kulcsszóval definiáltuk, akkor ennek
kezeléséről magának gondoskodik.
  Ekkor a függvény megkapja a "a:firstline" és a "a:lastline" változókat,
melyek tartalmazzák a tartomány kezdeti- és végpontját. Például: >

	:function Count_words() range
	:  let lnum = a:firstline
	:  let n = 0
	:  while lnum <= a:lastline
	:    let n = n + len(split(getline(lnum)))
	:    let lnum = lnum + 1
	:  endwhile
	:  echo "found " .. n .. " words"
	:endfunction

A függvényt meghívatjuk így: >

	:10,30call Count_words()

A függvény egyszer fut le és kiírja a szavak számát.
   A másik módszer, ha  a függvényt a "range" kulcsszó nélkül definiáljuk. Így
a függvény minden sorban külön meghívódik. Például: >

	:function  Number()
	:  echo "line " .. line(".") .. " contains: " .. getline(".")
	:endfunction

Ha a függvényt így hívjuk meg: >

	:10,15call Number()

Akkor az hat hívást jelent.


VÁLTOZÓ ARGUMENTUMLISTA

A Vim függvényeiben egynél több argumentum is szerepelhet. Az alábbi
paranccsal, például egy olyan függvényt definiálunk, melyben kötelezően kell
szerepelnie egy (start) argumentumnak. (A függvények maximálisan 20
argumentumot képesek kezelni: >

	:function Show(start, ...)

Az "a:1" változó tartalmazza az első argumentumot, a "a:2" a másodikat és így
tovább. Az "a:0" tartalmazza az extra argumentumok számát. Például: >

	:function Show(start, ...)
	:  echohl Title
	:  echo "start is " .. a:start
	:  echohl None
	:  let index = 1
	:  while index <= a:0
	:    echo "  Arg " .. index .. " is " .. a:{index}
	:    let index = index + 1
	:  endwhile
	:  echo ""
	:endfunction

A példa "echohl" a következő ":echo" parancs kiemelését határozza meg.
":echohl None" visszaállítja a kiemelést. Az ":echon" parancs ugyanúgy
működik, mint az ":echo", sortörést viszont nem alkalmaz.

Az "a:000" speciális változó, egy lista, mely az összes "..." argumentumot
tartalmazza. Lásd |a:000|.


LISTÁZÓ FÜGGVÉNYEK

A ":function" parancs az összes felhasználó által definiált (beleértve a
telepített beépülőket is) neveket és argumentumokat listázza: >

	:function
<	function Show(start, ...) ~
	function GetVimIndent() ~
	function SetSyn(name) ~

Ha meg szeretnénk tekinteni magát a függvényt, akkor adjuk át a függvény nevét
argumentumként a ":function" parancsnak: >

	:function SetSyn
<	1     if &syntax == '' ~
	2       let &syntax = a:name ~
	3     endif ~
	   endfunction ~


HIBAKERESÉS

A sor száma nagyon hasznos hibaüzenetek értelmezésekor, vagy hibakeresésnél.
Lásd |debug-scripts|.
   A 'verbose' opció 12, vagy annál nagyobbra állításával láthatóvá válik
minden függvényhívás. 15, vagy annál nagyobb esetén az összes futtatott sor
látszik.


FÜGGVÉNY TÖRLÉSE

A Show() függvény törlése: >

	:delfunction Show

Ha a függvény nem létezik, akkor hibaüzenetet kapunk.


FÜGGVÉNYHIVATKOZÁSOK

Olykor hasznos, ha egy függvényt változóhoz tudunk rendelni, ezt a function()
függvénnyel tudjuk megtenni, mely átalakítja a függvény nevét hivatkozássá. >

	:let result = 0		" or 1
	:function! Right()
	:  return 'Right!'
	:endfunc
	:function! Wrong()
	:  return 'Wrong!'
	:endfunc
	:
	:if result == 1
	:  let Afunc = function('Right')
	:else
	:  let Afunc = function('Wrong')
	:endif
	:echo call(Afunc, [])
<	Wrong! ~

Megjegyzés: a függvényhivatkozást tartalmazó változó nevének nagy betűvel kell
kezdődnie, különben könnyen egy beépített függvénynek tekinthetjük.
   A hivatkozott függvényt a call() függvénnyel tudjuk meghívni, melynek első
argumentuma a függvényhivatkozást tartalmazó változó, a második pedig az
argumentumokat tartalmazó lista.

A függvényhivatkozások szótárakkal való kombinálása további lehetőségeket
nyújt, erről azonban a következő fejezetben.

A saját magunk által definiálható függvényekről itt olvashatunk:
|user-functions|.

==============================================================================
*41.8*	Listák és szótárak

Eddig az alap String és szám típusokat használtuk. A Vim további két összetett
változó típust támogat: a listákat és a szótárakat.

A lista különböző adatok rendezett sora. Az adatok bármik lehetnek, ezért
létrehozhatunk listát számokkal, listát tartalmazó listákat, vagy akár a kettő
kombinációját. Lista három elemmel: >

	:let alist = ['aap', 'mies', 'noot']

A listát szögletes zárójelek határolják és értékeit vesszők választják el
egymástól. Üres lista létrehozása: >

	:let alist = []

Az add() függvénnyel a listához elemeket rendelhetünk: >

	:let alist = []
	:call add(alist, 'foo')
	:call add(alist, 'bar')
	:echo alist
<	['foo', 'bar'] ~

Listák összefűzéséhez a "+" operátort használhatjuk: >

	:echo alist + ['foo', 'bar']
<	['foo', 'bar', 'foo', 'bar'] ~

Vagy, ha közvetlenül szeretnéd kiegészíteni: >

	:let alist = ['one']
	:call extend(alist, ['two', 'three'])
	:echo alist
<	['one', 'two', 'three'] ~

Vegyük észre az add() és extend() közötti különbséget:  >

	:let alist = ['one']
	:call add(alist, ['two', 'three'])
	:echo alist
<	['one', ['two', 'three']] ~

Az add() második argumentuma egy elemeként adódik a listához.


FOR CIKLUS

A listák egyik jó tulajdonsága, hogy bejárhatjuk őket: >

	:let alist = ['one', 'two', 'three']
	:for n in alist
	:  echo n
	:endfor
<	one ~
	two ~
	three ~

A példa az "alist" lista összes elemét bejárja, az értéket "n"-hez rendelve
kiírja a kimenetre. A for ciklus általános formája: >

	:for {varname} in {listexpression}
	:  {commands}
	:endfor

Meghatározott ismétlésszámhoz a range() függvényt használhatjuk: >

	:for a in range(3)
	:  echo a
	:endfor
<	0 ~
	1 ~
	2 ~

Jegyezzük meg, hogy a range() függvény első eleme mindig nullával kezdődik,
ezért az utolsó elem eggyel kevesebb lesz, mint a lista hossza.
   Maximum értéket is meghatározhatunk, sőt, akár visszafelé is haladhatunk: >

	:for a in range(8, 4, -2)
	:  echo a
	:endfor
<	8 ~
	6 ~
	4 ~

Még hasznosabb példa: a buffer sorainak bejárása: >

	:for line in getline(1, 20)
	:  if line =~ "Date: "
	:    echo matchstr(line, 'Date: \zs.*')
	:  endif
	:endfor

Mely végighalad az első húsz soron (1-20 inkluzív) és kiírja a megtalált
dátumokat.


SZÓTÁRAK

A szótárak kulcs-értékpárokat tárolnak. A bejárás nagyon gyors, ha ismerjük a
kulcsokat. A szótárakat kapcsos zárójelek határolják: >

	:let uk2nl = {'one': 'een', 'two': 'twee', 'three': 'drie'}

A kulcsokhoz tartozó értékeket így érhetjük el: >

	:echo uk2nl['two']
<	twee ~

A szótár általános definíciója: >

	{<key> : <value>, ...}

Üres szótár definiálása kulcsok nélkül: >

	{}

A szótárakban rejlő potenciál hatalmas. Kezelésükhöz számos beépített függvény
elérhető. Például, a lista kulcsainak bejárása: >

	:for key in keys(uk2nl)
	:  echo key
	:endfor
<	three ~
	one ~
	two ~

Észrevehetjük, hogy a kulcsok nem rendezettek. Így rendezhetjük őket: >

	:for key in sort(keys(uk2nl))
	:  echo key
	:endfor
<	one ~
	three ~
	two ~

A szótárban tárolt elemek eredeti elrendezését soha nem kapjuk meg, ehhez
listát kell használnunk, mely sorrendben tárolja az elemeket.


SZÓTÁRFÜGGVÉNYEK

A szótár elemeit a szögletes zárójelek közötti kulcs átadásával érthetjük el.
>
	:echo uk2nl['one']
<	een ~

Az alábbi módszerrel is elérhetjük az elemeket, speciális karakterek írása
nélkül: >

	:echo uk2nl.one
<	een ~

A módszer csak az ASCII karakterek betűivel, számokkal és "_" karakterrel
működik. Így akár új elemeket is létrehozhatunk:  >

	:let uk2nl.four = 'vier'
	:echo uk2nl
<	{'three': 'drie', 'four': 'vier', 'one': 'een', 'two': 'twee'} ~

És most valami specialitás, függvényeket is létrehozhatunk listaelemként. >

	:function uk2nl.translate(line) dict
	:  return join(map(split(a:line), 'get(self, v:val, "???")'))
	:endfunction

Próbáljuk ki: >

	:echo uk2nl.translate('three two five one')
<	drie twee ??? een ~

Vegyük észre a "dict" szót a ":function" sorában. Ez jelöli azt, hogy a
függvényt egy szótáron használjuk. A "self" lokális változó erre a szótárra
utal.
   Vizsgáljuk meg a függvény visszatérési értékét: >
 
	split(a:line)

A split() függvény paraméterként egy stringet vár, melyet a szóközök mentén
elválaszt és listaként adja vissza ezen szavakat. A példában szereplő
visszatérési érték: >

	:echo split('three two five one')
<	['three', 'two', 'five', 'one'] ~

Ez a lista lesz a map() függvény első argumentuma. Bejárjuk a szótárat, és  a
kulcsokhoz tartozó értékeket a "v:val" változóhoz rendeljük. Gyakorlatilag
egy ciklus rövidített változata. A parancs: >

	:let alist = map(split(a:line), 'get(self, v:val, "???")')

Mely egyenértékű ezzel: >

	:let alist = split(a:line)
	:for idx in range(len(alist))
	:  let alist[idx] = get(self, alist[idx], "???")
	:endfor

A get() függvény ellenőrzi, hogy a kulcs szerepel-e a szótárban. Ha igen,
akkor az értéket visszaadja. Ha nem, akkor az előre beállított alapértelmezett
értéket adja vissza (ebben az esetben '???'). Kényelmes megoldás a nem létező
kulcsok kezelésére, ha nem szeretnénk hibaüzenetet kapni.

A join() függvény a split(): ellentéte, összefűzi a lista értékeit
szóközökkel.
  A split(), map() és join() kombinációjával kompakt módon szűrhetjük az
értékeket.


OBJEKTUM ORIENTÁLT PROGRAMOZÁS

Mivel a szótárakban nem csak értékeket helyezhetünk el, hanem függvényeket is,
ezért a szótárakat használhatjuk objektum-szerűen is.
   A fent említett példában a szótárat holland szavak angolra fordításához
használtuk. Ha ezt a mechanizmust újra fel szeretnénk használni, akkor először
hozzunk létre egy "objektumot" (szótárat), egy translate nevű függvénnyel: >

	:let transdict = {}
	:function transdict.translate(line) dict
	:  return join(map(split(a:line), 'get(self.words, v:val, "???")'))
	:endfunction

Ez picit különbözik az előzőleg használt módszertől. Itt a 'self.words'
segítségével hivatkozhatunk a szótár értékeire. Mivel konkrétan nincs a
'self.word' definiálva, ezért ezt az objektumot kezelhetjük absztrakt
osztályként.

Példányosítsuk a holland szavak fordításához: >

	:let uk2nl = copy(transdict)
	:let uk2nl.words = {'one': 'een', 'two': 'twee', 'three': 'drie'}
	:echo uk2nl.translate('three one')
<	drie een ~

És a német fordító: >

	:let uk2de = copy(transdict)
	:let uk2de.words = {'one': 'eins', 'two': 'zwei', 'three': 'drei'}
	:echo uk2de.translate('three one')
<	drei eins ~

Láthatjuk, hogy a copy() függvénnyel másoltuk a "transdict"-et, a másolatban
pedig átírtuk az értékeket. Az eredeti szótár természetesen nem változik.

Lépjünk tovább: >

	:if $LANG =~ "de"
	:  let trans = uk2de
	:else
	:  let trans = uk2nl
	:endif
	:echo trans.translate('one two three')
<	een twee drie ~

A példában a két objektum (szótár) egyikére hivatkozunk. Másolás nem történik.
A listákról és szótárakról bővebben: |list-identity| és |dict-identity|.

Előfordulhat olyan eset, amikor az adott nyelv nem támogatott. A translate()
függvényt felülírhatjuk, hogy ne tegyen semmit: >

	:let uk2uk = copy(transdict)
	:function! uk2uk.translate(line)
	:  return a:line
	:endfunction
	:echo uk2uk.translate('three one wladiwostok')
<	three one wladiwostok ~

Vegyük észre a ! jelet, mellyel felülírtuk a létező függvényhivatkozást. Most
használjuk a "uk2uk"-t, ha a nyelv nem támogatott: >

	:if $LANG =~ "de"
	:  let trans = uk2de
	:elseif $LANG =~ "nl"
	:  let trans = uk2nl
	:else
	:  let trans = uk2uk
	:endif
	:echo trans.translate('one two three')
<	one two three ~

További olvasnivaló: |Lists| és |Dictionaries|.

==============================================================================
*41.9*	Kivételek

Például: >

	:try
	:   read ~/templates/pascal.tmpl
	:catch /E484:/
	:   echo "Sorry, the Pascal template file cannot be found."
	:endtry

A ":read" parancs hibával tér vissza, ha a fájl nem található. A beépített
hibaüzenet helyet a hiba kódjával elkaphatjuk a hibát és egy szebb (vagy
relevánsabb) üzenetet írathatunk ki.

A ":try" és az ":endtry" között keletkezett hibák kivételeket képeznek. A
kivétel egy sztring. Hiba esetén a sztring tartalmazza a hibaüzenetet. Minden
hibaüzenethez tartozik egy azonosító. A példában szereplő kód az "E484:"
kivételt kezeli. A hiba garantáltan nem változik, a hibaüzenet viszont
változhat (a fordítás függvényében).

Ha a ":read" parancs futása közben egy más jellegű hibába ütközünk, azt az
"E484:" nem fogja kezelni, ezért a kivétel nem lesz elkapva és hiba
alapértelmezett hibaüzenete jelenik meg.

Kezelhetjük a kivételt így: >

	:try
	:   read ~/templates/pascal.tmpl
	:catch
	:   echo "Sorry, the Pascal template file cannot be found."
	:endtry

Ez azt jelenti, hogy az összes hiba el lesz kapva. Ezért a hibaüzenet az
alapértelmezett üzenet lesz, például "E21: Cannot make changes, 'modifiable' is off".

Hasznos mechanizmus a ":finally" használata: >

	:let tmp = tempname()
	:try
	:   exe ".,$write " .. tmp
	:   exe "!filter " .. tmp
	:   .,$delete
	:   exe "$read " .. tmp
	:finally
	:   call delete(tmp)
	:endtry

A kódrészlet szűri a kurzor pozíciójától a fájl végéig terjedő tartalmat a
":filter" paranccsal, ami egy fájlnevet vár argumentumként. Nem számít, hogy a
szűrés sikeres-e, ha valami hiba történik a ":try" és a ":finally" parancs
között (akár ha a felhasználó megszakítja a szűrést a CTRL-C billentyűvel, a
"call delete(tmp)" függvény mindig lefut, így nem hagyunk hátra ideiglenes
fájlt.

Több információ a kivételkezelésről a referenciában: |exception-handling|.

==============================================================================
*41.10* Általános információk

Az alábbi lista a Vim szkriptekre jellemző tulajdonságokat ír le, melyek
említve vannak a releváns pontokon, de ez egy szép tömör lista.

A sorvégi karakterek a rendszerünktől függ. A Unix rendszer <NL> karaktert
használ, a MS-Windows <CR><NL> karaktereket használ. Ez fontos a, ha mapjeink
a <CR> karakterrel végződnek. Lásd |:source_crnl|.


ÜRES KARAKTEREK

Az üres sorok engedélyezettek és figyelmen kívül vannak hagyva.

A vezető üres karakterek (szóközök és TABok), mindig figyelmen kívül vannak
hagyva minden esetben. A paraméterek közötti üres karakterek (például a "set"
és a "cpoptions" között a lenti példában), redukálva vannak egy karakterre,
amik elválasztó szerepet töltenek be. A sor utolsó karaktere után szereplő
üres karakterek szituációtól függően értelmezve vannak, lásd alább.

A ":set" parancshoz használnunk kell a "=" jelet: >

	:set cpoptions    =aABceFst

a "=" jelet megelőző üres karakterek ignorálva vannak, de a "=" jel után nem
szerepelhet üres karakter!

Ha üres karaktereket szeretnénk használni értékként, akkor escapelnünk kell
őket "\" karakterrel: >

	:set tags=my\ nice\ file

Ugyanez a példa így írva: >

	:set tags=my nice file

hibát eredményez, hiszen így értékelődik ki: >

	:set tags=my
	:set nice
	:set file


KOMMENTEK

A " (idézőjel), a komment kezdetét jelenti. Minden további karakter a az
aktuális sor végéig kommentként van értelmezve, kivéve azokat a parancsokat,
ahol a " karakternek jelentősége van.

Egy dologra különösen figyelnünk kell, például: >

	:abbrev dev development		" shorthand
	:map <F3> o#include		" insert include
	:execute cmd			" do it
	:!ls *.c			" list C files

A 'dev' rövidítés 'development     " shorthand'-re lesz kibontva. Az <F3> map
a teljes sort tartalmazza, beleértve a '" insert include'-t is. Az "execute"
parancs hibát eredményez. A "!" parancs mindent átad a shell értelmezőnek,
mely páratlan '"' karakter miatt hibát eredményez.
   A ":map", ":abbreviate", ":execute", és a "!" parancsok után nem
szerepelhet megjegyzés (létezik még pár parancs ezzel a megszorítással). A
":map", ":abbreviate", ":execute" parancsokhoz az alábbi trükköt
alkalmazhatjuk: >

	:abbrev dev development|" shorthand
	:map <F3> o#include|" insert include
	:execute cmd			|" do it

A '|' két parancsot választ el egymástól. Ezért a következő parancs csak
kommentként értékelődik ki. Az utolsó parancshoz két dolgok kell ismernünk: az
|:execute| és a '|' karakter használatát: >

	:exe '!ls *.c'			|" list C files

Vegyük észre, hogy a '|' karakter előtt nincs üres karakter a rövidítésben és
a mappingben. Ezekben a parancsokban minden karakter kiértékelődik a sor végig
(vagy a '|' karakterig), ezért sorok vége előtti üres karakterek nem
láthatóak.  >

	:map <F4> o#include

A hiba felderítéséhez állítsuk be a 'list' beállítást, ha szerkesztjük a vimrc
fájlt.

Unix rendszereken egy speciális módszerrel is kommentelhetjük a fájlokat, így
a Vim szkript futtatható marad: >

	#!/usr/bin/env vim -S
	echo "this is a Vim script"
	quit

A '#' önmagában kiírja a fájl sorát a hozzá tartozó sor számával. Egy '!'
jelet hozzáadva a '#' jel alapértelmezett működését elveszti|:#!| |-S|


CSAPDÁK

Az alábbi kódrészlet még nagyobb problémát okozhat: >

	:map ,ab o#include
	:unmap ,ab

Itt az unmap nem fog működni, hiszen az ",ab " mappelésre vonatkozik. Ez a map
pedig nem létezik. A hibát nehéz észrevenni, mert a ":unmap ,ab " utolsó
szóköz karaktere nem látható.

Ugyanez történik, ha a kommentünket az 'unmap' parancs után helyezzük el: >

	:unmap ,ab     " comment

Ebben az esetben a komment természetesen figyelmen kívül lesz hagyva. A Vim
pedig a ',ab     ' mappet szeretné unmappelni, ami nem létezik. Írjuk át
ilyen módon: >

	:unmap ,ab|    " comment


NÉZET VISSZAÁLLÍTÁSA

Olykor szükségünk lehet arra, hogy módosítás után visszatérjünk a kurzor előző
pozíciójához. A relatív pozíció visszaállítása a megfelelő megoldás, így
ugyanaz a sor jelenik meg az ablak első sorában.
   A példa másolja az aktuális sort, majd a másolatot a fájl első sorába
illeszti be, és visszaállítja a nézetet: >

	map ,p ma"aYHmbgg"aP`bzt`a

A működés: >
	ma"aYHmbgg"aP`bzt`a
<	ma			jelölő a kurzor pozíciójához
	  "aY			aktuális sor másolása "a" regiszterbe
	     Hmb		fájl első sorára ugrás, megjelölés "b"-vel
		gg		fájl első sorára ugrás
		  "aP		sor beillesztése a sor fölé
		     `b		ugrás az első megjelenített sorra
		       zt	sor pozícionálása középre
			 `a	ugrás "a" jelölőhöz


NEVEK, KONVENCIÓK

Az alábbi pár ponttal meg tudjuk előzni, hogy az általunk írt függvények nem
kívánt kapcsolatba lépjenek a mások által megírt függvényekkel. Az eljárás a
következő:
- Használjunk egyedi prefixumot minden függvény előtt. Ez lehet akár rövidítés
  is. Például: az "OW_" használata az option windowwal kapcsolatos
  függvényeknél.
- A függvénydefiníciókat tegyük egy helyre, állítsunk be egy globális
  változót, mely a függvények betöltöttségét jelenti. Ha ismét betöltjük, a
  függvényeinket, akkor először távolítsuk el őket (unload). 
Például: >

	" This is the XXX package

	if exists("XXX_loaded")
	  delfun XXX_one
	  delfun XXX_two
	endif

	function XXX_one(a)
		... body of function ...
	endfun

	function XXX_two(b)
		... body of function ...
	endfun

	let XXX_loaded = 1

==============================================================================
*41.11*	Beépülő írása				*write-plugin*
						*beépülő-létrehozás*

A saját Vim szkriptjeinket úgy is megírhatjuk, hogy az mások számára is
használható legyen. A szkriptek a fogd és vidd módszerrel azonnal
telepíthetőek:  |add-plugin|.

Gyakorlatilag két féle beépülőtípus létezik:

  global beépülők: Az összes fájlhoz.
filetype beépülők: Specifikus fájlokhoz.

Ebben a részben az elsőt mutatjuk be. A legtöbb elem egyébként a
fájlspecifikus beépülőkre is vonatkozik (erről a következő fejezetben lesz szó
section |write-filetype-plugin|).


NEVEK

Első lépésben el kell neveznünk a beépülőnket, mely rövid, tömör és általában
a beépülő funkcionalitását írja le. A legjobb, ha egy teljesen egyedi nevet
választunk, hogy elkerüljük a későbbi ütközést. A névnek nyolc, vagy annál
kevesebb karakterből kell állnia (a régi Windows rendszerek sajnos ennyit
kezelek).

A példában létrehozott szkript a "typecorr.vim". 

Be kell tartsunk bizonyos szabályokat, hogy az általunk írt szkript mindenki
számára működőképes legyen. Ezeket lépésről lépésre meg fogjuk ismerni. A
teljes plugin a fájl végén található.


TÖRZS

Kezdjük a beépülő törzsével, a sorok, mely az aktuális munkát végzik: >

 14	iabbrev teh the
 15	iabbrev otehr other
 16	iabbrev wnat want
 17	iabbrev synchronisation
 18		\ synchronization
 19	let s:count = 4

Az aktuális lista természetesen sokkal hosszabb lehet.

A sorszámozás csak a magyarázat miatt van feltüntetve, az aktuális beépülőbe
ne írjuk bele!


FEJLÉC

A beépülő folyamatosan fejlődni fog, időről időre hozzá fogunk adni bizonyos
dolgokat és egyszerre akár több verzió és létezhet belőle. Ha a szkriptet egy
harmadik fél fogja használni, akkor tájékoztassuk, hogy ki írta ezt a gyönyörű
beépülőt. 
Ezért, a beépülő tetejére írjunk egy fejlécet: >

  1	" Vim global plugin for correcting typing mistakes
  2	" Last Change:	2000 Oct 15
  3	" Maintainer:	Bram Moolenaar <Bram@vim.org>

Jogi és licensz információk: A beépülők hasznosak és nem igazán éri meg
korlátozni a terjesztésüket, ezért fontoljuk meg, hogy a beépülőnket
nyilvánosan elérhetővé tesszük, vagy használjuk a Vim |license|-t. Erről egy
rövid sort elég írnunk. Például: >

  4	" License:	This file is placed in the public domain.


SOROK FOLYTATÁSA, MELLÉKHATÁSOK ELKERÜLÉSE	    *use-cpo-save*
						    *cpo-save-használata*

A 18. sorban a sor folytatása a |line-continuation|ban leírtak szerint
történik. A 'compatible' opció beállítása miatt hibaüzenetet kapunk. Nem elég,
ha csak kikapcsoljuk a 'compatible' opciót, mert ennek több mellékhatása is
létezik. Ennek elkerülése érdekében állítsuk be a 'cpoptions' alapértelmezett
értékét (melyet a szkript végén visszaállíthatunk): >

 11	let s:save_cpo = &cpo
 12	set cpo&vim
 ..
 42	let &cpo = s:save_cpo
 43	unlet s:save_cpo

Tároljuk a jelenlegi 'cpoptions' értékét a s:save_cpo változóban. A beépülő
végén ebből állítjuk vissza az értékét. 

A szkriptben ezt lokális változóban tesszük meg |s:var|. Globális változó
esetén van arra esély, hogy a változó már definiált. 


NEM TÖLTŐDIK BE

Adjuk lehetőséget arra, hogy a felhasználó eldönthesse, hogy betölti-e az
adott beépülőt: >

  6	if exists("g:loaded_typecorr")
  7	  finish
  8	endif
  9	let g:loaded_typecorr = 1

Így nem tudjuk a szkriptet kétszer betölteni, ami hibát okozna (a függvények
újradefiniálása és az autocommandok duplikálódása miatt).

Az ajánlott prefixum a "loaded_", melyet a plugin neve követ. A ":g"-t csak
azért használatos, hogy a változót még véletlenül se definiáljuk a függvény
lokális változójaként.

A "finish" parancs megszakítja a fájl további beolvasását, sokkal gyorsabb,
mint az egész fájlt körülölelő if-endif szerkezet.


MAPPEK

Tegyük a beépülőt még érdekesebbé. Adjunk hozzá egy mapet, ami kurzor alatt
álló szót javítja. Választhatunk véletlenszerűen egy map azonosítót, de
előfordulhat, hogy ezt a felhasználó már definiálta. A <Leader> használatával
megengedhetjük a felhasználónak, hogy átírja a beépülő által használt
mappeket: >

 22	  map <unique> <Leader>a  <Plug>TypecorrAdd;

A "<Plug>TypecorrAdd;" megteszi, erről később.

A felhasználó kijelölhet magának egy egyedi "mapleader" billentyűt, mely
hozzáadódik a beépülőben meghatározott maphez. Például, ha a felhasználó az
alábbi módon állította be a leader billentyűjét: >

	let mapleader = "_"

a map értelemszerűen "_a"-re értékelődik ki. Alapértelmezett beállítás esetén
a backslash karakter "\" van érvényben, ezért a map "\a"-ra vált.

Megjegyzés: a <unique> miatt hibaüzenetet kapunk, ha az adott map már létezik.
|:map-<unique>|.

Mi történik akkor, ha felhasználó egy teljesen más mappet szeretne definiálni?
Ezt így biztosíthatjuk: >

 21	if !hasmapto('<Plug>TypecorrAdd;')
 22	  map <unique> <Leader>a  <Plug>TypecorrAdd;
 23	endif

Ez leellenőrzi, hogy létezik-e már a "<Plug>TypecorrAdd"-hoz map, és csak
akkor mappeli a "<Leader>a"-ra, ha az még nem létezik. Ezért a felhasználó így
is megadhatja a mappet a vimrc fájljában: >

	map ,c  <Plug>TypecorrAdd;

Így a mappelt szekvencia ",c" lesz ("a_" vagy "\a" helyett).


MODULARITÁS

Ahogy a szkriptünk terjedelemben hosszabb lesz, célszerű, ha darabokra
szedjük. Erre a célra a függvények bevezetése a legcélszerűbb módszer, de nem
szeretnénk, ha felülírná a létező függvényeinket. Például létrehozzuk az Add()
függvényt, de egy másik szkriptben is szerepel egy ugyanilyen függvény. Az
"s:" használatával függvényt lokálissá tehetjük a szkripthez.

Írjuk meg azt a függvényt, amivel egy új korrekciót adhatunk hozzá: >

 30	function s:Add(from, correct)
 31	  let to = input("type the correction for " .. a:from .. ": ")
 32	  exe ":iabbrev " .. a:from .. " " .. to
 ..
 36	endfunction

Így a szkripten belül meghívhatjuk az s:Add() függvényt. Ez lehetőséget ad
arra, hogy más szkriptek is definiálják a s:Add() függvényt sajátjukként, de
mindegyik a saját névterében hívható meg. Ráadásul létezhet egy globális Add()
függvény is (az "s:" nélkül), ami egy másik függvény.

Az <SID>-t a mappekben használjuk, ami generál egy szkript ID-t. Ez azonosítja
a szkriptet. A beépülőnkben ezt így használhatjuk: >

 24	noremap <unique> <script> <Plug>TypecorrAdd;  <SID>Add
 ..
 28	noremap <SID>Add  :call <SID>Add(expand("<cword>"), 1)<CR>

Ezért ha a felhasználó "\a"-t ír, az alábbi szekvenciává alakul: >

	\a  ->  <Plug>TypecorrAdd;  ->  <SID>Add  ->  :call <SID>Add()

Ha bármely más szkriptben szintén szerepel a <SID>Add map, akkor egy másik
azonosítót fog kapni, azaz a két map nem fog megegyezni.

Megjegyzés: A példában s:Add() helyett <SID>Add()-ot használtunk. Azért, mert
a mapet a felhasználó írja be (az pedig már nem a szkript névterében
található). Az <SID> a szkript azonosítója, így tudja a Vim, hogy melyik Add()
függvényt kell keresnie.

Ez egy kicsit komplex, viszont szükségünk van rá, ha azt akarjuk, hogy a
beépülőnk más beépülőkkel együtt tudjon működni. Az alapszabály: <SID>Add()
használata a mappekben és s:Add() használata minden egyéb helyen (a
beépülőben, autocommandokban, felhasználó parancsokban).

A mappet menüelemként is hozzáadhatjuk: >

 26	noremenu <script> Plugin.Add\ Correction      <SID>Add

A "Plugin" menüelem használata ajánlott. A példában csak egy menüelemet
hoztunk létre, de több elem esetén további menüpontokba ajánlott szervezni az
elemeket. Például: "Plugin.CSV" elemet egy olyan beépülőhöz, ami CSV
műveleteket támogat, "Plugin.CVS.checkin", "Plugin.CVS.checkout", stb.

Figyeljük meg, hogy a 28. sor ":noremap"-et használtuk a további mappelési
problémák elkerülésére. Előfordulhat, hogy valaki már mappelte a ":call"
parancsot. A 24. sorban is ":noremap"-et használtunk, de abban az esetben az
"<SID>Add"-ot szeretnénk remappelni, ezért használtuk itt a <script>-et. Az
ilyen módú mappelés lokális a szkripthez. |:map-<script>|. A 26. sorban
ugyanez történik. |:menu-<script>|


<SID> ÉS <Plug>					*using-<Plug>*
						*<Plug>-használata*

Az <SID> és <Plug> közötti különbségek:

<Plug>	látható a szkripten kívül. Olyan mappelésnél használjuk, ahol nagy az
	esély arra, hogy a felhasználó már definiált (vagy definiálni fog)
	mappet. A <Plug> egy olyan speciális kódot állít elő, amely nem
	egyezik meg egyetlen billentyű kódjával sem.
	Ha minimalizálni szeretnénk az ütközéseket, akkor definíciónk legyen:
	<Plug> szkriptnév mapnév
	A példánkban szkriptnévként a "Typecorr"-t használtuk, a mapnév pedig
	az "Add". A ";" a zárókarakter. A szkript- és mapnévnek csak az első
	karaktere nagy betű, így beazonosíthatjuk, hogy hol kezdődik a mapnév.

<SID>   a szkript ID (szkript egyedi azonosítója).
	A Vim az <SID>-hez egy "<SNR>123_" formátumnak megfelelő számot
	generál, ahol "123" egy véletlen szám. Ezért az "<SID>Add()" függvény
	neve "<SNR>11_Add()" az egyik szkriptben és "<SNR>22_Add()" a
	másikban. A ":function" paranccsal ez láthatóvá válik. A mappek <SID>
	átalakításának elve ugyanez, így lehet a szkript lokális függvényét
	meghívni mapből.



FELHASZNÁLÓI PARANCSOK

Adjunk egy olyan felhasználói parancsot, mellyel korrekciót adhatunk hozzá: >

 38	if !exists(":Correct")
 39	  command -nargs=1  Correct  :call s:Add(<q-args>, 0)
 40	endif

A felhasználói parancs definiálása akkor sikeres, ha a kívánt névvel még nem
szerepel azonos függvény, ellenkező esetben hibaüzenetet kapunk. A parancs
felülírása a ":command!" metódus alapján nem jó ötlet, hiszen a felhasználó
nem fogja érteni, hogy az általa definiált függvény miért nem működik.
|:command|


SZKRIPT VÁLTOZÓK

Ha a változó ":s"-el kezdődik, akkor az a szkript lokális változója (mely csak
a szkripten belül használható, a szkripten kívül pedig nem látható). A
változók addig maradnak érvényben, amíg a Vim fut. Ugyanazok a változók
maradnak érvényben, ha ugyanazt a szkriptfájlt töltjük be újra. |s:var|.

A legjobb, hogy ezeket a változókat használhatjuk a függvényeinkben,
auto-commandjainkban és felhasználói parancsainkban (amiket a szkriptben
definiáltunk). Példánkban az alábbi módosításokkal megszámolhatjuk a
korrekciókat: >

 19	let s:count = 4
 ..
 30	function s:Add(from, correct)
 ..
 34	  let s:count = s:count + 1
 35	  echo s:count .. " corrections now"
 36	endfunction

Első lépésben inicializáljuk az s:count változót, "4" értékkel. Később, az
s:Add() függvény hívása inkrementálja az s:count-ot. Nem számít, hogy a
függvény honnan lett meghívva, mivel a változó létezik, ezért a szkript a
lokális példányt használja. 


VÉGEREDMÉNY

A teljes szkript: >

  1	" Vim global plugin for correcting typing mistakes
  2	" Last Change:	2000 Oct 15
  3	" Maintainer:	Bram Moolenaar <Bram@vim.org>
  4	" License:	This file is placed in the public domain.
  5
  6	if exists("g:loaded_typecorr")
  7	  finish
  8	endif
  9	let g:loaded_typecorr = 1
 10
 11	let s:save_cpo = &cpo
 12	set cpo&vim
 13
 14	iabbrev teh the
 15	iabbrev otehr other
 16	iabbrev wnat want
 17	iabbrev synchronisation
 18		\ synchronization
 19	let s:count = 4
 20
 21	if !hasmapto('<Plug>TypecorrAdd;')
 22	  map <unique> <Leader>a  <Plug>TypecorrAdd;
 23	endif
 24	noremap <unique> <script> <Plug>TypecorrAdd;  <SID>Add
 25
 26	noremenu <script> Plugin.Add\ Correction      <SID>Add
 27
 28	noremap <SID>Add  :call <SID>Add(expand("<cword>"), 1)<CR>
 29
 30	function s:Add(from, correct)
 31	  let to = input("type the correction for " .. a:from .. ": ")
 32	  exe ":iabbrev " .. a:from .. " " .. to
 33	  if a:correct | exe "normal viws\<C-R>\" \b\e" | endif
 34	  let s:count = s:count + 1
 35	  echo s:count .. " corrections now"
 36	endfunction
 37
 38	if !exists(":Correct")
 39	  command -nargs=1  Correct  :call s:Add(<q-args>, 0)
 40	endif
 41
 42	let &cpo = s:save_cpo
 43	unlet s:save_cpo

A 33. sorra még nem tértünk ki. Alkalmazza az új korrekciót a kurzor alatt
lévő szón. A |:normal| paranccsal használjuk az új korrekciót. A Vim itt a
mappeket és rövidítések itt kibontja (annak ellenére, hogy a mapet
":noremap"-el definiáltuk.

Ajánlott a 'fileformat' opcióhoz "unix" értéket használni. A Vim szkript így
működni fog bármilyen környezetben. A "dos" értékre állított 'fileformat'
esetén szkript nem működik "unix" rendszereken. Lásd |:source-crnl|. A fájl
mentése előtt ezt be kell állítanunk: >

	:set fileformat=unix


DOKUMENTÁCIÓ						*write-local-help*
						        *help-fájlok-készítése*

Ajánlott a beépülőnket dokumentációval ellátni, különösen akkor, ha a
felhasználó a szkript működését nagymértékben befolyásolni tudja. Lásd
|add-local-help| a telepítéshez.

A beépülőnk példa-dokumentációja "typecorr.txt": >

  1	*typecorr.txt*	Plugin for correcting typing mistakes
  2
  3	If you make typing mistakes, this plugin will have them corrected
  4	automatically.
  5
  6	There are currently only a few corrections.  Add your own if you like.
  7
  8	Mappings:
  9	<Leader>a   or   <Plug>TypecorrAdd;
 10		Add a correction for the word under the cursor.
 11
 12	Commands:
 13	:Correct {word}
 14		Add a correction for {word}.
 15
 16							*typecorr-settings*
 17	This plugin doesn't have any settings.

Csak az első sorban számít a formátum. Ezt a Vim be fogja rakni a "LOCAL
ADDITIONS:"-ök közé |local-additions|. Az első sor első karakterének "*"
karakterrel KELL kezdődnie. A fájl megírása után a ":help" paranccsal
ellenőrizzük a bejegyzést.

A helpfájlhoz még több taget adhatunk ** közé zárva. Arra törekednünk kell,
hogy egyedi legyen. Például a "typecorr-" prefixum használata tökéletesen
megfelel e célra. 

A hivatkozásainkat || karakterek közé kell zárnunk, ezzel biztosíthatunk gyors
elérést a társított leírásokhoz.


FÁJLTÍPUS FELISMERÉS					*plugin-filetype*
							*beépülő-filetype*

Ha a Vim nem ismeri fel a fájl típusát, akkor erre a célra egy külön fájlt
kell létrehoznunk. Általában egy autocommandot tartalmaz, ami minta alapján
beállítja a kívánt fájltípust. Például: >

	au BufNewFile,BufRead *.foo			set filetype=foofoo

Mentsük ezt az egy soros fájlt a "ftdetect/foofoo.vim" néven a 'runtimepath'
lista első könyvtárába. Unixon ez "~/.vim/ftdetect/foofoo.vim". A fájl neve a
fájltípus neve lesz.

Ennél még komolyabb ellenőrzéseket végezhetünk például detektál hatjuk a fájl
nyelvét a tartalma alapján. Lásd |new-filetype|.


ÖSSZEFOGLALÁS						*plugin-special*
							*beépülő-speciális*


Összefoglalás a beépülőkben használt funkciókról:

s:name			szkript lokális változója

<SID>			szkript-azonosító, mappekhez és a szkript lokális
			függvényeihez

hasmapto()		a szkriptben használt map definíciójának tesztelése

<Leader>		a "mapleader" értéke, felhasználó által definiált
			billentyű, mellyel a beépülő mapjei kezdődnek

:map <unique>		figyelmeztet, ha a map már létezik

:noremap <script>	a mapet csak a szkript használhatja, globálisan nem
			érhető el

exists(":Cmd")		felhasználói parancs meglétének ellenőrzése

==============================================================================
*41.12*	Filetype beépülő írása		*write-filetype-plugin* *ftplugin*
					*ftplugin-készítése*

A fájltípus beépülő majdnem egy globális beépülő, azzal a kivétellel, hogy a
definiált mappek csak az aktuális bufferre érvényesek. Lásd
|add-filetype-plugin| a használathoz.

Először olvassuk el a globális beépülőkről szóló részt |41.11|. Az összes
említett dolog érvényes a fájltípus beépülőkre is. A kivételeket itt
részletezzük. Az elengedhetetlen tulajdonság az az, hogy csak az aktív
bufferre legyen érvényes.


TILTÁS

Ha olyan fájltípus beépülőt írunk, amit sokan fognak használni, akkor adjuk
lehetőséget a letiltására. Helyezzük el a szkriptben az alábbi két sort: >

	" Only do this when not done yet for this buffer
	if exists("b:did_ftplugin")
	  finish
	endif
	let b:did_ftplugin = 1

Ez egyben azt is megakadályozza, hogy a bufferben a fájl többször is
betöltődjön. (ez akkor történik meg, ha az ":edit" paranccsal, argumentumok
nélkül szerkesztjük magát a beépülőt).

Így a felhasználók a következő sorral tilthatják a fájlt betöltését: >

	let b:did_ftplugin = 1

Ehhez az szükséges, hogy a fájltípus beépülők könyvtára megelőzze a
$VIMRUNTIME könyvtárát a 'runtimepath'-ban!.

Ha a szkript valamelyik beállítását felül szeretnénk írni, akkor  az írjuk ki
egy külön fájlba: >

	setlocal textwidth=70

Ezt pedig mentsük az "after" könyvtárba, ami utolsóként fog betöltődni az
alapértelmezett "vim.vim" ftplugin könyvtára után (|after-directory|). Unix
rendszereken ez "~/.vim/after/ftplugin/vim.vim". 


BEÁLLÍTÁSOK

A fájltípus beépülő csak az aktuális bufferre való hatását így
kényszeríthetjük ki: >

	:setlocal

Amely a ":set" paranccsal egyenértékű azzal a kivétellel, hogy csak az
aktuális buffer opcióit állítja be. Ha |:setlocal| paranccsal globális
változót, vagy ablak-specifikus változót állítunk be, az több bufferre
hatással lesz, ez pedig kerülendő.

Ha az opció típusa lista, akkor fontoljuk meg a "+=" és a "-=" operátor
használatát, mert így a lista megtartja az eredeti értékét. Jó ötlet, ha a
változó inicializálásakor a kezdő értéknek a változó alapértelmezett értékét
adjuk meg (előfordulhat, hogy a felhasználó esetleg már módosította a változót
a beépülő telepítését megelőzően). Például: >

	:setlocal formatoptions& formatoptions+=ro


MAPPEK

A map hozzárendelése a jelenlegi bufferhez: >

	:map <buffer>

Ezt még kombinálnunk kell a fentebb említett map-deklarációval. Példa egy
funkcionalitás létrehozására a fájltípus beépülőben: >

	if !hasmapto('<Plug>JavaImport;')
	  map <buffer> <unique> <LocalLeader>i <Plug>JavaImport;
	endif
	noremap <buffer> <unique> <Plug>JavaImport; oimport ""<Left><Esc>

A |hasmapto()|-val Ellenőrizzük, hogy a felhasználó definiált-e már mappet a 
<Plug>JavaImport;-hoz. Ha nem, akkor a fájltípus beépülő létrehozza az
alapértelmezett mappet. A <LocalLeader> megengedi a felhasználónak, hogy egy
egyedi leader-billentyűvel hívja a mappet. Az alapértelmezett leader key a
backslash "\".
A "<unique>" használata miatt soha nem fogunk hibaüzenetet kapni, ha a map már
létezik, vagy fedésben van az érvényben lévő mappekkel.
A |:noremap| parancs hatására a mapben definiált billentyűleütések nem hívják
meg a már definiált mappeket. Kezdhetjük a map leírását ":noremap <script>"-el
is, így lehetőséget adunk arra, hogy remappeljük a szkriptben <SID>-vel
kezdődő mappeket.

A felhasználónak úgy kell lehetőséget adni a szkript mapjeinek letiltására
anélkül, hogy mindent tiltana. Részlet a mail fájltípusból: >

	" Add mappings, unless the user didn't want this.
	if !exists("no_plugin_maps") && !exists("no_mail_maps")
	  " Quote text by inserting "> "
	  if !hasmapto('<Plug>MailQuote;')
	    vmap <buffer> <LocalLeader>q <Plug>MailQuote;
	    nmap <buffer> <LocalLeader>q <Plug>MailQuote;
	  endif
	  vnoremap <buffer> <Plug>MailQuote; :s/^/> /<CR>
	  nnoremap <buffer> <Plug>MailQuote; :.,$s/^/> /<CR>
	endif

Az implementáció két globális változót használ:
|no_plugin_maps|	az összes fájltípus beépülő mapjeinek a tiltása
|no_mail_maps|		a "mail" fájltípus mapjeinek a tiltása


FELHASZNÁLÓI PARANCSOK

A "-buffer" argumentumot használva a fájltípus beépülő felhasználói parancsai
csak egy bufferben futnak. |:command| Például: >

	:command -buffer  Make  make %:r.s


VÁLTOZÓK

A fájlt típusának megegyezésekor az összes buffer betölti a fájltípus
beépülőt. A szkript lokális változóit |s:var| a bufferek látják, értékét
felülírhatják (az aktuális bufferek osztoznak a változón). Ha kimondottan
buffer-specifikus változót szeretnénk létrehozni (a szkripten belül), akkor
használjuk a |b:var| változókat.


FÜGGVÉNYEK

A függvényeket elég egyszer deklarálnunk. A fájltípus beépülő újbóli betöltése
(új bufferhez), újra és újra felülírja a függvényünket. A következő
megoldás biztosítja, hogy a függvények csak egyszer legyenek deklarálva: >

	:if !exists("*s:Func")
	:  function s:Func(arg)
	:    ...
	:  endfunction
	:endif
<

VISSZAVONÁS				    *undo_indent* *undo_ftplugin*
				  *behúzás_visszavonás* *ftplugin_visszavonás*

Ha a felhasználó a ":setfiletype xyz" módszerrel állítja át a fájltípust,
akkor az előző fájltípus beállításait vissza kell vonnunk. A "b:undo_ftplugin"
változóban helyezzük el azt a parancsot, ami visszaállítja a módosításokat.
Például: >

	let b:undo_ftplugin = "setlocal fo< com< tw< commentstring<"
		\ .. "| unlet b:match_ignorecase b:match_words b:match_skip"

Ha a ":setlocal" parancsot "<" jellel használjuk, az visszaállítja az opciók
globális értékét. Ez az egyik legjobb és legkellemesebb módszer erre a célra.

Ne feledjük, az említett példakód csak akkor működik, ha engedélyezve van a
sor folytatása ("C" flagnek nem szabad szerepelnie a 'cpoptions'-ban), mint
ahogy a |:use-cpo-save| résznél már ezt említettük.

A behúzások visszavonásához a "b:undo_indent" változót is be kell állítanunk
értelemszerűen.


FÁJLNÉV

A fájltípus nevének szerepelni kell a fájl nevében |ftplugin-name|. A három
leggyakoribb alak: 

	.../ftplugin/stuff.vim
	.../ftplugin/stuff_foo.vim
	.../ftplugin/stuff/bar.vim

A fájltípus: "stuff", "foo" és "bar" tetszőleges nevek.


ÖSSZEFOGLALÁS					    *ftplugin-special*
						    *ftplugin-speciális*

A fájltípus beépülő egyedi technikái:

<LocalLeader>		A "maplocalleader" értéke, mellyel a fájltípus beépülő
			mapjei kezdődnek.

:map <buffer>		Buffer-specifikus map

:noremap <script>	Csak a <SID>-vel kezdődő mappek remappelése.

:setlocal		Buffer-specifikus opció beállítása.

:command -buffer	Buffer-specifikus felhasználói parancs

exists("*s:Func")	Függvénynév-definíció ellenőrzés

Továbbá |plugin-special|, a beépülők által használt egyedi dolgok.

==============================================================================
*41.13*	Compiler beépülő írása		*write-compiler-plugin*
					*compiler-beépülő-készítése*

Az ilyen típusú beépülők fordító-specifikus opciókat is beállítanak. Ezeket a
|:compiler| paranccsal tölthetjük be. Azért használjuk, hogy beállítsuk az
'errorformat' és a 'makeprg' parancsokat. 

A legegyszerűbb ezt egy példán szemléltetni. A következő parancs szerkeszti az
összes fordítóval kapcsolatos beépülőt: >

	:next $VIMRUNTIME/compiler/*.vim

A |:next| használatával ugorhatunk a következő fájlra.

A fordító fájloknak két fő feladata van. Az egyik a mechanizmus, amivel a
felhasználó felülírhatja, vagy kiegészítheti az alapértelmezett fájlt. Az
alapértelmezett fájlban az alábbi szerepel: >

	:if exists("current_compiler")
	:  finish
	:endif
	:let current_compiler = "mine"

Ha saját fordító-fájlt írunk, akkor azt tegyük be a saját runtime
könyvtárunkban (például: ~/.vim/compiler Unixon), ezzel átállítjuk a
"current_compiler" értékét és ezzel az alapértelmezett fájl beállításai nem
értelmeződnek.
							*:CompilerSet*
A második mechanizmushoz használjuk a ":set" parancsot a ":compiler!" és a
":setlocal" parancsot a ":compiler" parancshoz. Ezt a műveletet a Vim
megkönnyíti a ":CompilerSet" parancs használatával. A Vim régi verzió sajnos
ezt nem támogatják, így ezt nekünk definiálnunk kell. Például: >

  if exists(":CompilerSet") != 2
    command -nargs=* CompilerSet setlocal <args>
  endif
  CompilerSet errorformat&		" use the default 'errorformat'
  CompilerSet makeprg=nmake

Ha Vim alapértelmezett disztribúciójához (vagy egy rendszerszintű runtime
könyvtárhoz) írjuk, mindenképpen helyezzük el a definíciót a fájlunkban. Ha
"current_compiler" egy felhasználói beépülő már értéket adott, akkor semmit
nem történik.

Ha olyan beépülőt írunk, amely az alapértelmezett beépülő érték írja felül,
akkor nem kell ellenőriznünk a "current_compiler" értékét. Természetesen a
beépülőnket kell utoljára betöltenünk, ezért helyezzük el a 'runtimepath'
utolsó elérési utak egyikében, Unixon ez ~/.vim/after/compiler.

==============================================================================
*41.14*	A gyors beépülő ismérvei		    *write-plugin-quickload*
						    *gyorsan-betöltő-plugin*

A beépülő idővel növekszik és elég hosszúvá válhat. Indításnál ez szembetűnő
lehet, még akkor is, ha alig használjuk a beépülőt. Itt az idő a quickload
beépülő használatára.

Az ötlet, hogy a beépülőt két részletben töltjük be. Először a felhasználói
parancsokat és mappeket, majd a függvénydefiníciókat és stb.

Meglepően hangzik, hogy a quickload valójában két részletbeni betöltést
jelent. Az első rész azonnal betöltődik, de a második rész csak akkor, ha a
beépülő funkcionalitását ténylegesen használjuk. Ha állandóan használjuk a
script funkcionalitását, akkor a szkript mindig lassabb!

A Vim 7-től kezdődően a quickload alternatívája az 'autoload' |41.15|.

Ezt az alábbi példa demonstrálja: >

	" Vim global plugin for demonstrating quick loading
	" Last Change:	2005 Feb 25
	" Maintainer:	Bram Moolenaar <Bram@vim.org>
	" License:	This file is placed in the public domain.

	if !exists("s:did_load")
		command -nargs=* BNRead  call BufNetRead(<f-args>)
		map <F19> :call BufNetWrite('something')<CR>

		let s:did_load = 1
		exe 'au FuncUndefined BufNet* source ' .. expand('<sfile>')
		finish
	endif

	function BufNetRead(...)
		echo 'BufNetRead(' .. string(a:000) .. ')'
		" read functionality here
	endfunction

	function BufNetWrite(...)
		echo 'BufNetWrite(' .. string(a:000) .. ')'
		" write functionality here
	endfunction

A szkript első betöltésénél a "s:did_load" változó nem kap értéket, ezért az
"if" és "endif" közötti utasítások lefutnak, melyet a |:finish| paranccsal
zárunk. A szkript értelmezése itt egyelőre megszakad.

A második alkalommal, az "s:did_load" változónak már van értéke és az "endif"
utáni utasítások lefutnak, melyek betöltik a BufNetRead() és a BufNetWrite()
függvényeket.

Ha a szkriptet bemásoljuk a plugin könyvtárunkba, akkor a Vim azt minden
indításkor lefuttatja. A sorrend a következő:

1. A "BNRead" parancsdefiníció létrejön és az <F19> billentyű elvégzi a
   mappelést (ez fut le a Vim indításakor). A |FuncUndefined| autocommand

2. A felhasználó meghívja a BNRead parancsot, vagy leüti az <F19> billentyűt,
   ezért a BufNetRead() vagy a BufNetWrite() függvény hívást kap.

3. A Vim nem fogja megtalálni a függvényt, ezért a |FuncUndefined| eseményt
   kiváltja. A "BufNet*" minta illeszkedik a függvény nevére, ezért a "source
   fname" parancs lefut. "fname" a szkript nevével lesz egyenlő, a fájl
   elérési útja bármi lehet ('runtimepath'-on belül), mert ezt az "<sfile>"
   kibontásával kapjuk meg (lásd |expand()|).

4. A szkript újból betöltődik, az "s:did_load" változó már létezik és a
   függvénydefiníciók lefutnak.

Vegyük észre, hogy a későbbiekben betöltött függvények neve illeszkedik a
|FuncUndefined| autocommand mintájára. Biztosítanunk kell, hogy más függvény
erre a mintára ne illeszkedjen.

==============================================================================
*41.15*	Szkript könyvtárak írása			*write-library-script*
						*függvénykönyvtárak-készítése*

Egyes funkcionalitást több helyen is használni szeretnénk. Ha a funkcionalitás
terjedelme több pár sornál, akkor az írjuk ki egy új fájlba, elérhetővé téve a
többi szkript számára. Az így létrehozott  szkriptet nevezzük könyvtár
szkriptnek.

A könyvtár szkript manuális betöltése lehetséges az |exists()| függvénnyel: >

	if !exists('*MyLibFunction')
	   runtime library/mylibscript.vim
	endif
	call MyLibFunction(arg)

Tudnunk kell, hogy a MyLibFunction() a "library/mylibscript.vim" fájlban van
definiálva a 'runtimepath' könyvtárak egyikében.

Hogy ezt leegyszerűsítsük, használjuk a Vim autoload mechanizmusát: >

	call mylib#my function(arg)

Sokkal egyszerűbb, ugye? A Vim felismerte a függvény nevét, mivel ez nem volt
definiálva, megkereste az "autoload/mylib.vim" fájlt a 'runtimepath'-ban.
A szkriptek muszáj definiálnia a "mylib#myfunction()" függvényt.

A mylib.vim fájlba annyi függvényt tehetünk, amennyi jól esik. Ha így
teszünk, akkor a '#' előtt a megfelelő szkript nevét kell használnunk
(ellenkező esetben a Vim nem tudja eldönteni, hogy melyik szkriptet töltse
be).

Szkriptjeinket szervezhetjük alkönyvtárakba is. Például: >

	call netlib#ftp#read('somefile')

Unixon a könyvtár szkriptek elérése útja általában: >

	~/.vim/autoload/netlib/ftp.vim

Melyekben a függvényeinket így definiáljuk: >

	function netlib#ftp#read(fname)
		"  Read the file fname through ftp
	endfunction

A függvény neve a függvényhívási paranccsal megegyezik. A '#' előtti rész
természetesen követi a fájl elhelyezkedési struktúráját.

Változókat létrehozása hasonlóképpen: >

	let weekdays = dutch#weekdays

Így a változót az "autoload/dutch.vim" fájlból töltjük be, ami valami hasonlót
rejt: >

	let dutch#weekdays = ['zondag', 'maandag', 'dinsdag', 'woensdag',
		\ 'donderdag', 'vrijdag', 'zaterdag']

Lásd: |autoload|.

==============================================================================
*41.16*	Vim Szkriptek megosztása			    *distribute-script*
							 *szkriptek-megosztása*

A Vim felhasználók a szkriptjeiket a Vim oldaláról szerzik be
http://www.vim.org. Amennyiben készítettél valami hasznosat, akkor ne habozz
azt megosztani!

A Vim szkriptek bármilyen rendszeren futtathatóak. Tar és gzip azonban egyes
rendszereket nem érhető el alapértelmezetten, így munkádat készítsd el "zip"
formátumban.

A legjobb hordozhatóság érdekében használjuk a Vimet a szkriptfájlok
összeállításához |vimball|.

Fontoljuk meg, hogy elérhetővé tesszük a szkript automatikus frissítését (egy
sor mindösszesen).  Lásd |guvs-plugins|.

==============================================================================

Következő fejezet: |usr_42.txt|  Új menük létrehozása

Jogi információk: lásd |manual-copyright|  vim:tw=78:ts=8:noet:ft=help:norl:
